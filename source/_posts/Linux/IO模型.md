---
title: IO模型
categories: 
- Linux
---

**同步和异步**

同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪。

异步指的是用户进程触发IO操作以后便开始做其他的事情，而当IO操作已经完成的时候会得到IO完成的通知

**阻塞与非阻塞**

阻塞指的是当试图对该文件描述符进行读写时，如果当时没有东西可读，或暂时不可写，程序就进入等待状态，直到有东西可读或可写为止。

非阻塞指的是如果没有东西可读，或不可写，读写函数马上返回，而不会等待。

**同步阻塞IO**

JAVA传统的BIO属于此种方式

在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当IO操作完成之后，用户进程才能运行。

**同步非阻塞IO**

JAVA的NIO就属于同步非阻塞IO

在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。

**多路复用IO**

多路复用实现了一个线程处理多个 I/O 句柄的操作。

select、poll、epoll 都是 I/O 多路复用的具体实现

select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程

**信号驱动式IO模型**

在unix系统中，应用程序发起IO请求时，可以给IO请求注册一个信号函数，请求立即返回，操作系统底层则处于等待状态（等待数据就绪），直到数据就绪，然后通过信号通知主调程序，主调程序才去调用系统函数recvfrom()完成IO操作。

信号驱动也是一种非阻塞式的IO模型，比起上面的非阻塞式IO模型，信号驱动式IO模型不需要轮询检查底层IO数据是否就绪，而是被动接收信号，然后再调用recvfrom执行IO操作。

比起多路复用IO模型来说，信号驱动IO模型针对的是一个IO的完成过程， 而多路复用IO模型针对的是多个IO同时进行时候的场景。

**异步IO**

在此种模式下，将整个IO操作（包括等待数据就绪，复制数据到应用程序工作空间）全都交给操作系统完成。

数据就绪后操作系统将数据拷贝进应用程序运行空间之后，操作系统再通知应用程序，这个过程中应用程序不需要阻塞。

**举个现实生活中的例子：**

如果你想吃一份卤肉饭，

同步阻塞：你到饭馆点餐，然后在那儿等着，还要一直喊：好了没啊！

同步非阻塞：在饭馆点完餐，就去遛狗了。不过遛一会儿，就回饭馆喊一声：好了没啊！

多路复用：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。

异步非阻塞：饭馆打电话说，我们知道您的位置，一会儿给你送过来，安心遛狗就可以了。

**BIO/NIO/AIO适用场景**

BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。

NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。

AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。