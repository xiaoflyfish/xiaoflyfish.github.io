---
title: 线程模型
categories: 
- Linux
---

# Reactor

## 单Reactor单线程

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201216220529.png" alt="img" style="zoom:33%;" />

Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发

如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理

如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应

## 单Reactor多线程

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201216220748.png" alt="img" style="zoom:33%;" />

Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发

如果建立连接请求, 则由 Acceptor 通过 accept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件

如果不是连接请求，则由 Reactor 分发调用连接对 应的Handler 来处理

Handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的 Worker 线程池的某个线程处理业务

Worker 线程池会分配独立线程完成真正的业务， 并将结果返回给 Handler

Handler 收到响应后，通过 send 将结果返回给 Client

## 主从Reactor多线程

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201217114744.png" alt="img" style="zoom:33%;" />

Reactor 主线程 MainReactor 对象通过 select 监听连接事件, 收到事件后，通过 Acceptor 处理连接事件(主 Reactor 只处理连接事件)

当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor

SubReactor 将连接加入到连接队列进行监听,并创建 Handler 进行各种事件处理

当有新事件发生时， SubReactor 就会调用对应的 Handler处理

Handler 通过 read 读取数据，分发给后面的 （Worker 线程池）处理

（Worker 线程池）分配独立的 （Worker 线程）进行业务处理，并返 回结果

Handler 收到响应的结果后，再通过 send 将结果返回给 Client

一个 MainReactor 可以关联多个 SubReactor

# Proactor

流程与Reactor模式类似，区别在于proactor在IO ready事件触发后，完成IO操作再通知应用回调

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201217130706.png" alt="img" style="zoom:33%;" />

Reactor模式是一种被动的处理，即有事件发生时被动处理。而Proator模式则是主动发起异步调用，然后循环检测完成事件。

**Netty的线程模型**

Netty的线程模型可以在以上三种Reactor模型之间进行切换