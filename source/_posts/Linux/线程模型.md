---
title: 线程模型
categories: 
- Linux
---

在高性能的I/O设计中，有两个著名的模型：Reactor模型和Proactor模型，其中Reactor模型用于同步I/O，而Proactor模型运用于异步I/O操作

# Reactor

无论是C++还是Java编写的网络框架，大多数都是基于Reactor模型进行设计和开发，Reactor模型基于事件驱动，特别适合处理海量的I/O事件

Reactor模型中定义的三种角色：

- Reactor：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。
- Acceptor：处理客户端新连接，并分派请求到处理器链中。
- Handler：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理。

## 单Reactor单线程

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201216220529.png" alt="img" style="zoom:33%;" />

Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发

如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理

如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应

## 单Reactor多线程

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201216220748.png" alt="img" style="zoom:33%;" />

Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发

如果建立连接请求, 则由 Acceptor 通过 accept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件

如果不是连接请求，则由 Reactor 分发调用连接对 应的Handler 来处理

Handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的 Worker 线程池的某个线程处理业务

Worker 线程池会分配独立线程完成真正的业务， 并将结果返回给 Handler

Handler 收到响应后，通过 send 将结果返回给 Client

## 主从Reactor多线程

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201217114744.png" alt="img" style="zoom:33%;" />

Reactor 主线程 MainReactor 对象通过 select 监听连接事件, 收到事件后，通过 Acceptor 处理连接事件(主 Reactor 只处理连接事件)

当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor

SubReactor 将连接加入到连接队列进行监听,并创建 Handler 进行各种事件处理

当有新事件发生时， SubReactor 就会调用对应的 Handler处理

Handler 通过 read 读取数据，分发给后面的 （Worker 线程池）处理

（Worker 线程池）分配独立的 （Worker 线程）进行业务处理，并返 回结果

Handler 收到响应的结果后，再通过 send 将结果返回给 Client

一个 MainReactor 可以关联多个 SubReactor

# Proactor

流程与Reactor模式类似，区别在于proactor在IO ready事件触发后，完成IO操作再通知应用回调

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201217130706.png" alt="img" style="zoom:33%;" />

Reactor模式是一种被动的处理，即有事件发生时被动处理。而Proator模式则是主动发起异步调用，然后循环检测完成事件。

**Netty的线程模型**

Netty的线程模型可以在以上三种Reactor模型之间进行切换

Proactor有如下缺点：

1. 编程复杂性，由于异步操作流程的事件的初始化和事件完成在时间和空间上都是相互分离的，因此开发异步应用程序更加复杂。应用程序还可能因为反向的流控而变得更加难以Debug；
2. 内存使用，缓冲区在读或写操作的时间段内必须保持住，可能造成持续的不确定性，并且每个并发操作都要求有独立的缓存，相比Reactor模型，在Socket已经准备好读或写前，是不要求开辟缓存的；
3. 操作系统支持，Windows下通过IOCP实现了真正的异步 I/O，而在Linux系统下，Linux2.6才引入，并且异步I/O使用epoll实现的，所以还不完善。

因此在 Linux 下实现高并发网络编程都是以Reactor模型为主