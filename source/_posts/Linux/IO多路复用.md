---
title: IO多路复用
categories: 
- Linux
---

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程

目前支持I/O多路复用的系统调用有 `select，pselect，poll，epoll`

I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作

但`select，pselect，poll，epoll`本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间

# select

select 函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，通过遍历`fdset`，来找到就绪的描述符。

**缺点**

select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由`FD_SETSIZE`设置，默认值是1024

对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低

# poll

poll本质上和`select`没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个`fd`对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历

它没有最大连接数的限制，原因是它是基于链表来存储的

poll还有一个特点是**水平触发**，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd

# epoll

epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次

epoll使用事件的就绪通知方式，通过`epoll_ctl`注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，`epoll_wait`便可以收到通知

epoll是被动触发方式，给fd注册了相应事件的时候，我们为每一个fd指定了一个回调函数，当数据准备好之后，就会把就绪的fd加入一个就绪的队列中，`epoll_wait`的工作方式实际上就是在这个就绪队列中查看有没有就绪的fd，如果有，就唤醒就绪队列上的等待者，然后调用回调函数

**优点：**

没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。

效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即`Epoll`最大的优点就在于它只管你活跃的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。

内存拷贝，利用`mmap()`文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销

**文件描述符的操作有两种模式：LT和ET**

LT模式是默认模式，LT模式与ET模式的区别如下：

LT模式：当`epoll_wait`检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用`epoll_wait`时，会再次响应应用程序并通知此事件。

ET模式：当`epoll_wait`检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用`epoll_wait`时，不会再次响应应用程序并通知此事件。

**选择**

表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。

select低效是因为每次它都需要轮询

**epoll的核心是3个API，核心数据结构是：1个红黑树和1个链表**

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210214150916.png" style="zoom:33%;" />