---
title: 基本使用
categories: 
- 消息队列
- RabbitMQ
---

安装教程：https://www.rabbitmq.com/install-debian.html

# 基本命令行操作

**关于服务的操作：**

1. 服务启动：`rabbitmqctl start_app` / `rabbitmq-server start &`

2. 服务停止：`rabbitmqctl stop_app` / `rabbitmq-server stop`

3. 服务重启：`service rabbitmq-server restart`

4. 节点状态：`rabbitmqctl status`

**关于用户的操作：**

1. 添加用户：`rabbitmqctl add_user username password`
2. 列出所有用户：`rabbitmqctl list_users`
3. 删除用户：`rabbitmqctl delete_user username`
4. 清除用户权限：`rabbitmqctl clear_permissions -p vhostpath username`
5. 列出用户权限：`rabbitmqctl list_user_permissions username`
6. 修改密码：`rabbitmqctl change_password username newpassword`
7. 设置用户权限：`rabbitmqctl set_permissions -p vhostpath username ".*" ".*" ".*"`

**关于虚拟主机的操作：**

1. 创建虚拟主机：`rabbitmqctl add_vhost vhostpath`
2. 列出所有虚拟主机：`rabbitmqctl list_vhost`
3. 列出虚拟主机上所有权限：`rabbitmqctl list_permissions -p vhostpath`
4. 删除虚拟主机：`rabbitmqctl delete_vhost vhostpath`

**关于消息队列的操作：**

1. 查看所有队列信息：`rabbitmqctl list_queues`
2. 清除队列里的消息：`rabbitmqctl -p vhostpath purge_queue blue`

**高级命令**

1. `rabbitmqctl reset`：移除所有数据，要在`rabbitmqctl stop_app`之后使用
2. 组成集群命令：`rabbitmqctl join_cluster  [--ram]` （ram内存级别存储，disc磁盘）
3. 查看集群状态：`rabbitmqctl cluster_status`
4. 修改集群节点的存储形式：`rabbitmqctl change_cluster_node_type disc | ram`
5. 忘记（摘除）节点：`rabbitmqctl forget_cluster_node [--offline]` （offline服务不启动的情况下）
6. 修改节点名称：`rabbitmqctl rename_cluster_node oldnode1 newnode1 [oldnode2] [newnode2 ...]`

> 集群配置失败，故障转移等情况下可以将启动失败的节点给移除掉。它可以在不启动的情况下对节点的摘除

# 入门使用

引入RabbitMQ依赖：

```xml
<dependency>
	<groupId>com.rabbitmq</groupId>
	<artifactId>amqp-client</artifactId>
	<version>3.6.5</version>
</dependency>
```

创建一个生产者

```java
public class Producer {

    private static final String QUEUE_NAME = "test01";

    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂并配置
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost("192.168.58.129");
        connectionFactory.setPort(5672);
        // 设置虚拟机
        connectionFactory.setVirtualHost("/test");
        // 2. 通过连接工厂建立连接
        Connection connection = connectionFactory.newConnection();

        // 3. 通过connection创建Channel
        Channel channel = connection.createChannel();

        // 4. 通过Channel发送数据 (exchange, routingKey, props, body)
        // 不指定Exchange时, 交换机默认是AMQP default, 此时就看RoutingKey
        // RoutingKey要等于队列名才能被路由, 否则消息会被删除
        for (int i = 0; i < 5; i++) {
            String msg = "Learn For RabbitMQ-" + i;
            channel.basicPublish("", QUEUE_NAME, null, msg.getBytes());
            System.out.println("Send message : " + msg);
        }

        // 5.关闭连接
        channel.close();
        connection.close();
    }
}
```

创建一个消费者

```java
public class Consumer {

    private static final String QUEUE_NAME = "test01";

    public static void main(String[] args) throws IOException, TimeoutException {
        // 1. 创建连接工厂并配置
        ConnectionFactory connectionFactory = new ConnectionFactory();
        connectionFactory.setHost("192.168.58.129");
        connectionFactory.setPort(5672);
        // 设置虚拟机
        connectionFactory.setVirtualHost("/test");
        // 2. 通过连接工厂建立连接
        Connection connection = connectionFactory.newConnection();

        // 3. 通过connection创建Channel
        Channel channel = connection.createChannel();

        // 4. 声明队列 (queue, durable, exclusive, autoDelete, args)
        channel.queueDeclare(QUEUE_NAME, true, false, false, null);

        // 5. 创建消费者
        DefaultConsumer defaultConsumer = new DefaultConsumer(channel) {
            /**
             * 获取消息 （监听到有消息时调用）
             * @param consumerTag 消费者标签, 在监听队列时可以设置autoAck为false,即手动确认（避免消息的丢失）, 消息唯一性处理
             * @param envelope 信封
             * @param properties 消息的属性
             * @param body 消息的内容
             * @throws IOException
             */
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String msg = new String(body, "utf-8");
                System.out.println("Received message : " + msg);
            }
        };

        // 6. 设置Channel, 监听队列(String queue, boolean autoAck,Consumer callback)
        channel.basicConsume(QUEUE_NAME, true, defaultConsumer);


    }
}
```

**参数：**

- `queue`：队列名称
- `durable`：持久化，true 即使服务重启也不会被删除
- `exclusive`：独占，true 队列只能使用一个连接，连接断开队列删除
- `autoDelete`：自动删除，true 脱离了Exchange（连接断开），即队列没有Exchange关联时，自动删除
- `arguments`：扩展参数
- `autoAck`：是否自动签收（回执）

不指定Exchange时，交换机默认是AMQP default，此时就看`RoutingKey`，RoutingKey要等于队列名才能被路由，否则消息会被删除

**交换机属性**

`Name`：交换机名称

`Type`：交换机类型—— direct、topic、fanout、header

`Durability`：是否需要持久化，true为持久化

`Auto Delete`：当最后一个绑定到Exchange上的队列删除后，即Exchange上没有队列绑定，自动删除该Exhcange

`Internal`：当前Exchange是否用于RabbitMQ内部使用，大多数使用默认False

`Arguments`：扩展参数，用于扩展AMQP协议定制化使用

> **Direct Exchange**：

```java
 // Consumer
 // 声明交换机: 
 // (String exchange, String type, boolean durable, boolean autoDelete, boolean internal, Map<String, Object) arguments)
 channel.exchangeDeclare("exchangeName", BuiltinExchangeType.DIRECT, true, false, false, null);

 // 声明队列 (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object) args)
 channel.queueDeclare("queueName", true, false, false, null);
 
 // 建立绑定关系:
 channel.queueBind("queueName", "exchangeName", "routingKey");
 // ===================================================================
 // Producer
 // 发送消息 (String exchange, String routingKey, BasicProperties props, Bytes[] body)
 channel.basicPublish("exchangeName", "routingKey", null, "msg".getBytes());
```

> **Topic Exchange**：

```java
 // Consumer
 // 声明交换机: 
 // (String exchange, String type, boolean durable, boolean autoDelete, boolean internal, Map<String, Object) arguments)
 channel.exchangeDeclare("exchangeName", BuiltinExchangeType.TOPIC, true, false, false, null);

 // 声明队列 (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object) args)
 channel.queueDeclare("queueName", true, false, false, null);
 
 // 建立绑定关系:
 channel.queueBind("queueName", "exchangeName", "routingKey.#");
 // ===================================================================
 // Producer
 // 发送消息 (String exchange, String routingKey, BasicProperties props, Bytes[] body)
 channel.basicPublish("exchangeName", "routingKey.hi", null, "msg".getBytes());
 channel.basicPublish("exchangeName", "routingKey.save", null, "msg".getBytes());
 channel.basicPublish("exchangeName", "routingKey.save.hi", null, "msg".getBytes());
```

因为使用了模糊匹配的"`#`"，可以匹配到发送的三条消息。因此可以收到三条消息

> **Fanout Exchange**：

```java
 // Consumer
 // 声明交换机: 
 // (String exchange, String type, boolean durable, boolean autoDelete, boolean internal, Map<String, Object) arguments)
 channel.exchangeDeclare("exchangeName", BuiltinExchangeType.FANOUT, true, false, false, null);

 // 声明队列 (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object) args)
 channel.queueDeclare("queueName", true, false, false, null);
 
 // 建立绑定关系: 
 //（不设置routingKey, 这里为空）
 channel.queueBind("queueName", "exchangeName", "");
 // ===================================================================
 // Producer
 // 发送消息 (String exchange, String routingKey, BasicProperties props, Bytes[] body)
 // 同样routingKey为空 （也可以是任意字符串, 因为fanout并不依据routingKey）
 channel.basicPublish("exchangeName", "", null, "msg".getBytes());
```



