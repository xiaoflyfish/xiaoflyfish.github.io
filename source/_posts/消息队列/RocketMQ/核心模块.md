---
title: 核心模块
categories: 
- 消息队列
- RocketMQ
---

有四大核心模块，从生产者发送消息到消费者消费经历过以下的流程：

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214165455.png)

先以 Producer 角度来说，与其中一个 ns 建立长链接，然后定期发送心跳维持状态，获取 Topic 主题路由信息，然后与 Broker Master 建立长链接，定期发送心跳判断是否可用。根据发送消息的类型，判断是否需要 Broker 的返回值。

从 Consumer 角度来说，与 Producer 不同点在于，它可以从 Broker Master 订阅消息，也能够从 Broker Salve 订阅消息。

由于 RocketMQ 是纯 Java 语言编写的，所以可以在 Github 中下载源码，查看每个模块的详细设计

# Nameserver

Nameserver 来管理消息订阅，消息发送和消费信息，集群中的各个服务需要通过 Nameserver 来了解各自的状态。

有点像 Dubbo 中的注册中心 Zookeeper，NameServer 中维护着 Producer 集群、Broker 集群、 Consumer 集群的服务状态。

通过定时（默认是 30s）发送心跳数据包进行维护更新各个服务的状态。

1. 接收 Broker 的请求，注册 Broker 的路由信息
2. 接口 Client 的请求，根据某个 Topic 获取其到 Broker 的路由信息

NameServer 没有状态，可以横向扩展。每个 Broker 在启动的时候会到NameServer 注册；Producer 在发送消息前会根据 Topic 到 NameServer 获取路由(到 Broker)信息；Consumer 也会定时获取 Topic 路由信息。

关于 Namesrv，了解上述概念后，可以在代码中查看具体的启动流程：

```java
org.apache.rocketmq.namesrv.NamesrvStartup#main
```

# Broker

Broker 的定位是消息代理存储服务器，职责是负责持久化消息还有管理消息消费的进度。

介绍一下它的特性：

1. 与所有 Namesrv 节点保持长链接和心跳，定时（默认 30s）将 Topic 信息注册到 Namesrv。
2. 负责存储消息，以 Topic 为维度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。
3. 具有上亿级消息堆积能力，同时可以严格保证消息的有序性。

具体启动代码入口在：

```java
org.apache.rocketmq.broker.BrokerStartup#main
```

# Producer

消息发送者，往消息队列发送消息的主体角色。

下图是 RocketMQTemplate 调用 convertAndSend 方法调用的时序图：

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214170005.png)

核心步骤在 DefaultMQProducerImpl 的发送实现方法，底层选择要发往的 MessageQueue，执行前置钩子、通过 NettyClinet 来发送请求，发送完成后执行后置钩子，最后返回 SendResult。

具体可以在 SpringBoot 中引入 RocketMQ-Starter 依赖，然后发送消息，查看整体调用链路。

# Consumer

一个消费者分组中，可以设定很多个 Listener，来分别消费不同 Topic 下的消息。

在消息消费时，需要通过 ConsumerGroup + Topic + Tag 来唯一确定 Listener。

所以同一个消费组、同一个主题下，不可以出现相同 Tag 的 Listener，应用在启动时会报错。

具体 Consumer 启动时的代码入口在这里：

```java
org.apache.rocketmq.spring.support.DefaultRocketMQListenerContainer#start
```