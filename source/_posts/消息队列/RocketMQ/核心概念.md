---
title: 核心概念
categories: 
- 消息队列
- RocketMQ
---

核心组件有四个 **Nameserver、Broker、Producer、Consumer**

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214135621.png)

# Topic

消息主题，是一种消息的逻辑分类，例如这类消息属于哪类操作。例如库存相关、订单相关、活动相关等。理解成一种抽象的分类规范，大家的操作按照 Topic 进行分类，不同的 Producer 将消息发送到指定的 Topic，不同的 Consumer 订阅指定的 Topic，从上面拉取消息消费，屏蔽了底层的消息存储。

# Tag

对 Topic 进一步细化，在阿里云官方文档有这行注释 Message Tag，可理解为 Gmail 中的标签，对消息进行再归类，方便 Consumer 指定过滤条件在消息队列 RocketMQ 版的服务器过滤

[Topic与Tag最佳实践](https://help.aliyun.com/document_detail/95837.html?spm=a2c4g.11186623.2.11.310f425cg0Epwr#concept-2047146)

# Message

它是消息队列中 消息传递的载体。

发送消息是指发送到某个主题 Topic 下，其中每条消息包括以下几部分：

**Message ID**

消息的全局唯一标识，由 RocketMQ 发送过程中自动生成，唯一标识某条信息

**Message key**

消息的业务标识，由消息生产者 Producre 设置，唯一标识某个业务逻辑。

**Message Body**

消息携带的内容体，一般在这里自定义传递的内容，记得要将消息内容序列化

**MessageQueue**

前面提到的 Topic 是抽象概念，实际发送消息和消费消息的地方是 Message Queue，每个 Topic 下可能有多个消息队列。

引入队列的原因是为了提高可用性和灵活性，按照队列的性质 FIFO，先发送的消息先消费。

例如默认情况下，一个 Topic 会分配四个 Message Queue（参数配置：defaultTopicQueueNums），如果有两个 Broker，那将会平分两个

消息发送的目的地和消费的获取源就是 Message Queue

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214141314.png)

# Group

分组信息，一个组可以订阅多个 Topic。

具体可以分为 Producer Group 和 Consumer Group，一个应用里都可以建立多个发送者组和消费者组，不过推荐的用法是一个应用指定一个 Producer Group，统一消息发送者的信息。

一般一个应用只需设定一个消费者组，单独订阅主题进行消费。如果一个 Topic 在一个应用中想设定两个处理逻辑，那么可以配置不同的消费者分组，可以实现对同一个主题消息设定不同的处理者 Handler

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214141639.png)

# Offset

位移量，用来保存消息消费的进度。

从上面了解到，一个 Broker 下会有多个 Message Queue，我们需要用一个下标来记录消息消费的位置。通过 Offset 可以定位到目前消费完成的消息位置，指示 Consumer 下一条要从 Offest 后面位置消费消息。

在代码中，Offset 是 long 基础类型，根据它来访问 Message Queue 指定位置的消息。

# Order

消息有序性

一种按照顺序进行发布和消费的消息类型，分为 全局顺序消息和分区顺序消息。

**全局顺序：**

这个比较好理解，对于同一个 Topic 的消息，无论消费者有多少个，消息出队只能一个一个按照顺序来，下一个 Message 的消费依赖于前一个消费完成。

适用于性能要求不高的场景，不过基本挺少选择该模式。

**分区顺序：**

通过某个 Sharding Key 来进行区块分区。同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。

这里是文档中举的例子：

电商的订单创建，以订单 ID 作为 Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。

可以通过 Sharding Key 来保证同一类型、用户的消息顺序发送和消费，既保证了高并发处理消息，也保障了业务上的连贯性。

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214152107.png)

上图展示的是 分区顺序，从代码实现来说，需要设定自定义 Selector，然后对入参 arg 进行解析和根据策略选择 mq，例如常见的哈希取模，选择策略可以参考这个类 ：SelectMessageQueueByHash

# 消息消费模式

在 RocketMQ 中，实现的消费模式有两种

拉（PULL）模式： Consumer 主动从消息服务器 Broker 获取消息。

推（PUSH）模式： 消息服务器 Broker 主动推送消息到 Consumer。

MQPullConsumer： 取消息的过程需要用户自己写，首先通过打算消费的Topic 拿到 MessageQueue 的集合，遍历 MessageQueue 集合，然后针对每个 MessageQueue 批量取消息，一次取完后，记录该队列下一次要取的开始offset，直到取完了，再换另一个 MessageQueue。

MQPushConsumer： consumer 把轮询过程封装了，并注册 MessageListener 监听器，取到消息后，唤醒 MessageListener 的 consumeMessage() 来消费，对用户而言，感觉消息是被推送（push）过来的。

查看 SpringBoot 里面的 @RocketMQMessageListener 注解实现方式和团队使用二次封装的 RocketMQ，发现使用的都是 MQPushConsumer，封装好了 pull 轮询过程，所以可以认为，RocketMQ 使用的是 Pull 拉取模式的消费模式。

# 消息重复

**消息的语义有三种：**

> 最多一次（At most once）
>
> 最少一次（At least once）
>
> 精确一次（Exactly once）

由于网络波动原因，无法避免消息在网络传输时，发送端认为第一次发送失败后，进行发送重试

于是乎我们要解决的问题可以理解成：两条一样的消息，如何保证程序处理正确？

**目前常见的做法有两种：**

1、保证消息的幂等性

2、消息系统过滤重复的消息，或者消费端过滤重复的消息

消息去重： 这个比较好理解，每条消息带有全局唯一的 Message ID，可以在消息系统 Broker 处进行过滤，也可以在消费者 Consumer 处进行过滤。

目前在介绍中，没看到 RocketMQ 在 Broker 处进行过滤去重，所以需要在消费者端进行过滤。可以考虑新增一张数据库表，记录处理过的 Message ID，如果遇到重复的消息就不再进行处理，在处理中的消息可以先放入 Redis，避免同时消费一样的消息