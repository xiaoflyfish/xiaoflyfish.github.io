---
title: 消息丢失
categories: 
- 消息队列
- KAFKA
---

**生产者程序丢失数据**

目前 Kafka Producer 是异步发送消息的，也就是说如果你调用的是 `producer.send(msg) `这个 API，那么它通常会立即返回，但此时你不能认为消息发送已成功完成。

也就是说不要使用 `producer.send(msg)`，而要使用 `producer.send(msg, callback)`

```java
ListenableFuture<SendResult<String, Object>> future = kafkaTemplate.send(topic, o);
future.addCallback(result -> logger.info("生产者成功发送消息到topic:{} partition:{}的消息", result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),
ex -> logger.error("生产者发送消失败，原因：{}", ex.getMessage()));
```

另外这里推荐为 Producer 的`retries`（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了

**消费者程序丢失数据**

当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。

解决办法也比较粗暴，我们手动关闭闭自动提交 offset，每次在真正消费完消息之后之后再自己手动提交 offset 。 这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。

**最佳实践**

> 不要使用 producer.send(msg)

而要使用 `producer.send(msg, callback)`，一 定要使用带有回调通知的 send 方法。

> 设置 retries 为一个较大的值

这里的 retries 同样是 Producer 的参数，对应前面提到 的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries > 0 的 Producer 能够自动重试消息发送，避免消息丢失。

> 设置 acks = all

acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 acks = all 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。

> 设置 replication.factor >= 3

为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 `replication.factor >= 3`。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。

> 设置 min.insync.replicas > 1

一般情况下我们还需要设置 `min.insync.replicas> 1` ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。`min.insync.replicas` 的默认值为 1 ，在实际生产中应尽量避免默认值 1。

> 设置 unclean.leader.election.enable = false

Kafka 0.11.0.0版本开始 `unclean.leader.election.enable` 参数的默认值由原来的true 改为false

我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 `unclean.leader.election.enable = false ` 的话，当 leader 副本发生故障时就不会从  follower 副本中和 leader 同步程度达不到要求的副本中选择出  leader ，这样降低了消息丢失的可能性。

> 确保消息消费完成再提交

Consumer 端有个参数 `enable.auto.commit`，最好把它设 置成 false，并采用手动提交位移的方式，这对于单Consumer 多线程 处理的场景而言是至关重要的。