---
title: 循环依赖
categories: 
- Spring
---

循环依赖，其实就是循环引用，就是两个或者两个以上的 bean 互相引用对方，最终形成一个闭环，如 A 依赖 B，B 依赖 C，C 依赖 A

**Spring循环依赖的情况有两种：**

构造器的循环依赖，field属性的循环依赖

对于构造器的循环依赖，Spring 是无法解决的，只能抛出 `BeanCurrentlyInCreationException` 异常

**源码：**

```java
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    // 从一级缓存缓存 singletonObjects 中加载 bean
    Object singletonObject = this.singletonObjects.get(beanName);
    // 缓存中的 bean 为空，且当前 bean 正在创建
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        // 加锁
        synchronized (this.singletonObjects) {
            // 从 二级缓存 earlySingletonObjects 中获取
            singletonObject = this.earlySingletonObjects.get(beanName);
            // earlySingletonObjects 中没有，且允许提前创建
            if (singletonObject == null && allowEarlyReference) {
                // 从 三级缓存 singletonFactories 中获取对应的 ObjectFactory
                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    //从单例工厂中获取bean
                    singletonObject = singletonFactory.getObject();
                    // 添加到二级缓存
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    // 从三级缓存中删除
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return singletonObject;
}
```

循环依赖涉及的3个关键的变量，分别是3个级别的缓存，定义如下：

```java
//单例bean的缓存 一级缓存
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
 
//单例对象工厂缓存 三级缓存
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
 
//预加载单例bean缓存 二级缓存
//存放的 bean 不一定是完整的
private final Map<String, Object> earlySingletonObjects = new HashMap<>(16)
```

一级缓存里面是完整的Bean,是当一个Bean完全创建后才put

三级缓存是不完整的BeanFactory,是当一个Bean在new之后就put(没有属性填充、初始化)

二级缓存是存储三级缓存创建的Bean

**循环依赖解决过程：**

首先，尝试从一级缓存`singletonObjects`中获取单例Bean

如果获取不到，则从二级缓存`earlySingletonObjects`中获取单例Bean

如果仍然获取不到，则从三级缓存`singletonFactories`中获取单例BeanFactory

最后，如果从三级缓存中拿到了BeanFactory，则通过`getObject()`把Bean存入二级缓存中，并把该Bean的三级缓存删掉

**为什么多例模式不能解决循环依赖呢？**

因为多例模式下每次new() Bean都不是一个，如果按照这样存到缓存中，就变成单例了

**一二三级缓存下二级缓存的意义：**

二级缓存为了存储 三级缓存的创建出来的早期Bean， 为了避免三级缓存重复执行。