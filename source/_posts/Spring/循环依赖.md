---
title: 循环依赖
categories: 
- Spring
---

循环依赖，其实就是循环引用，就是两个或者两个以上的 bean 互相引用对方，最终形成一个闭环，如 A 依赖 B，B 依赖 C，C 依赖 A

**Spring循环依赖的情况有两种：**

构造器的循环依赖，field属性的循环依赖

对于构造器的循环依赖，Spring 是无法解决的，只能抛出 `BeanCurrentlyInCreationException` 异常

**源码：**

```java
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    // 从一级缓存缓存 singletonObjects 中加载 bean
    Object singletonObject = this.singletonObjects.get(beanName);
    // 缓存中的 bean 为空，且当前 bean 正在创建
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        // 加锁
        synchronized (this.singletonObjects) {
            // 从 二级缓存 earlySingletonObjects 中获取
            singletonObject = this.earlySingletonObjects.get(beanName);
            // earlySingletonObjects 中没有，且允许提前创建
            if (singletonObject == null && allowEarlyReference) {
                // 从 三级缓存 singletonFactories 中获取对应的 ObjectFactory
                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    //从单例工厂中获取bean
                    singletonObject = singletonFactory.getObject();
                    // 添加到二级缓存
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    // 从三级缓存中删除
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return singletonObject;
}
```

循环依赖涉及的3个关键的变量，分别是3个级别的缓存，定义如下：

```java
//单例bean的缓存 一级缓存
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
 
//单例对象工厂缓存 三级缓存
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
 
//预加载单例bean缓存 二级缓存
//存放的 bean 不一定是完整的
private final Map<String, Object> earlySingletonObjects = new HashMap<>(16)
```

一级缓存里面是完整的Bean,是当一个Bean完全创建后才put

三级缓存是不完整的BeanFactory,是当一个Bean在new之后就put(没有属性填充、初始化)

二级缓存是存储三级缓存创建的Bean

**循环依赖解决过程：**

首先，尝试从一级缓存`singletonObjects`中获取单例Bean

如果获取不到，则从二级缓存`earlySingletonObjects`中获取单例Bean

如果仍然获取不到，则从三级缓存`singletonFactories`中获取单例BeanFactory

最后，如果从三级缓存中拿到了BeanFactory，则通过`getObject()`把Bean存入二级缓存中，并把该Bean的三级缓存删掉

**三级缓存**

看看下存储缓存的代码

在 AbstractAutowireCapableBeanFactory 的 doCreateBean() 方法中，有这么一段代码：

```java
boolean earlySingletonExposure = (mbd.isSingleton() // 单例模式
        && this.allowCircularReferences // 允许循环依赖
        && isSingletonCurrentlyInCreation(beanName)); // 当前单例 bean 是否正在被创建
if (earlySingletonExposure) {
    if (logger.isTraceEnabled()) {
        logger.trace("Eagerly caching bean '" + beanName +
                "' to allow for resolving potential circular references");
    }
    // 为了后期避免循环依赖，提前将创建的 bean 实例加入到三级缓存 singletonFactories 中
    addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
}
```

其核心逻辑是，当满足以下3个条件时，把bean加入三级缓存中：

- 单例
- 允许循环依赖
- 当前单例Bean正在创建

`addSingletonFactory(String beanName, ObjectFactory singletonFactory)` 方法，代码如下

```java
protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
	Assert.notNull(singletonFactory, "Singleton factory must not be null");
	synchronized (this.singletonObjects) {
		if (!this.singletonObjects.containsKey(beanName)) {
			this.singletonFactories.put(beanName, singletonFactory);
			this.earlySingletonObjects.remove(beanName);
			this.registeredSingletons.add(beanName);
		}
	}
}
```

从这段代码我们可以看出，singletonFactories 这个三级缓存才是解决 Spring Bean 循环依赖的关键

同时这段代码发生在 `createBeanInstance(...)` 方法之后，也就是说这个 bean 其实已经被创建出来了，但是它还没有完善（没有进行属性填充和初始化），但是对于其他依赖它的对象而言已经足够了（已经有内存地址了，可以根据对象引用定位到堆中对象），能够被认出来了

**为什么多例模式不能解决循环依赖**

因为多例模式下每次new() Bean都不是一个，如果按照这样存到缓存中，就变成单例了

**一二三级缓存下二级缓存的意义：**

二级缓存为了存储 三级缓存的创建出来的早期Bean， 为了避免三级缓存重复执行

在循环依赖的关系中，当 `beanA` 从**第三级缓存**升级到**第二级缓存**的时候，我们可以在其升级的时候去设置一些 `beanA` 的属性或者做一些其他事情,我们只需要在 beanA 的类中实现 `SmartInstantiationAwareBeanPostProcessor` 接口即可

只有**二级缓存**的话，当我们创建好一个没有完成初始化的 `bean` 的时候、要么就直接调用 `ObjectFactory` 的 `getObject` 方法获取经过回调的 `bean` 放入到**第二级缓存**(不管这个 `bean` 存不存在一个循环引用的关系链中)，要么就直接放刚刚创建好的没有完成初始化的 `bean` 放入到**第二级缓存**。无论是哪种情况，都无法达到这样一个需求：当存在循环依赖的时候，我们作为用户需要对其进行一些设置或者一些其他的操作