---
title: HTTP
categories: 
- 网络基础
---

**在浏览器地址栏键入URL，按下回车之后经历的流程**

1.DNS解析：浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名对应的IP地址，DNS缓存从近到远依次是浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、域名服务器缓存、顶级域名服务器缓存。

从哪个缓存找到对应的IP直接返回，不再查询后面的缓存。

2.TCP连接：结合三次握手

3.发送HTTP请求：浏览器发出读取文件的HTTP请求，该请求发送给服务器

4.服务器处理请求并返回HTTP报文：服务器对浏览器请求做出响应，把对应的带有HTML文本的HTTP响应报文发送给浏览器

5.浏览器解析渲染页面

6.连接结束：浏览器释放TCP连接，该步骤即四次挥手。

第5步和第6步可以认为是同时发生的，哪一步在前没有特别的要求

# 状态码

状态码由3位数字组成，第一位定义响应的类别

1XX：指示信息，表示请求以接收，继续处理

2XX：成功，表示请求已经被成功接收、理解、接受

* 200 OK：正常返回信息

3XX：重定向，要完成请求必须进行进一步操作

* 301：永久性转移，旧地址的资源已经被永久地移除了。搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址

* 302：暂时性转移，旧地址的资源还在，只是临时地从旧地址跳转到新地址，搜索引擎会抓取新的内容而保存旧的网址。

4XX：客户端错误，请求由语法错误或请求无法实现

* 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。此时需要分析客户端的代码，去看看请求为什么出现服务   器无法理解的错误。

* 401 Unauthorized：缺失或错误的认证，这个状态代码必须和WWW-Authenticate报头域一起使用。

* 403 Forbidden：客户端请求没有权限去访问要求的资源。

* 404 Not Found：请求资源不存在，检擦URL或路径配置。

5XX：服务器错误，服务器未能实现合法的请求

* 500 Internal Server Error：服务器发生不可预测的错误。检查服务器日志，看看里面的代码哪里错误，进而抛出异常。

* 502 Bad Gateway：服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。

* 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。

* 504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。

# GET和POST

**GET请求和POST请求的区别**

1. `GET` 请求的请求参数是添加到 `head` 中，可以在 `url` 中可以看到；`POST` 请求的请求参数是添加到`BODY`中,在`url` 中不可见。

2. 请求的`url`有长度限制，这个限制由浏览器和 `web` 服务器决定和设置的。例如IE浏览器对 `URL`的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。因为`GET`请求的参数是添加到`URL`中，所以`GET`请求的`URL`的长度限制需要将请求参数长度也考虑进去。而`POST`请求不用考虑请求参数的长度。

3. `GET`请求产生一个数据包;  `POST`请求产生2个数据包,在火狐浏览器中，产生一个数据包。这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体。因为`GET`没有请求体，所以就发送一个数据包，而`POST`包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。

4. `GET` 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。

5. `GET`是幂等的，而`POST`不是。(幂等表示执行相同的操作，结果也是相同的)

# HTTP1.1

**长连接**

HTTP 1.1支持长连接

HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用，在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头

HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。

**流水线**

请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。

**host字段**

在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。

HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。

**100Status**

HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。100状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。

**Chunked transfer-coding**

HTTP/1.1将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。

**cache**

HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活。

# HTTP2.0

**HTTP2.0和HTTP1.X相比的新特性**

- 新的二进制格式，HTTP1.x的解析是基于文本
- 多路复用，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面
- header压缩，HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小
- 服务端推送

**HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别**

- HTTP/1.1的Pipeling为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；
- HTTP2.0多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行

# Cookie和Session

**Session的实现方式：**

1.使用Cookie来实现。服务器给每个Session分配一个唯一的JSession id，并通过Cookie发送给客户端。客户端发起新的请求的时候，将在Cookie头中携带的JSession id，服务器找到客户端对应的Session。

2.使用URL回写来实现。URL回写是指服务器在发送给浏览器页面的所有链接都携带JSession id的参数，客户端点击任何一个链接，都会把JSession id带回服务器，如果直接在浏览器输入服务端资源的URL来请求该资源，Session是匹配不到的。

Tomcat对Session的实现是一开始同时使用Cookie和URL回写机制，如果发现客户端支持Cookie，就继续使用Cookie，停止使用URL回写；如果发现Cookie被禁用，就一直使用URL回写。

**Cookie与Session的区别**

1. cookie的数据信息存放在客户端浏览器上，session的数据信息存放在服务器上。
2. 单个cookie保存的数据<=4KB，一个站点最多保存20个Cookie。对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。
3. cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。
4. cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。
5. 开发可以通过设置cookie的属性，达到使cookie长期有效的效果。session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。
6. cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。

# HTTP3.0

使用UDP协议

# 请求头

HTTP 请求报文由3部分组成(请求行+请求头+请求体)

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210210120236.png" style="zoom:33%;" />

**常见的HTTP报文头属性**

- Accpet
  - 告诉服务端,客户端接收什么类型的响应
- Referer
  - 表示这是请求是从哪个URL进来的
- Cache-Control
  - 对缓存进行控制,如一个请求希望响应的内容在客户端缓存一年,或不被缓可以通过这个报文头设置
- Accept-Encoding
  - 这个属性是用来告诉服务器能接受什么编码格式,包括字符编码,压缩形式(一般都是压缩形式)
    - 例如:Accept-Encoding:gzip, deflate(这两种都是压缩格式)
- Host
  - 指定要请求的资源所在的主机和端口
- User-Agent 作用：告诉服务器，客户端使用的操作系统、浏览器版本和名称

# 响应报文

> 响应报文与请求报文一样,由三个部分组成(响应行,响应头,响应体)

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210210135518.png" style="zoom:33%;" />

