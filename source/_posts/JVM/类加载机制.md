---
title: 类加载机制
categories: 
- JVM
---

# 基本过程

![](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201209222100.png)

**加载**

在加载阶段，Java虚拟机需要完成以下三件事情：

> 1.通过一个类的全限定名来获取定义此类的二进制字节流。
>
> 2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
>
> 3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

**验证**

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合Java虚拟机规范的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

**准备**

准备阶段是正式为类中定义的变量分配内存并设置类变量初始值的阶段

**解析**

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程

**初始化**

进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通 过程序编码制定的主观计划去初始化类变量和其他资源。

# 类加载器

**Bootstrap ClassLoader（启动类加载器）**

由JVM实现(C++)，负责将`%JAVA_HOME%/lib`目录中或`-Xbootclasspath`中参数指定的路径中的，并且是虚拟机识别的（按名称）类库加载到JVM中，负责装载JRE的核心类库，如JRE目录下的`rt.jar,charsets.jar`等，其中`java.lang`包中的类库，它存放在`rt.jar`中

**Extension ClassLoader（扩展类加载器）**

负责加载`%JAVA_HOME%/lib/ext`中的所有类库，负责装载JRE扩展目录ext下的jar类包或通过`java.ext.dirs`系统变量指定路径中的类库

**Application ClassLoader（应用程序加载器）**

负责ClassPath中的类库

除了启动类加载器，其他类加载器都由Java层实现并继承`java.lang.ClassLoader`

**自定义类加载器**

自定义类加载器只需继承ClassLoader类并重写findClass方法

定义一个TestClassLoader类继承ClassLoader，重写findClass方法，此方法要做的事情是读取Test.class字节流并传入父类的defineClass方法，然后就可以通过自定义累加载器TestClassLoader对Test.class进行加载

# 双亲委派机制

双亲委派机制要求除了Bootstrap ClassLoader外，其余的类加载器都要有自己的父加载器。子加载器通过组合来复用父加载器的代码，而不是使用继承。在某个类加载器加载class文件时，它首先委托父加载器去加载这个类，依次传递到顶层类加载器(Bootstrap)。如果顶层加载不了（它的搜索范围中找不到此类），子加载器才会尝试加载这个类

双亲委派模型的实现比较简单，在`java.lang.ClassLoader#loadClass(java.lang.String)`方法中

**优点**

沙箱安全机制：自己写的`String.class`类不会被加载，这样便可以防止核心API库被随意篡改

比如位于rt.jar包中的类`java.lang.Object`，无论哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，确保了Object类在各种加载器环境中都是同一个类

避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次

**打破双亲委派**

打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法

默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载，这里为了破坏双亲委派机制必须重写loadClass方法，即这里先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制