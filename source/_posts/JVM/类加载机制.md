---
title: 类加载机制
categories: 
- JVM
---

# 基本过程

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201209222100.png" style="zoom:33%;" />

**加载**

在加载阶段，Java虚拟机需要完成以下三件事情：

> 1.通过一个类的全限定名来获取定义此类的二进制字节流。
>
> 2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
>
> 3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

**验证**

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合Java虚拟机规范的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

**准备**

准备阶段是正式为类中定义的变量分配内存并设置类变量初始值的阶段

**解析**

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程

**初始化**

进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通 过程序编码制定的主观计划去初始化类变量和其他资源。

# 类加载器

**Bootstrap ClassLoader（启动类加载器）**

由JVM实现(C++)，负责将`%JAVA_HOME%/lib`目录中或`-Xbootclasspath`中参数指定的路径中的，并且是虚拟机识别的（按名称）类库加载到JVM中，负责装载JRE的核心类库，如JRE目录下的`rt.jar,charsets.jar`等，其中`java.lang`包中的类库，它存放在`rt.jar`中

**Extension ClassLoader（扩展类加载器）**

负责加载`%JAVA_HOME%/lib/ext`中的所有类库，负责装载JRE扩展目录ext下的jar类包或通过`java.ext.dirs`系统变量指定路径中的类库

**Application ClassLoader（应用程序加载器）**

负责ClassPath中的类库

除了启动类加载器，其他类加载器都由Java层实现并继承`java.lang.ClassLoader`

**自定义类加载器**

自定义类加载器只需继承ClassLoader类并重写findClass方法

定义一个TestClassLoader类继承ClassLoader，重写findClass方法，此方法要做的事情是读取Test.class字节流并传入父类的defineClass方法，然后就可以通过自定义累加载器TestClassLoader对Test.class进行加载

# 双亲委派机制

双亲委派机制要求除了Bootstrap ClassLoader外，其余的类加载器都要有自己的父加载器。子加载器通过组合来复用父加载器的代码，而不是使用继承。在某个类加载器加载class文件时，它首先委托父加载器去加载这个类，依次传递到顶层类加载器(Bootstrap)。如果顶层加载不了（它的搜索范围中找不到此类），子加载器才会尝试加载这个类

双亲委派模型的实现比较简单，在`java.lang.ClassLoader#loadClass(java.lang.String)`方法中

**优点**

沙箱安全机制：自己写的`String.class`类不会被加载，这样便可以防止核心API库被随意篡改

比如位于rt.jar包中的类`java.lang.Object`，无论哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，确保了Object类在各种加载器环境中都是同一个类

避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次

**打破双亲委派**

打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法

默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载，这里为了破坏双亲委派机制必须重写loadClass方法，即这里先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制

**自身缺陷**

线程上下文类加载器(Thread Context ClassLoader)，这个类加载器可以通过`java.lang.Thread`类的setContextClassLoader()设置，这样子，JNDI服务就可以使用线程上下文类加载器去加载所需的SPI类库，但是父类加载器中请求子类加载器去加载类这一点已经打破了双亲委派模型。目前，JNDI、JDBC、JCE、JAXB和JBI等模块都是通过此方式实现

**JDBC为什么要破坏双亲委派模型**

在JDBC 4.0之后实际上我们不需要再调`Class.forName`来加载驱动程序了，我们只需要把驱动的jar包放到工程的类加载路径里，那么驱动就会被自动加载

这个自动加载采用的技术叫做SPI，数据库驱动厂商也都做了更新。可以看一下jar包里面的`META-INF/services`目录，里面有一个`java.sql.Driver`的文件，文件里面包含了驱动的全路径名

使用上，我们只需要通过下面一句就可以创建数据库的连接：

```java
Connection con =    
             DriverManager.getConnection(url , username , password ) ;   
```

因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件

这个子类加载器是通过` Thread.currentThread().getContextClassLoader() `得到的线程上下文加载器

线程上下文类加载器默认情况下就是系统加载器

**Tomcat为什么要破坏双亲委派模型**

每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210214103953.png" style="zoom:33%;" />

tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的：

- 对于各个 `webapp`中的 `class`和 `lib`，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。
- 与 `jvm`一样的安全性问题。使用单独的 `classloader`去装载 `tomcat`自身的类库，以免其他恶意或无意的破坏；
- 热部署