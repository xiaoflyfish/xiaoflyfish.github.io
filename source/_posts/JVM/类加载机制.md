---
title: 类加载机制
categories: 
- JVM
---

# 类加载器

**Bootstrap ClassLoader（启动类加载器）**

由JVM实现(C++)，负责将`%JAVA_HOME%/lib`目录中或`-Xbootclasspath`中参数指定的路径中的，并且是虚拟机识别的（按名称）类库加载到JVM中，负责装载JRE的核心类库，如JRE目录下的`rt.jar,charsets.jar`等，其中`java.lang`包中的类库，它存放在`rt.jar`中

**Extension ClassLoader（扩展类加载器）**

负责加载`%JAVA_HOME%/lib/ext`中的所有类库，负责装载JRE扩展目录ext下的jar类包或通过`java.ext.dirs`系统变量指定路径中的类库

**Application ClassLoader（应用程序加载器）**

负责ClassPath中的类库

除了启动类加载器，其他类加载器都由Java层实现并继承`java.lang.ClassLoader`

**自定义类加载器**

自定义类加载器只需继承ClassLoader类并重写findClass方法

定义一个TestClassLoader类继承ClassLoader，重写findClass方法，此方法要做的事情是读取Test.class字节流并传入父类的defineClass方法，然后就可以通过自定义累加载器TestClassLoader对Test.class进行加载

# 双亲委派机制

双亲委派机制要求除了Bootstrap ClassLoader外，其余的类加载器都要有自己的父加载器。子加载器通过组合来复用父加载器的代码，而不是使用继承。在某个类加载器加载class文件时，它首先委托父加载器去加载这个类，依次传递到顶层类加载器(Bootstrap)。如果顶层加载不了（它的搜索范围中找不到此类），子加载器才会尝试加载这个类

双亲委派模型的实现比较简单，在`java.lang.ClassLoader#loadClass(java.lang.String)`方法中

**优点**

沙箱安全机制：自己写的`String.class`类不会被加载，这样便可以防止核心API库被随意篡改

比如位于rt.jar包中的类`java.lang.Object`，无论哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，确保了Object类在各种加载器环境中都是同一个类

避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次

**打破双亲委派**

打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法

默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载，这里为了破坏双亲委派机制必须重写loadClass方法，即这里先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制