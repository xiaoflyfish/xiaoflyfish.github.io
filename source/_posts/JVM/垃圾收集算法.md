---
title: 垃圾收集算法
categories: 
- JVM
---

**标记清除算法**

首先标记出所有需要回收的对象，在标记完成后统一回收所有未被标记的对象，它是最基础的收集算法

标记阶段：遍历所有的GC Roots对象，对从GC Roots对象可达的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象

清除阶段：清除的过程是对堆内存进行遍历，如果发现某个对象没有被标记为可达对象（通过读取对象header信息），则将其回收

两个明显的问题：

1.效率问题（遍历太多）

2.空间问题（标记清除后会产生大量不连续的碎片），会产生大量碎片，内存碎片过多可能导致无法给大对象分配内存

**复制算法**

它可以将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉，这样就使每次的内存回收都是对内存区间的一半进行回收

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低

**标记整理算法**

根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移动，然后直接清理掉端边界以外的内存

因此其不会产生内存碎片。标记—整理算法提高了内存的利用率，并且它适合在收集对象存活时间较长的老年代

**分代收集算法**

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块，一般将堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法

比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集，而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集