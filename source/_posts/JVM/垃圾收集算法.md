---
title: 垃圾收集算法
categories: 
- JVM
---

**标记清除算法**

首先标记出所有需要回收的对象，在标记完成后统一回收所有未被标记的对象，它是最基础的收集算法

标记阶段：遍历所有的GC Roots对象，对从GC Roots对象可达的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象

清除阶段：清除的过程是对堆内存进行遍历，如果发现某个对象没有被标记为可达对象（通过读取对象header信息），则将其回收

两个明显的问题：

1.效率问题（遍历太多）

2.空间问题（标记清除后会产生大量不连续的碎片），会产生大量碎片，内存碎片过多可能导致无法给大对象分配内存

**复制算法**

它可以将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉，这样就使每次的内存回收都是对内存区间的一半进行回收

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低

现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的Eden 空间和两块较小的Survior 空间，每次使用Eden 空间和其中一块Survivor，在回收时，将Eden和Survivor中还存活着的对象一次性复制到另一块Survivor 空间上，最后清理Eden 和使用过的那一块Survivor

HotSpot 虚拟机的Eden 和Survivor 的大小比例默认为8:1，保证了内存的利用率达到90 %，如果每次回收有多于10% 的对象存活，那么一块Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间

JVM默认有这个参数`-XX:+UseAdaptiveSizePolicy`(默认开启)，会导致这个8:1:1比例自动变化

**标记整理算法**

根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移动，然后直接清理掉端边界以外的内存

因此其不会产生内存碎片。标记—整理算法提高了内存的利用率，并且它适合在收集对象存活时间较长的老年代

**分代收集算法**

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块，一般将堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法

比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集，而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集

# GC类型

**Minor GC和Full GC**

Minor GC/Young GC：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。

Major GC/Full GC：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。

**FullGC触发条件**

1.Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内 存的大小。此时老年代都放不下这些存活对象了，就会发生“Handle Promotion Failure”的情况，这个时候就会触 发一次“Full GC”

如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的 “OOM”内存溢出了

2.如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。

3.如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC

4.老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打 开；

开启空间担保参数，老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC；

5.CMS收集器老年代已经使用的 内存空间超过了这个参数“-XX:CMSInitiatingOccupancyFaction”指定的比例，也会自动触发Full GC

6.显示调用System.gc