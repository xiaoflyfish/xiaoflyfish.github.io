---
title: 内存溢出
categories: 
- JVM
---

除了程序计数器外 ，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。

**虚拟机栈和本地方法栈溢出**

如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

如果虚拟机在扩展栈时无法申请到足够的内存空间 ，则抛出OutOfMemoryError异常。

**堆溢出**

一般的异常信息： java.lang.OutOfMemoryError:Java heap spaces。 出现这种异常， 一般手段是先通过内存映像分析工具(如 Eclipse Memory Analyzer)对 dump 出来的堆转存快照进行分析， 重点是确认内存中的对象是否是必要的， 先分清是因为内存泄漏(Memory Leak)还是内存溢出(MemoryOverflow)。

如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots相关联并导致垃圾收集器无法自动回收。

如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx 与-Xms)的设置是否适当

**方法区溢出**

异常信息： java.lang.OutOfMemoryError:PermGen space。

**运行时常量池溢出**

异常信息： java.lang.OutOfMemoryError:PermGen space。

如 果 要 向 运 行 时 常 量 池 中 添 加 内 容 ， 最 简 单 的 做 法 就 是 使 用 `String.intern()`这个 Native 方法。

该方法的作用是： 如果池中已经包含一个等于此 String 的字符串， 则返回代表池中这个字符串的 String 对象； 否则，将此 String 对象包含的字符串添加到常量池中， 并且返回此 String 对象的引用 。

**一般来说发生内存溢出有两种主要的场景：**

系统承载高并发请求，因为请求量过大，导致大量对象都是存活的，所以要继续放入新的对象实在是不行了，此时就会引发OOM系统 崩溃

系统有内存泄漏的问题，就是莫名其妙弄了很多的对象，结果对象都是存活的，没有及时取消对他们的引用，导致触发GC还是无法回 收，此时只能引发内存溢出，因为内存实在放不下更多对象了