---
title: 垃圾收集器
categories: 
- JVM
---

**Serial收集器**

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。

大家看名字就知道这个收集器是一个单线程收集器了。它 的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工 作的时候必须暂停其他所有的工作线程（ Stop The World ），直到它收集结束。

新生代采用复制算法，老年代采用标记-整理算法

Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。

Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器。

它主要有两大用途：一种用途是在JDK1.5 以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案

那种运行在Windows上的客户端程序，建议采用Serial垃圾回收器，单CPU单线程垃圾回收即可

Serial垃圾收集器依然是JVM运行在Client模式下默认的新生代垃圾收集器

**Parallel Scavenge收集器**

Parallel收集器其实就是Serial收集器的多线程版本

Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。

CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。

Parallel Old收集器是Parallel Scavenge收集器的老年代版本。

**ParNew收集器**

ParNew现在一般都是用在新生代的垃圾回收器

ParNew收集器其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。

它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器）配合工作

# CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

它非常符合在注重用户体 验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程 （基本上）同时工作。

CMS是老年代垃圾回收器，基于标记-清除算法实现，新生代默认使用ParNew收集器，基于复制算法

能与CMS搭配使用的新生代垃圾收集器有Serial收集器和ParNew收集器，这2个收集器都采用标记复制算法，都会触发STW事件，停止所有的应用线程，不同之处在于，Serial是单线程执行，ParNew是多线程执行

**整个过程分为四个步骤：**

1.初始标记： 暂停所有的其他线程(STW)，并记录下GC Roots直接能引用的对象，速度很快。

2.并发标记： 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但 是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的 对象状态发生改变。

3.重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对 象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。

4.并发清理： 开启用户线程，同时GC线程开始对未标记的区域做清扫。

5.并发重置：重置本次GC过程中的标记数据

在整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，因此从总体上看，CMS收集器的内存回收过程是与用户线程一起并发执行的

**主要优点：并发收集、低停顿。但是它有下面几个明显的缺点：**

1.对CPU资源敏感（会和服务抢资源），是比较耗费CPU资源；

2.无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；

3.它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生

# G1收集器

G1垃圾回收器是可以同时回收新生代和老年代的对象的，不需要两个垃圾回收器配合起来运作

G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC 停顿时间要求的同时,还具备高吞吐量性能特征

G1将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region。

一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M

**垃圾回收的过程**

1.初始标记：暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快

2.并发标记：同CMS的并发标记

3.最终标记：同CMS的重新标记

4.筛选回收：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期 望的GC停顿时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划，比如说老年代此时有1000个 Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得 知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region，尽量把GC导致的停顿时间控制在我们指定的范围内。

这个阶段其实也可以做到与用户程序一起并发执行，但 是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代或是老 年代，回收算法主要用的是复制算法，将一个region中的存活对象复制到另一个region中，这种不会像CMS那样 回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片。

# ZGC收集器

ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器

**ZGC的特性主要有3个：**

1.支持TB量级的堆。我们生产环境的硬盘还没有上TB呢，这应该可以满足未来十年内，所有JAVA应用的需求吧。

2.最大GC停顿时间不超10ms。目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右

3.最糟糕的情况下吞吐量会降低15%。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。

另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下