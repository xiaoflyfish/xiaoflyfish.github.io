---
title: JIT即时编译
categories: 
- JVM
---

当 JVM 的初始化完成后，类在调用执行过程中，执行引擎会把字节码转为机器码，然后在操作系统中才能执行。

最初，JVM 中的字节码是由解释器完成编译的，当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为热点代码。

为了提高热点代码的执行效率，在运行时，即时编译器(JIT)会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后保存到内存中

HotSpot 虚拟机包含多个即时编译器，有 C1，C2 和 Graal，JDK8 以后采用的是分层编译的模式

# 分层编译

在 Java7 之前，需要根据程序的特性来选择对应的 JIT，虚拟机默认采用解释器和其中一个编译器配合工作。

Java7 引入了分层编译，这种方式综合了 C1 的启动性能优势和 C2 的峰值性能优势，我们也可以通过参数 `-client`或者`-server` 强制指定虚拟机的即时编译模式

我们可以通过 java -version命令行可以直接查看到当前系统使用的编译模式：

```
C:\Users\Administrator>java -version
java version "1.8.0_45"
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)
```

mixed mode代表是默认的混合编译模式，除了这种模式外，我们还可以使用-Xint参数强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作；也可以使用参数-Xcomp强制虚拟机运行于只有 JIT 的编译模式下

# 触发标准

在 HotSpot 虚拟机中，热点探测是 JIT 的触发标准。

> 热点探测是基于计数器的热点探测，采用这种方法的虚拟机会为每个方法建立计数器统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法” 。

虚拟机为每个方法准备了两类计数器：方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发 JIT 编译。

# 优化技术

JIT 编译运用了一些经典的编译优化技术来实现代码的优化，即通过一些例行检查优化，可以智能地编译出运行时的最优性能代码。主要有两种：`方法内联`、`逃逸分析`。

## 方法内联

方法内联它会把一些短小的方法体，直接纳入目标方法的作用范围之内，就像是直接在代码块中追加代码。这样，就少了一次方法调用，执行速度就能够得到提升，这就是方法内联的概念。

## 逃逸分析

逃逸分析是判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。

可以通过JVM参数进行设置：

```
-XX:+DoEscapeAnalysis 开启逃逸分析（jdk1.8 默认开启）
-XX:-DoEscapeAnalysis 关闭逃逸分析
```

其具体优化方法主要有三种：`栈上分配`、`锁消除`、`标量替换`。

**栈上分配**

在 Java 中默认创建一个对象是在堆中分配内存的，而当堆内存中的对象不再使用时，则需要通过垃圾回收机制回收，这个过程相对分配在栈中的对象的创建和销毁来说，更消耗时间和性能。

这个时候，逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上。

**锁消除**

如果是在单线程环境下，其实完全没有必要使用线程安全的容器，但就算使用了，因为不会有线程竞争，这个时候 JIT 编译会对这个对象的方法锁进行锁消除。

可以通过JVM参数进行设置：

```
-XX:+EliminateLocks 开启锁消除（jdk1.8 默认开启）
-XX:-EliminateLocks 关闭锁消除复制代码
```

**标量替换**

逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。这种编译优化就叫做标量替换。

可以通过JVM参数进行设置：

```
-XX:+EliminateAllocations 开启标量替换（jdk1.8 默认开启）
-XX:-EliminateAllocations 关闭就可以了
```