---
title: 分布式锁
categories: 
- Redis
---

使用分布式锁的目的，无外乎就是保证同一时间只有一个客户端可以对共享资源进行操作。

**使用SETNX实现**

SETNX的使用方式为：`SETNX key value`，只在键key不存在的情况下，将键key的值设置为value，若键key存在，则SETNX不做任何动作。

这种方案有一个致命问题，就是某个线程在获取锁之后由于某些异常因素（比如宕机）而不能正常的执行解锁操作，那么这个锁就永远释放不掉了。

为此，我们可以为这个锁加上一个超时时间

执行 `SET key value EX seconds` 的效果等同于执行 `SETEX key seconds value` 

执行 `SET key value PX milliseconds` 的效果等同于执行 `PSETEX key milliseconds value` 

**方案看上去很完美，但实际上还是会有问题**

试想一下，某线程A获取了锁并且设置了过期时间为10s，然后在执行业务逻辑的时候耗费了15s，此时线程A获取的锁早已被Redis的过期机制自动释放了

在线程A获取锁并经过10s之后，改锁可能已经被其它线程获取到了。当线程A执行完业务逻辑准备解锁（`DEL key`）的时候，有可能删除掉的是其它线程已经获取到的锁。

所以最好的方式是在解锁时判断锁是否是自己的，我们可以在设置`key`的时候将value设置为一个唯一值`uniqueValue`（可以是随机值、UUID、或者机器号+线程号的组合、签名等）。

当解锁时，也就是删除key的时候先判断一下key对应的value是否等于先前设置的值，如果相等才能删除key

这里我们一眼就可以看出问题来：`GET`和`DEL`是两个分开的操作，在GET执行之后且在DEL执行之前的间隙是可能会发生异常的。

如果我们只要保证解锁的代码是原子性的就能解决问题了

这里我们引入了一种新的方式，就是**Lua脚本**，示例如下：

```c
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

其中`ARGV[1]`表示设置key时指定的唯一值。

由于Lua脚本的原子性，在Redis执行该脚本的过程中，其他客户端的命令都需要等待该Lua脚本执行完才能执行。

**确保过期时间大于业务执行时间**

为了防止多个线程同时执行业务代码，需要确保过期时间大于业务执行时间

增加一个boolean类型的属性`isOpenExpirationRenewal`，用来标识是否开启定时刷新过期时间。

在增加一个`scheduleExpirationRenewal`方法用于开启刷新过期时间的线程

加锁代码在获取锁成功后将isOpenExpirationRenewal置为true，并且调用`scheduleExpirationRenewal`方法，开启刷新过期时间的线程

解锁代码增加一行代码，将isOpenExpirationRenewal属性置为false，停止刷新过期时间的线程轮询

**Redisson实现**

获取锁成功就会开启一个定时任务,定时任务会定期检查去续期

该定时调度每次调用的时间差是`internalLockLeaseTime / 3`,也就10秒

默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 `30-10 = 20`秒的时候,就会进行一次续期,把锁重置成30秒

# RedLock

在集群中，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生

**Redlock算法就是为了解决这个问题**

使用 Redlock，需要提供多个 `Redis` 实例，这些实例之前相互独立没有主从关系。同很多分布式算法一样，redlock 也使用大多数机制

加锁时，它会向过半节点发送 set指令，只要过半节点 `set` 成功，那就认为加锁成功。释放锁时，需要向所有节点发送 del 指令。不过 Redlock 算法还需要考虑出错重试、时钟漂移等很多细节问题，同时因为 `Redlock` 需要向多个节点进行读写，意味着相比单实例 Redis 性能会下降一些

**具体流程为：**

* 顺序向五个节点(假如有5个节点)请求加锁
* 三个节点加锁成功并且花费时间小于锁的有效期，认定加锁成功

也就是说，假设锁30秒过期，三个节点加锁花了31秒，自然是加锁失败了

在 Redis 官方推荐的 Java 客户端 `Redisson` 中，内置了对 `RedLock` 的实现

[https://redis.io/topics/distlock](https://redis.io/topics/distlock)

[https://github.com/redisson/redisson/wiki](https://github.com/redisson/redisson/wiki)