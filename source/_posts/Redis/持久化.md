---
title: 持久化
categories: 
- Redis
---

# RDB

RDB 持久化（也称作快照持久化）是指将内存中的数据生成快照保存到磁盘里面，保存的文件后缀是 `.rdb`。

rdb 文件是一个经过压缩的二进制文件，当 Redis 重新启动时，可以读取rdb快照文件恢复数据。

Redis 服务器默认是通过 RDB 方式完成持久化的，对应 `redis.conf` 文件的配置项如下：

```
# RDB文件的名称
dbfilename dump.rdb
# 备份RDB和AOF文件存放路径
dir /usr/local/var/db/redis/
```

**触发操作**

Redis 提供了两个用于生成 RDB 文件的命令，一个是 SAVE，另一个是 BGSAVE。

触发 Redis 进行 RDB 备份的方式有两种，一种是通过 SAVE 命令、BGSAVE 命令手动触发快照生成的方式，另一种是配置保存时间和写入次数，由 Redis 根据条件自动触发保存操作

`redis.conf` 默认配置了以下 3 个保存条件：

```
save 900 1
save 300 10
save 60 10000
```

用户可以通过 save 选项设置多个保存条件，只要其中任意一个条件被满足，服务器就会执行 BGSAVE 命令

## 优缺点

**优点**

RDB 是一个压缩过的非常紧凑的文件，保存着某个时间点的数据集，适合做数据的备份、灾难恢复

与 AOF 持久化方式相比，恢复大数据集的时候会更快

**缺点**

RDB 的数据安全性是不如 AOF 的，保存整个数据集是个重量级的过程，根据配置可能要几分钟才进行一次持久化，如果服务器宕机，那么就可能丢失几分钟的数据 Redis 数据集较大时，fork 的子进程要完成快照会比较耗费 CPU 和时间

# AOF

AOF 会把 Redis 服务器每次执行的写命令记录到一个日志文件中，当服务器重启时再次执行 AOF 文件中的命令来恢复数据

默认情况下 AOF 功能是关闭的，Redis 只会通过 RDB 完成数据持久化的。

开启 AOF 功能需要 `redis.conf` 文件中将 appendonly 配置项修改为 yes，这样在开启 AOF 持久化功能的同时，将基于 RDB 的快照持久化置于低优先级

```
# 此选项为AOF功能的开关，默认为no，通过yes来开启aof功能
appendonly yes
# 指定AOF文件名称
appendfilename appendonly.aof
# 备份RDB和AOF文件存放路径
dir /usr/local/var/db/redis/
```

**AOF的执行流程**

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201211153747.png)

> write()

为了提高文件的写入效率，当用户调用 write 函数将数据写入文件时，操作系统会先把数据写入到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。

> fsync()

虽然操作系统底层对 write() 函数进行了优化 ，但也带来了安全问题。如果宕机内存缓冲区中的数据会丢失，因此系统同时提供了同步函数 fsync() ，强制操作系统立刻将缓冲区中的数据写入到磁盘中，从而保证了数据持久化。

AOF 文件的写入流程可以分为以下 3 个步骤：

- 命令追加（append）：将 Redis 执行的写命令追加到 AOF 的缓冲区 aof_buf
- 文件写入（write）和文件同步（fsync）：AOF 根据对应的策略将 aof_buf 的数据同步到硬盘
- 文件重写（rewrite）：定期对 AOF 进行重写，从而实现对写命令的压缩。

Redis 提供了 appendfsync 配置项来控制 AOF 缓存区的文件同步策略，appendfsync 可配置以下三种策略：

- appendfsync always：每执行一次命令保存一次 命令写入 aof_buf 缓冲区后立即调用系统 fsync 函数同步到 AOF 文件，fsync 操作完成后线程返回，整个过程是阻塞的。
- appendfsync no：不保存，命令写入 aof_buf 缓冲区后调用系统 write 操作，不对 AOF 文件做 fsync 同步；同步由操作系统负责，通常同步周期为 30 秒。
- appendfsync everysec：每秒钟保存一次命令写入 aof_buf 缓冲区后调用系统 write 操作，write 完成后线程立刻返回，fsync 同步文件操作由单独的进程每秒调用一次。是 Redis 的默认配置

## 文件重写

随着命令不断写入 AOF，文件会越来越大，导致文件占用空间变大，数据恢复时间变长。为了解决这个问题,Redis 引入了重写机制来对 AOF 文件中的写命令进行合并，进一步压缩文件体积

**触发机制**

手动触发：直接调用 bgrewriteaof 命令，该命令的执行与 bgsave 有些类似，都是 fork 子进程进行具体的工作，且都只有在 fork 时会阻塞

自动触发：根据 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 配置项，以及 aof_current_size 和 aof_base_size 的状态确定触发时机

- auto-aof-rewrite-min-size：执行 AOF 重写时，文件的最小体积，默认值为 64MB
- auto-aof-rewrite-percentage：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值

**重写流程**

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201211161349.png)

1.客户端通过 bgrewriteaof 命令对 Redis 主进程发起 AOF 重写请求

2.在文件重写完成之前，主进程会继续把写命令追加到 aof_buf 缓冲区，根据 appendfsync 策略同步到旧的 AOF 文件，这样可以避免 AOF 重写失败造成数据丢失，保证原有的 AOF 文件的正确性

3.由于 fork 操作运用写时复制技术，子进程只能共享 fork 操作时的内存数据，主进程会把新命令追加到一个 aof_rewrite_buf 缓冲区中，避免 AOF 重写时丢失这部分数据

4.子进程读取 Redis 进程中的数据快照，生成写入命令并按照命令合并规则批量写入到新的 AOF 文件

5.子进程写完新的 AOF 文件后，向主进程发信号，主进程接受到子进程的信号以后，将 aof_rewrite_buf 缓冲区中的写命令追加到新的 AOF 文件，主进程使用新的 AOF 文件替换旧的 AOF 文件，AOF 重写过程完成

## 优缺点

**优点**

数据更完整，安全性更高，秒级数据丢失（取决于 fsync 策略，如果是 everysec，最多丢失 1 秒的数据）

**缺点**

对于相同的数据集，AOF 文件的体积要远远大于 RDB 文件，数据恢复也会比较慢