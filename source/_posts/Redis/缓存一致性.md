---
title: 缓存一致性
categories: 
- Redis
---

推荐博客1：[分布式之数据库和缓存双写一致性方案解析](https://www.cnblogs.com/rjzheng/p/9041659.html)

推荐博客2：[分布式之数据库和缓存双写一致性方案解析(二)](https://www.cnblogs.com/rjzheng/p/9240611.html)

推荐博客3：[分布式之数据库和缓存双写一致性方案解析(三)](https://www.cnblogs.com/rjzheng/p/9302609.html)

**Cache Aside Pattern**

最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，先更新数据库，然后再删除缓存。

**先删除缓存再更新DB**

两个并发操作，一个是更新操作，另一个是查询操作，删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库，于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了

**先更新DB再删除缓存**

一个是查询操作，一个是更新操作的并发，首先，没有了删除`cache`数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来，而不会像上面那个，后续的查询操作一直都在取老的数据

**解决方案大概有以下几种：**

对删除缓存进行重试，数据的一致性要求越高，我越是重试得快

定期全量更新，简单地说，就是我定期把缓存全部清掉，然后再全量加载

给所有的缓存一个失效期

**为什么是删除缓存，而不是更新缓存**

系统设计中有一个思想叫 `Lazy Loading`，适用于那些加载代价大的操作，删除缓存而不是更新缓存，就是懒加载思想的一个应用