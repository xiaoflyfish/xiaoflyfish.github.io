---
title: 基本介绍
categories: 
- Redis
- 数据类型
---

# String

**应用：**

分布式锁，计数器

# Hash

是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。Redis 中每个 hash 可以存储 232-1 键值对（40多亿）

**不能使用hash键的情况：**

过期功能的使用，过期功能只能使用在key上；（因为里面是存的 key field value 只能对key 设置过期，没法真正的对field 设置过期，所以说不支持分布式锁）

# List

**应用：**

实现阻塞消息队列，实现用户消息列表

暖暖userID（201）关注：青山老师，TOM老师，科比，登科

1：青山老师发微博，消息ID为1201

LPUSH 201 1201

2：TOM老师发消息，消息ID为1202

LPUSH 201 1202

分页获取201的消息列表：`LRANGE 201 0,1*10` （分页获取）

# Set

Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据

集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)

**应用：**

实现直播刷礼物，转发参加抽奖活动

`SADD key {userid}_1` 刷礼物，转发微博加入到集合键中

SMEMBERS key 获取所有用户，大轮盘转起来

`SPOP key count/SRANDMEMBER key [count]` 抽取 count名中奖者 ：`SRANDMEMBER key [count](返回集合中一个或多个随机数)`



**实现点赞，签到，like等功能**

点赞：SADD kile::8001(被赞者） 1001（当前点赞用户）

取消点赞：SREM like::8001 1001 （从集合中移除1001）

检查用户是否点过赞：SISMEMBER like::8001 1001 (SISMEMBER :判断 member 元素是否是集合 key 的成员)

获取用户的点赞列表：SMEMBERS like::8001(SMEMBERS返回集合中的所有成员)

获取点赞用户数：SCARD like::8001 (scard:获取集合的成员数)



**基于集合运算实现关注模型（可能认识的人）**

Seven关注的人：sevenSub:{qing,mic,james}

青山关注的人：qingSub:{seven,jack,mic,james}

Mic关注的人：micSub:{seven,james,qing,jack,tom}

我和青山共同关注：SINTER sevenSub,qingSub {mic,james} (返回给定所有集合的交集)

我(Seven)关注的人也关注他：SISMEMBER mincSub (遍历我关注的人员列表，判断是否在他的关注列表中，在表示同时关注了他，否则则没有关注） (判断 member 元素是否是集合 key 的成员)

我可能认识的人：SDIFFSTORE sevenMayKnow qingSub sevenSub{seven,jack} 

`SDIFFSTORE destination key1 [key2]`
返回给定所有集合的差集并存储在 destination 中,以key1为基准，在key2中不存在的，即为差集

# Zset

Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。有序集合的成员是唯一的,但分数(score)却可以重复。

不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)

**应用：**

实现排行榜（单日，周，月，年）

展示排行：倒序取10条，并携带score的值，score值为搜索值

`ZREVRANGE hotNews::20200113 0 10 withscores （ZREVRANGE key start stop [WITHSCORES] `

` ZUNIONSTORE destination numkeys key [key ...]`计算给定的一个或多个有序集的并集，并存储在新的 key 中

# Geo

Geo可以用于存储经纬度、计算两地之间的距离、范围计算等