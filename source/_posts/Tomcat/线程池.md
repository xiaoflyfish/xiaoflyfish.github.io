---
title: 线程池
categories: 
- Tomcat
---

**Java线程池**

如果当前运行的线程，少于corePoolSize，则创建一个新的线程来执行任务。

如果运行的线程等于或多于 corePoolSize，将任务加入 BlockingQueue。

如果 BlockingQueue 内的任务超过上限，则创建新的线程来处理任务。

如果创建的线程超出 maximumPoolSize，任务将被拒绝策略拒绝。

Tomcat/Jetty 是目前比较流行的 Web 容器，两者接受请求之后都会转交给线程池处理，这样可以有效提高处理的能力与并发度。JDK 提高完整线程池实现，但是 Tomcat/Jetty 都没有直接使用

Jetty 采用自研方案，内部实现 `QueuedThreadPool` 线程池组件，而 Tomcat 采用扩展方案，踩在 JDK 线程池的肩膀上，扩展 JDK 原生线程池

**通常我们可以将执行的任务分为两类：**

- cpu 密集型任务
- io 密集型任务

cpu 密集型任务，需要线程长时间进行的复杂的运算，这种类型的任务需要少创建线程，过多的线程将会频繁引起上文切换，降低任务处理处理速度。

io 密集型任务，由于线程并不是一直在运行，可能大部分时间在等待 IO 读取/写入数据，增加线程数量可以提高并发度，尽可能多处理任务

JDK线程池这种策略显然比较适合处理 `cpu` 密集型任务，但是对于 `io` 密集型任务，如数据库查询，rpc 请求调用等，就不是很友好了。

由于 Tomcat/Jetty 需要处理大量客户端请求任务，如果采用原生线程池，一旦接受请求数量大于线程池核心线程数，这些请求就会被放入到队列中，等待核心线程处理。这样做显然降低这些请求总体处理速度，所以两者都没采用 JDK 原生线程池。

**Tomcat线程池**

如果当前运行的线程，少于corePoolSize，则创建一个新的线程来执行任务。

如果线程数大于 corePoolSize了，Tomcat 的线程不会直接把线程加入到无界的阻塞队列中，而是去判断submittedCount（已经提交线程数）是否等于 maximumPoolSize。

如果等于，表示线程池已经满负荷运行，不能再创建线程了，直接把线程提交到队列，

如果 BlockingQueue 达到上限（假如设置了上限），被默认线程池启动拒绝策略，tomcat 线程池会 catch 住拒绝策略抛出的异常，再次把尝试任务加入中 BlockingQueue 中。

再次加入失败，启动拒绝策略。

Tomcat 扩展线程池直接继承 JDK 线程池 `java.util.concurrent.ThreadPoolExecutor` ，重写部分方法的逻辑。另外还实现了 `TaskQueue` ，直接继承 `LinkedBlockingQueue` ，重写 `offer` 方法

