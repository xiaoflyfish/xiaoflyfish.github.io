---
title: 布隆过滤器
categories: 
- 数据结构
---

布隆过滤器的核心实现是一个超大的位数组和几个哈希函数，假设位数组的长度为m，哈希函数的个数为k

**具体的操作流程：**

假设集合里面有3个元素{x, y, z}，哈希函数的个数为3，首先将位数组进行初始化，将里面每个位都设置位0，对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1

查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点，如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合，反之，如果3个点都为1，则该元素可能存在集合中，注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率

理论情况下添加到集合中的元素越多，误报的可能性就越大，并且，存放在布隆过滤器的数据不容易删除

位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1，这样申请一个 100w个元素的位数组只占用 1000000Bit/8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间

**基本使用**

利用Google开源的 Guava中自带的布隆过滤器

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>28.0-jre</version>
</dependency>
```

我们创建了一个最多存放 最多 1500个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）

```java
// 创建布隆过滤器对象
BloomFilter<Integer> filter = BloomFilter.create(
        Funnels.integerFunnel(),
        1500,
        0.01);
// 判断指定元素是否存在
System.out.println(filter.mightContain(1));
System.out.println(filter.mightContain(2));
// 将元素添加进布隆过滤器
filter.put(1);
filter.put(2);
System.out.println(filter.mightContain(1));
System.out.println(filter.mightContain(2));
```

在我们的示例中，当mightContain()方法返回true时，我们可以99％确定该元素在过滤器中，当过滤器返回false时，我们可以100％确定该元素不存在于过滤器

**Redis中的布隆过滤器**

Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 ，布隆过滤器就是其中的 Module

详情可以查看 Redis 官方对 Redis Modules 的介绍 ：https://redis.io/modules

另外，官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module,地址：https://github.com/RedisBloom/RedisBloom

**使用场景**

布隆过滤器的巨大用处就是，能够迅速判断一个元素是否在一个集合中。因此他有如下三个使用场景:

1. 网页爬虫对URL的去重，避免爬取相同的URL地址
2. 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）
3. 缓存击穿，将已存在的缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。

缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉

```java
String get(String key) {
    String value = redis.get(key);     
    if (value  == null) {
        if(!bloomfilter.mightContain(key)){
            return null; 
        }else{
            value = db.get(key); 
            redis.set(key, value); 
        }    
    }
    return value；
}
```

