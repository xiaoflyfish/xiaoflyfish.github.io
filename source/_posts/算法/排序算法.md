---
title: 排序算法
categories: 
- 算法
---

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201211191354.png)

# 冒泡排序

核心思路：冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作

**举例说明：4 5 6 3 2 1,从小到大排序**

第一次冒泡的结果:4 5 6 3 2 1->4 5 3 6 2 1 - > 4 5 3 2 6 1 -> 4 5 3 2 1 6,6这个元素的位置确定了

第二次冒泡的结果:4 5 3 2 1 6->4 3 5 2 1 6 -> 4 3 2 5 1 6 -> 4 3 2 1 5 6

第三次冒泡的结果:4 3 2 1 5 6->3 4 2 1 5 6 -> 3 2 4 1 5 6 -> 3 2 1 4 5 6

第四次冒泡的结果:3 2 1 4 5 6->2 3 1 4 5 6 -> 2 1 3 4 5 6

第五次冒泡的结果:2 1 3 4 5 6->1 2 3 4 5 6

1.时间复杂度：`O(N^2)`

2.空间复杂度:O(n)

3.稳定性:不稳定

```java
import java.util.Arrays;
public class BubbleSort {
	public static void main(String[] args) {
		int data[] = { 4, 5, 6, 3, 2, 1 };
		int n = data.length;
		for (int i = 0; i < n - 1; i++) {	//排序的次数
			boolean flag = false;
			for (int j = 0; j < n - 1 - i; j++) {	//具体冒泡 n - 1 - i
				if (data[j] > data[j + 1]) {
					int temp = data[j];	
					data[j] = data[j + 1];
					data[j + 1] = temp;
					flag = true;
				}
			}
			if(!flag) break;
		}
		System.out.println(Arrays.toString(data));
	}
}
```

# 选择排序

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾，以此类推，直到所有元素均排序完毕

```java
public class SelectionSort {
    public int[] selectionSort(int[] A, int n) {
        //记录最小下标值
        int min=0;
        for(int i=0; i<A.length-1;i++){
            min = i;
            //找到下标i开始后面的最小值
            for(int j=i+1;j<A.length;j++){
                 if(A[min]>A[j]){
                     min = j;
                 }
            }
            if(i!=min){
                swap(A,i,min);
            }
        }
        return A;
    }
    private void swap(int[] A,int i,int j){
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }
}
```

# 插入排序

插入排序算法的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间

```java
public class InsertionSort {
    public int[] insertionSort(int[] A, int n) {
      //用模拟插入扑克牌的思想
        //插入的扑克牌
        int i,j,temp;
        //已经插入一张，继续插入
        for(i=1;i<n;i++){
            temp = A[i];
            //把i前面所有大于要插入的牌的牌往后移一位，空出一位给新的牌
            for(j=i;j>0&&A[j-1]>temp;j--){
                A[j] = A[j-1];
            }
            //把空出来的一位填满插入的牌
            A[j] = temp;
        }
        return A;
    }
}
```

# 归并排序

先使每个子序列有序，再将两个已经排序的序列合并成一个序列的操作

若将两个有序表合并成一个有序表，称为二路归并

```java
public class MergeSort {
	public static void main(String[] args) {
		int data[] = { 9, 5, 6, 8, 0, 3, 7, 1 };
		megerSort(data, 0, data.length - 1);
		System.out.println(Arrays.toString(data));
	}
 
	public static void mergeSort(int data[], int left, int right) { // 数组的两端
		if (left < right) { // 相等了就表示只有一个数了 不用再拆了
			int mid = (left + right) / 2;
			mergeSort(data, left, mid);
			mergeSort(data, mid + 1, right);
			// 分完了 接下来就要进行合并，也就是我们递归里面归的过程
			merge(data, left, mid, right);
		}
	}
 
	public static void merge(int data[], int left, int mid, int right) {
		int temp[] = new int[data.length];		//借助一个临时数组用来保存合并的数据
		
		int point1 = left;		//表示的是左边的第一个数的位置
		int point2 = mid + 1;	//表示的是右边的第一个数的位置
		
		int loc = left;		//表示的是我们当前已经到了哪个位置了
		while(point1 <= mid && point2 <= right){
			if(data[point1] < data[point2]){
				temp[loc] = data[point1];
				point1 ++ ;
				loc ++ ;
			}else{
				temp[loc] = data[point2];
				point2 ++;
				loc ++ ;
			}
		}
    
		while(point1 <= mid){
			temp[loc ++] = data[point1 ++];
		}
		while(point2 <= right){
			temp[loc ++] = data[point2 ++];
		}
		for(int i = left ; i <= right ; i++){
			data[i] = temp[i];
		}
	}
}
```

# 希尔排序

希尔排序的核心在于间隔序列的设定，既可以提前设定好间隔序列，也可以动态的定义间隔序列

基本思想：算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d，对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成

希尔排序法(缩小增量法) 属于插入类排序，是将整个无序列分割成若干小的子序列分别进行插入排序的方法

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201211193635.png)

# 快速排序

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序

基准数一般就是取要排序序列的第一个

从后面往前找到比基准数小的数进行对换

从前面往后面找比基准数大的进行对换

```java
public class QuickSort {
    public static void quickSort(int[]arr,int low,int high){
         if (low < high) {     
             int middle = getMiddle(arr, low, high);     
             quickSort(arr, low, middle - 1);//递归左边            
             quickSort(arr, middle + 1, high);//递归右边   
          }  
    }
    public static int getMiddle(int[] list, int low, int high) {     
        int tmp = list[low];    
        while (low < high) {     
            while (low < high && list[high] >= tmp) {//大于关键字的在右边
                high--;     
            }     
            list[low] = list[high];//小于关键字则交换至左边   
            while (low < high && list[low] <= tmp) {//小于关键字的在左边
                low++;     
            }     
            list[high] = list[low];//大于关键字则交换至左边   
        }     
       list[low] = tmp;           
       return low;                   
    } 
}
```

```java
public class QuickSort {
 
	public static void quickSort(int data[], int left, int right) {
 
		int base = data[left]; // 基准数，取序列的第一个
		int ll = left; // 表示的是从左边找的位置
		int rr = right; // 表示从右边开始找的位置
		while (ll < rr) {
			// 从后面往前找比基准数小的数
			while (ll < rr && data[rr] >= base) {
				rr--;
			}
			if (ll < rr) { // 表示是找到有比之大的
				int temp = data[rr];
				data[rr] = data[ll];
				data[ll] = temp;
				ll++;
			}
			while (ll < rr && data[ll] <= base) {
				ll++;
			}
			if (ll < rr) {
				int temp = data[rr];
				data[rr] = data[ll];
				data[ll] = temp;
				rr--;
			}
		}
		// 肯定是递归 分成了三部分,左右继续快排，注意要加条件不然递归就栈溢出了
		if (left < ll)
			quickSort(data, left, ll - 1);
		if (ll < right)
			quickSort(data, ll + 1, right);
	}
}
```

## 优化

基本的快速排序选取第一个或最后一个元素作为基准。但是，这是一直很不好的处理方法

如果数组已经有序时，此时的分割就是一个非常不好的分割。因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为冒泡排序，时间复杂度为`O(n^2)`

**三数取中**

一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元

举例：待排序序列为：8 1 4 9 6 3 5 2 7 0

左边为：8，右边为0，中间为6

我们这里取三个数排序后，中间那个数作为枢轴，则枢轴为6

**插入排序**

当待排序序列的长度分割到一定大小后，使用插入排序 原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排

**重复数组**

在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割

在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少

具体过程：在处理过程中，会有两个步骤

第一步，在划分过程中，把与key相等元素放入数组的两端

第二步，划分结束后，把与key相等的元素移到枢轴周围

举例：

待排序序列 1 4 6 7 6 6 7 6 8 6

三数取中选取枢轴：下标为4的数6

转换后，待分割序列：6 4 6 7 1 6 7 6 8 6

枢轴key：6

第一步，在划分过程中，把与key相等元素放入数组的两端

结果为：6 4 1 6(枢轴) 7 8 7 6 6 6

此时，与6相等的元素全放入在两端了

第二步，划分结束后，把与key相等的元素移到枢轴周围

结果为：1 4 66(枢轴) 6 6 6 7 8 7

此时，与6相等的元素全移到枢轴周围了

之后，在1 4 和 7 8 7两个子序列进行快排

# 堆排序

如何建堆：

1.从最后一个非叶子节点开始，依次比较元素大小，开始堆化

2.从倒数第二个非叶子节点堆化

3.重复操作

**堆排序:**

1.将堆顶和最后一个元素交换

2.排除最后一个元素，继续建堆

3.重复1，2操作

```java
import java.util.Arrays;
 
public class HeapSort {
	public static void main(String[] args) {
		int data[] = { 8, 4, 20, 7, 3, 1, 25, 14, 17 };
		heapSort(data);
		System.out.println(Arrays.toString(data));
	}
 
	public static void maxHeap(int data[], int start, int end) { 
 
		int parent = start;
		int son = parent * 2 + 1; // 下标是从0开始的就要加1，从1就不用
		while (son < end) {
			int temp = son;
			// 比较左右节点和父节点的大小
			if (son + 1 < end && data[son] < data[son + 1]) { // 表示右节点比左节点大
				temp = son + 1; // 就要换右节点跟父节点
			}
			// temp表示的是 我们左右节点大的那一个
			if (data[parent] > data[temp])
				return; // 不用交换
			else { // 交换
				int t = data[parent];
				data[parent] = data[temp];
				data[temp] = t;
				parent = temp; // 继续堆化
				son = parent * 2 + 1;
			}
		}
		return;
 
	}
 
	public static void heapSort(int data[]) {
 
		int len = data.length;
		for (int i = len / 2 - 1; i >= 0; i--) { 
			maxHeap(data, i, len);		
		}
		for (int i = len - 1; i > 0; i--) {
			int temp = data[0];
			data[0] = data[i];
			data[i] = temp;
			maxHeap(data, 0, i);
		}
	}
 
}
```