---
title: 基础知识
categories: 
- Java基础
---

**静态初始化块、初始化块和构造方法**

> 非静态初始化块（构造代码块）：

作用：给对象进行初始化。对象一建立就运行，且优先于构造函数的运行。

与构造函数的区别：非静态初始化块给所有对象进行统一初始化，构造函数只给对应对象初始化。

应用：将所有构造函数共性的东西定义在构造代码块中。

初始化块真正体现其独一无二的作用是在匿名内部类中，由于是匿名内部类，因而无法写构造方法，但是很多时候还是要完成相应的初始化工作，这时就需要用到初始化块了

> 静态初始化块：

作用：给类进行初始化。随着类的加载而执行，且只执行一次

与构造代码块的区别：

1. 构造代码块用于初始化对象，每创建一个对象就会被执行一次；静态代码块用于初始化类，随着类的加载而执行，不管创建几个对象，都只执行一次。
2. 静态代码块优先于构造代码块的执行
3. 都定义在类中，一个带static关键字，一个不带static

执行顺序：

父类的静态初始化块->子类的静态初始化块->父类的初始化块->父类的构造函数->子类的初始化块->子类的构造函数

# 快速失败

在用迭代器遍历一个集合对象时，如果遍历过程中对如若改变了集合的结构，都被抛出ConcurrentModificationException异常

**什么是结构上的改变**

例如集合上的插入和删除就是结构上的改变，但是，如果是对集合中某个元素进行修改的话，并不是结构上的改变

它是集合中的一种错误检测机制

原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用`hashNext()/next()`遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历

**解决方法**

使用迭代器的remove方法

```java
public class NoFailFastSingleThread {
  public static void main(String[] args) {
      List<String> lists = new ArrayList<>(10);
      for (int i = 0; i < 4; i++){
          lists.add(String.valueOf(i));
      }
      Iterator<String> iterator = lists.iterator();
      while (iterator.hasNext()){
          String next = iterator.next();
          if (next != null){
              iterator.remove();
          }
      }
  }
}
```

**安全失败**

java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改