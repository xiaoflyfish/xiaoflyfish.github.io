---
title: 索引
categories: 
- MySQL
---

索引是帮助MySQL高效获取数据的数据结构，简单理解为：排好序的快速查找数据结构

**适合创建索引的情况**

1、主键自动创建唯一索引

2、频繁作为查询条件的字段应当创建索引

3、查询中与其他表关联的字段，即外键适合创建索引

4、查询中排序的字段适合创建索引，因为排序字段若通过索引去访问将大大提高排序速度

5、查询中统计或者分组的字段适合创建索引

**不适合建立索引的情况**

1、频繁更新的字段，经常增删改的表，不适合创建索引

2、WHERE条件里用不到字段不适合创建索引

3、表记录太少的情况无需建立索引

4、如果某个数据列中包含许多重复的内容，为它建立索引就没有太大的实际效果

# 分类

按结构分：Hash索引和B+树索引

根据索引字段个数划分：单值和复合索引

根据是否是在主键上建立的索引进行划分：主键索引，辅助索引

根据数据与索引的存储关联性划分：聚簇索引/非聚簇索引

其他分类：唯一索引，全文索引

**聚簇索引/非聚簇索引**

聚簇索引：Innodb的主键索引，非叶子节点存储的是索引指针，叶子节点存储的是既有索引也有数据

非聚簇索引：MyISAM中索引和数据文件分开存储，B+Tree的叶子节点存储的是数据存放的地址，而不是具体的数据

# B+树

**B+树比B树更适合数据库索引的原因**

1.B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当

2.由于非叶子节点不存储 data，所以一个节点可以存储更多的索引节点，每个节点能索引的范围更大更精确。也就是说使用 B+树单次磁盘 I/O 的信息量相比较 B 树更大，I/O 效率更高

3.B+树只要遍历叶子节点就可以实现整棵树的遍历，支持基于范围的查询

# 索引失效

**最佳左前缀法则**

如果索引了多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始 并且 不跳过索引中的列

不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描

不能继续使用索引中范围条件（bettween、<、>、in等）右边的列

尽量使用覆盖索引（只查询索引的列（索引列和查询列一致）），减少select *

索引字段上使用（！= 或者 < >）判断时，会导致索引失效而转向全表扫描

索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描

索引字段使用like以通配符开头（%字符串）时，会导致索引失效而转向全表扫描

索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描

索引字段使用 or 时，会导致索引失效而转向全表扫描

# 索引下推

索引下推简称ICP，在Mysql5.6的版本上推出，用于优化查询

在开始之前先先准备一张用户表(user)，其中主要几个字段有：id、name、age、address

建立联合索引（name，age）

```sql
SELECT * from user where  name like '陈%' and age=20
```

5.6之前的版本是没有索引下推这个优化的

会忽略age这个字段，直接通过name进行查询，在(name,age)这棵树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要**回表两次**

**5.6版本添加了索引下推这个优化**

InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，**这个过程只需要回表一次**

根据explain解析结果可以看出Extra的值为**Using index condition**，表示已经使用了索引下推