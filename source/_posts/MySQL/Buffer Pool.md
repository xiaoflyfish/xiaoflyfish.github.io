---
title: Buffer Pool
categories: 
- MySQL
---

Buffer Pool就是数据库的一个内存组件，里面缓存了磁盘上的真实数据，然后我们的Java系统对数据库执行的增删改操 作，其实主要就是对这个内存数据结构中的缓存数据执行的

在对数据库执行增删改操作的时候，实际上主要都是针对内存里的`Buffer Pool`中的数据进行的，也 就是你实际上主要是对数据库的内存里的数据结构进行了增删改

# 数据结构

Buffer Pool默认情况下是128MB

我 们的磁盘文件中就是会有很多的数据页，每一页数据里放了很多行数据

所以实际上假设我们要更新一行数据，此时数据库会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页直接给加载到Buffer Pool里去

**磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来**

实际上默认情况下，磁盘中存放的数据页的大小是16KB，也就是说，一页数据包含了16KB的内容。

而Buffer Pool中存放的一个一个的数据页，我们通常叫做缓存页，因为毕竟Buffer Pool是一个缓冲池，里面的数据都是从磁 盘缓存到内存去的。

而Buffer Pool中默认情况下，一个缓存页的大小和磁盘上的一个数据页的大小是一一对应起来的，都是16KB。

**缓存页对应的描述信息**

每个缓存页都会对应一个描述信息，这个描述信息本身也是一块数据，在Buffer Pool中，每个缓存页的描述数据放在最前面， 然后各个缓存页放在后面

包含如下的一些东西：这个数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址

描述数据大概相当于缓存页大小的5%左右

# Free链表

他是一个双向链表数据结构，这个free链表里，每个节点就是一个空闲的缓存 页的描述数据块的地址，也就是说，只要你一个缓存页是空闲的，那么他的描述数据块就会被放入这个free链表中

我们需要从free链表里获取一个描述数据块，然后就可以对应的获取到这个描述数据块对应的空闲缓存页

接着我们就可以把磁盘上的数据页读取到对应的缓存页里去，同时把相关的一些描述数据写入缓存页的描述数据块里去，比如 这个数据页所属的表空间之类的信息，最后把那个描述数据块从free链表里去除就可以了

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201223075637.png" style="zoom:50%;" />

**怎么知道数据页有没有被缓存**

其实数据库还会有一个哈希表数据结构，他会用表空间号+数据页号，作为一个key，然后缓存页的地址作为value。

当你要使用一个数据页的时候，通过“表空间号+数据页号”作为key去这个哈希表里查一下，如果没有就读取数据页，如果 已经有了，就说明数据页已经被缓存了

# Flush链表

凡是被修改过的缓存页，都会把他的描述数据块加入到flush链表中去，flush的意思就是这些都是脏页，后续都是要flush刷新到磁盘上去的

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201223075918.png" style="zoom:50%;" />

# LRU算法

通过这个LRU链表，我们可以知道哪些缓存页是最近最少被使用的，那么当你缓存页需要腾出来一个刷入磁盘的时 候，就可以选择那个LRU链表中最近最少被使用的缓存页了

**MySQL的预读机制**

假设现在有两个空闲缓存页，然后在加载一个数据页的时候，连带着把他的一个相邻的数据页也加载到缓存里去了，正好每个数据页放入一个空闲缓存页

**为什么MySQL要设计一个预读机制**

说白了为了提升性能。假设你读取了数据页01到缓存页里去，那么好，接下来有可能会接着顺序读取数据页01相邻的数据页02到缓存页里去，这个时候，是不是可能在读取数据页02的时候要再次发起一次磁盘 IO，所以为了优化性能，MySQL才设计了预读机制，也就是说如果在一个区内，你顺序读取了好多数据页了，比如数据页 01~数据页56都被你依次顺序读取了，MySQL会判断，你可能接着会继续顺序读取后面的数据页

如果你预读的一大堆数据页要是占据了LRU链表的前面部分，可能这些预读的数据页压根儿后续没人会使用，那你这个预读机制就是在捣乱了

## 优化LRU

**冷热数据分离**

为了解决上面说的简单的LRU链表的问题，真正MySQL在设计LRU链表的时候，采取的实际上是冷热数据分离的思想

真正的LRU链表，会被拆分为两个部分，一部分是热数据，一部分是冷数据，这个冷热数据的比例是由` innodb_old_blocks_pct`参数控制的，他默认是37，也就是说冷数据占比37%

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201223082313.png" style="zoom:50%;" />

第一次把一个数据页加载到缓存页之后，这个缓存页实际上是被放在冷数据区域的链表头部位置

MySQL设定了一个规则，他设计了一个`innodb_old_blocks_time`参数，默认值1000，也就是1000毫秒

必须是一个数据页被加载到缓存页之后，在1s之后，你访问这个缓存页，他才会被挪动到热数据区域的链 表头部去

当你要淘汰缓存的时候，优先就是会选择冷数据区域的尾部的缓存页，他不会让刚加载进来的缓存页占据LRU链表的头部，频繁访问的缓存页在LRU链表的尾部，淘汰的时候淘汰尾部的频繁访问的缓存页了

## 性能优化

**LRU链表的热数据区域是如何进行优化的**

LRU链表的热数据区域的访问规则被优化了一下，即你只有在热数据区域的后3/4部分的缓存页被访问了，才 会给你移动到链表头部去

举个例子，假设热数据区域的链表里有100个缓存页，那么排在前面的25个缓存页，他即使被访问了，也不会移动到 链表头部去的。但是对于排在后面的75个缓存页，他只要被访问，就会移动到链表头部去。 这样的话，他就可以尽可能的减少链表中的节点移动了

# 淘汰缓存页

有一个后台线程，他会运行一个定时任务，这个定时任务每隔一段时间就会把LRU链表的冷数据区域的尾部的一些缓存页，刷入 磁盘里去，清空这几个缓存页，把他们加入回free链表去

# 并发优化

线程并发访问一个`Buffer Pool`，必然是要加锁的，然后让一个线程先完成一系列的操作，比如说加载数据页到 缓存页，更新free链表，更新lru链表，然后释放锁，接着下一个线程再执行一系列的操作

**MySQL的生产优化经验：多个Buffer Pool优化并发能力**

一般来说，MySQL默认的规则是，如果你给Buffer Pool分配的内存小于1GB，那么最多就只会给你一个Buffer Pool。

但是如果你的机器内存很大，那么你必然会给Buffer Pool分配较大的内存，比如给他个8G内存，那么此时你是同时可 以设置多个Buffer Pool的

这个时候，假设多个线程并发过来访问，那么不就可以把压力分散开来了

有的线程访问这个buffer pool，有的线程访问那个buffer pool

# 动态调整大小

他实际上设计了一个chunk机制，也就是说buffer pool是由很多chunk组 成的，他的大小是`innodb_buffer_pool_chunk_size`参数控制的，默认值就是128MB。

所以实际上我们可以来做一个假设，比如现在我们给buffer pool设置一个总大小是8GB，然后有4个buffer pool，那 么每个buffer pool就是2GB，此时每个buffer pool是由一系列的128MB的chunk组成的，也就是说每个`buffer pool `会有16个chunk。

然后每个buffer pool里的每个chunk里就是一系列的描述数据块和缓存页，每个`buffer pool`里的多个chunk共享一套 free、flush、lru这些链表

**基于chunk机制是如何支持运行期间，动态调整buffer pool大小的**

比如我们buffer pool现在总大小是8GB，现在要动态加到16GB，那么此时只要申请一系列的128MB大小的`chunk`就 可以了，只要每个chunk是连续的128MB内存就行了。然后把这些申请到的chunk内存分配给buffer pool就行了。

有个这个chunk机制，此时并不需要额外申请16GB的连续内存空间，然后还要把已有的数据进行拷贝。