---
title: 事务
categories: 
- MySQL
---

# ACID

**原子性**

根据定义，原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。即要么转账成功，要么转账失败

**怎么保证原子性的**

利用Innodb的undo log

undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息

例如：

- (1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
- (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
- (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作

undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子

**隔离性**

根据定义，隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰

**怎么保证隔离性的**

利用的是锁和MVCC机制

**持久性**

根据定义，持久性是指事务一旦提交，它对数据库的改变就应该是永久性的

**怎么保证持久性的**

利用Innodb的redo log

当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和bin log内容决定回滚数据还是提交数据

**一致性**

根据定义，一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的

**那什么是合法的数据状态呢？**

这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的

# 事务隔离级别

**读未提交**

当隔离级别设置为Read uncommitted 时，就可能出现脏读

**读已提交**

Oracle和SQL Server默认隔离级别

当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读

**可重复读**

MySQL默认隔离级别

Repeatable read避免了不可重复读，但还有可能出现幻读

**可序列化**

Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读

