---
title: Order By
categories: 
- MySQL
---

# 工作原理

MySQL会给每个线程分配一块内存用于排序，称为**sort_buffer**。

**全字段排序:**

一般带有order by 的SQL语句 会初始化`sort_buffer`，放入需要返回的字段。

查找一条记录就放入到`sort_buffer`,继续找，直到找完符合条件的为止。

对`sort_buffer`中的数据按照字段如name快速排序(归并排序);

排序这个动作可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数`sort_buffer_size`。

缺点: 如果查询要返回的字段很多的话，那么`sort_buffer` 要放的字段数太多，要分成很多个临时文件来归并排序。排序的性能会很差。

**rowid排序:**

参数 `max_length_for_sort_data` 是MySQL 中专门控制用于排序的行数据的长度的。

如果单行的长度超过这个值，MySQL就认为单行太大，需要换一个算法。

新的算法只将要排序的字段和主键id 放入`sort_buffer`中，最后排完序根据主键id的值回表去取对应的字段返回给客户端。

**比较:**

MySQL担心排序内存太小，才会采用rowid算法。虽然可以一次排序更多行，但是需要回表取数据。

MySQL认为内存足够大，会优先选择全字段排序，把需要的字段都放到`sort_buffer`中，这样排序后就可以直接从内存返回查询结果了，不用再回表。

这就体现了MySQL的一个设计思想: 如果内存够，就要多利用内存，尽量减少磁盘访问。

**覆盖索引优化**

并不是所有的order by语句都需要排序操作的。之所欲需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据都是无序的。

如果能保证从某个索引上取出来的数据，天然就是按照要排序字段递增排序的话，是不是就不用排序了？

这时候创建一个联合索引，是取值的字段和要排序的字段(where条件字段，order by 字段)。

这时候，只要where条件字段的值是同一个值，order by 字段的值就一定是有序的。

还可以继续优化，也就是覆盖索引，直接创建需要取值的字段的联合索引。但是也不是查询都需要用上覆盖索引，因为索引的维护是由代价的，需要自己权衡选择。

比如select name,age,city 。 直接创建(name,age,city)联合索引。就不需要回表去取数据了。