---
title: 锁
categories: 
- MySQL
---

# 行锁

行锁，也称为记录锁，顾名思义就是在记录上加的锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

**行锁类型**

1.Record Locks：

我们前边提到的记录锁就是这种类型，也就是仅仅把一条记录锁上。官方的类型名称为：`LOCK_REC_NOT_GAP`。

记录锁是有S（共享）锁和X（排他）锁之分的，分别称之为S型记录锁和X型记录锁，当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁；

2.Gap Locks：

我们说MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决。InnoDB他们提出了一种称之为Gap Locks的锁，官方的类型名称为：`LOCK_GAP`，我们也可以简称为gap锁。

3.Next-Key Locks：

有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以设计InnoDB就提出了一种称之为Next-Key Locks的锁，官方的类型名称为：`LOCK_ORDINARY`，我们也可以简称为next-key锁。

next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。

4.Insert Intention Locks：

我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的gap锁（next-key锁也包含gap锁），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。

但是InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为Insert Intention Locks，官方的类型名称为：`LOCK_INSERT_INTENTION`，我们也可以称为插入意向锁。