---
title: 锁
categories: 
- MySQL
---

# 行锁

行锁，也称为记录锁，顾名思义就是在记录上加的锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

**行锁类型**

> Record Locks：

我们前边提到的记录锁就是这种类型，也就是仅仅把一条记录锁上。官方的类型名称为：`LOCK_REC_NOT_GAP`。

记录锁是有S（共享）锁和X（排他）锁之分的，分别称之为S型记录锁和X型记录锁，当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁；

> Gap Locks：

我们说MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC方案解决，也可以采用加锁方案解决。InnoDB他们提出了一种称之为Gap Locks的锁，官方的类型名称为：`LOCK_GAP`，我们也可以简称为gap锁。

> Next-Key Locks：

有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以设计InnoDB就提出了一种称之为Next-Key Locks的锁，官方的类型名称为：`LOCK_ORDINARY`，我们也可以简称为next-key锁。

next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。

**一致性非锁定读**

是指InnoDB存储引擎通过多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放，相反地，InnoDB存储引擎会去读取行的一个快照数据。

非锁定读机制极大地提高了数据库的并发性，这是InnoDB存储引擎的默认读取方式。

但是在不同事务隔离级别下，读取的方式不一定相同。此外，即使都是使用非锁定的一致性读，但是对于快照数据的定义也各不相同。在事务隔离级别READ COMMITTED 和REPEATABLE READ下，InnoDB都使用非锁定一致性读。然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总数读取被锁定行的最新的快照数据。而在REPEATABLE READ事务隔离级别下，对于快照数据，非锁定一致性读总是获取事务开始时的行数据版本。

快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本，因此一行记录可能有不止一个快照数据

**一致性锁定读** 

在某些情况下，用户需要显示地对数据库读取操作进行加锁，以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于SELECT的只读操作

InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读操作：

SELECT...FOR UPDATE 对读取的行记录加一个X锁；

SELECT...LOCK IN SHARE MODE对读取的行记录加一个S锁。