---
title: 分布式ID
categories: 
- 分布式
---

# UUID

UUID 虽然很好地满足了全局唯一这个要求，但是并不适合作为数据库存储的唯一主键

比如：`135c8321-bf10-46d3-9980-19ba588554e8`，这是一个 36 位的字符串

首先 UUID 作为数据库主键太长了，会导致比较大的存储开销，另外一个，UUID 是无序的，如果使用 UUID 作为主键，会降低数据库的写入性能

# 雪花算法

SnowFlake是`Twitter`开源的分布式ID生成算法，结果是一个long型的ID

整个结构是64位，该算法实现基本就是二进制操作，单机每秒内理论上最多可以生成`1024*(2^12)`，也就是409.6万个ID(`1024 X 4096 = 4194304`)

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201230222039.png" style="zoom:33%;" />

-  1位标识，由于long基本类型是带符号的，最高位是符号位，正数是0，负数是1，id一般是正数，最高位是0
-  41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的，41位的时间截，可以使用69年，年=` (1L << 41) / (1000L * 60 * 60 * 24 * 365)` = 69
-  10位的数据机器位，可以部署在1024个节点，包括5位`datacenterId`和5位`workerId`，`10-bit`机器可以分别表示1024台机器
-  12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒产生4096个ID序号，理论上`SnowFlake`方案的QPS约为409.6w/s，这种分配方式可以保证在任何一台机器在任意毫秒内生成的ID都是不同的

 加起来刚好64位，为一个Long型

**优点：**

整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右

> 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的
> 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的
> 可以根据自身业务特性分配bit位，非常灵活

**缺点：**

> 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态
> 针对此，美团做出了改进：https://github.com/Meituan-Dianping/Leaf

