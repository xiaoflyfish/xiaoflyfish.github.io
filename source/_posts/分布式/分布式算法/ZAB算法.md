---
title: ZAB算法
categories: 
- 分布式算法
- 选举算法
---

ZAB算法是为 ZooKeeper 实现分布式协调功能而设计的。

相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。

相比较于 Raft 算法，ZAB 算法尽可能保证数据的最新性。所以，ZAB 算法可以说是对 Raft 算法的改进。

使用 ZAB 算法选举时，集群中每个节点拥有 3 种角色：

- Leader，主节点；
- Follower，跟随者节点；
- Observer，观察者，无投票权。

选举过程中，集群中的节点拥有 4 个状态：

- Looking 状态，即选举状态。当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态。
- Leading 状态，即领导者状态，表示已经选出主，且当前节点为 Leader。
- Following 状态，即跟随者状态，集群中已经选出主后，其他非主节点状态更新为 Following，表示对 Leader 的追随。
- Observing 状态，即观察者状态，表示当前节点为 Observer，持观望态度，没有投票权和选举权。

投票过程中，每个节点都有一个唯一的三元组 (`server_id, server_zxID, epoch`)，其中 `server_id` 表示本节点的唯一 ID；`server_zxID` 表示本节点存放的数据 ID，数据 ID 越大表示数据越新，选举权重越大；epoch 表示当前选取轮数，一般用逻辑时钟表示。

ZAB 选举算法的核心是“少数服从多数，ID 大的节点优先成为主”，因此选举过程中通过 `(vote_id, vote_zxID`) 来表明投票给哪个节点，其中`vote_id` 表示被投票节点的 ID，`vote_zxID` 表示被投票节点的服务器 zxID。

**ZAB 算法选主的原则是：server_zxID 最大者成为 Leader；若 server_zxID 相同，则 server_id 最大者成为 Leader。**

**假设有 3 台 Server A、B、C， Leader 的选举过程如下：**

1. 每台 Server 会发出一个投票Server 启动时，状态为 LOOKING，将发出投票选举 Leader，投票的格式为（sid, ZXID）

- sid：被推举的 Leader 的 SID 值（每台 Server 的唯一 ID，由配置文件配置）
- ZXID：被推举的 Leader 的事务 ID

	ZXID，这里由于是集群启动，所以各 Server 的 ZXID 均为0。

	由于每台 Server 不知道其他机器的情况，唯一能确定的是自身是在运行的，因此，第一票都将投给自己。这里假设 Server A、B、C 的 SID 是 1、2、3，则发出的投票分别为 (1,0)、(2,0)、(3,0)。

2. 接收来自各服务器的投票

3. 处理投票
   对于接收到的投票，将会依次与自己的投票进行比较，比较的规则是依次比较 ZXID、sid 的大小，这里由于 ZXID 都是 0，无法决定哪个投票更大，因此会比较 Sid。当接收到的投票大于自身投票时，则会更新投票内容，否则不更新，再向集群中的其他 Server 发出投票。

4. 统计投票
   每次投票后，会统计所有的投票，如果有过半的投票推举了某台 Server，则认为已经选出了 Leader，将不再发送投票。

5. 改变服务器状态
   确定 Leader 后，如果自身是 Leader，将状态更改为 LEADING，如果是 Follower，则状态变更为 FOLLOWING。

ZAB 算法性能高，对系统无特殊要求，采用广播方式发送信息，若节点中有 n 个节点，每个节点同时广播，则集群中信息量为 `n*(n-1)` 个消息，容易出现广播风暴；且除了投票，还增加了对比节点 ID 和数据 ID，这就意味着还需要知道所有节点的 ID 和数据 ID，所以选举时间相对较长。但该算法选举稳定性比较好，当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点数据 ID 和节点 ID 最大，且获得投票数过半，才会导致切主。