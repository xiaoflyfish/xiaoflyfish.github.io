---
title: TCC
categories: 
- 分布式
- 分布式事务
---

TCC 把事务运行过程分成` Try、Confirm/Cancel `两个阶段，每个阶段的逻辑由业务代码控制，避免了长事务，可以获取更高的性能

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201228215327.png" style="zoom:33%;" />

Try 阶段：调用 `Try` 接口，尝试执行业务，完成所有业务检查，预留业务资源。

Confirm 或 `Cancel` 阶段：两者是互斥的，只能进入其中一个，并且都满足幂等性，允许失败重试。

Confirm 操作：对业务系统做确认提交，确认执行业务操作，不做其他业务检查，只使用 `Try `阶段预留的业务资源

Cancel 操作：在业务执行错误，需要回滚的状态下执行业务取消，释放预留资源

**Try 阶段失败可以 Cancel，如果 Confirm 和 Cancel 阶段失败了怎么办**

TCC 中会添加事务日志，如果 Confirm 或者 `Cancel` 阶段出错，则会进行重试，所以这两个阶段需要支持幂等；如果重试失败，则需要人工介入进行恢复和处理等

**TCC的优缺点**

实际开发中，`TCC` 的本质是把数据库的二阶段提交上升到微服务来实现，从而避免数据库二阶段中长事务引起的低性能风险。

所以说，TCC 解决了跨服务的业务操作原子性问题，比如下订单减库存，多渠道组合支付等场景，通过 `TCC` 对业务进行拆解，可以让应用自己定义数据库操作的粒度，可以降低锁冲突，提高系统的业务吞吐量。

TCC 的不足主要体现在对微服务的侵入性强，TCC 需要对业务系统进行改造，业务逻辑的每个分支都需要实现` Try、Confirm、Cancel` 三个操作，并且 `Confirm、Cance`l 必须保证幂等。

另外` TCC `的事务管理器要记录事务日志，也会损耗一定的性能。

**真实业务场景分析 TCC**

以一个电商中的支付业务来演示，用户在支付以后，需要进行更新订单状态、扣减账户余额、增加账户积分和扣减商品操作

**我们把订单业务拆解为以下几个步骤：**

- 订单更新为支付完成状态
- 扣减用户账户余额
- 增加用户账户积分
- 扣减当前商品的库存

**下面应用 TCC 事务，需要对业务代码改造，抽象 Try、Confirm 和 Cancel 阶段**

> Try 操作

Try 操作一般都是锁定某个资源，设置一个预备的状态，冻结部分数据。比如，订单服务添加一个预备状态，修改为 `UPDATING`，也就是更新中的意思，冻结当前订单的操作，而不是直接修改为支付成功。

库存服务设置冻结库存，可以扩展字段，也可以额外添加新的库存冻结表。积分服务和库存一样，添加一个预增加积分，比如本次订单积分是 100，添加一个额外的存储表示等待增加的积分，账户余额服务等也是一样的操作。

> Confirm操作

Confirm 操作就是把前边的 Try 操作锁定的资源提交，类比数据库事务中的 `Commit` 操作。在支付的场景中，包括订单状态从准备中更新为支付成功；库存数据扣减冻结库存，积分数据增加预增加积分。

> Cancel操作

Cancel 操作执行的是业务上的回滚处理，类比数据库事务中的 `Rollback` 操作。首先订单服务，撤销预备状态，还原为待支付状态或者已取消状态，库存服务删除冻结库存，添加到可销售库存中，积分服务也是一样，将预增加积分扣减掉。

**对比2PC两阶段提交**

TCC 事务模型的思想类似 `2PC` 提交，下面对比 TCC 和基于 `2PC` 事务 XA 规范对比

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201228220042.png" style="zoom:33%;" />

2PC/XA 是数据库或者存储资源层面的事务，实现的是强一致性，在两阶段提交的整个过程中，一直会持有数据库的锁

TCC 关注业务层的正确提交和回滚，在` Try` 阶段不涉及加锁，是业务层的分布式事务，关注最终一致性，不会一直持有各个业务资源的锁。