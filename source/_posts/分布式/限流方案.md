---
title: 限流方案
categories: 
- 分布式
---

# 容器限流

**Tomcat限流**

Tomcat 8.5 版本的最大线程数在 `conf/server.xml` 配置

```xml
<Connector port="8080" protocol="HTTP/1.1"
          connectionTimeout="20000"
          maxThreads="150"
          redirectPort="8443" />
```

**Nginx限流**

Nginx提供了两种限流手段：一是控制速率，二是控制并发连接数

> 控制速率

我们需要使用 `limit_req_zone` 用来限制单位时间内的请求数，即速率限制

```nginx
limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;
server { 
    location / { 
        limit_req zone=mylimit;
    }
}
```

以上配置表示，限制每个 IP 访问的速度为 2r/s，因为 `Nginx` 的限流统计是基于毫秒的，我们设置的速度是 2r/s，转换一下就是 500ms 内单个 IP 只允许通过 1 个请求，从 501ms 开始才允许通过第 2 个请求

> 控制并发数

利用 `limit_conn_zone` 和 `limit_conn` 两个指令即可控制并发数

```nginx
limit_conn_zone $binary_remote_addr zone=perip:10m;
limit_conn_zone $server_name zone=perserver:10m;
server {
    ...
    limit_conn perip 10;
    limit_conn perserver 100;
}
```

其中 `limit_conn perip 10` 表示限制单个 IP 同时最多能持有 10 个连接；`limit_conn perserver` 100 表示 server 同时能处理并发连接的总数为 100 个

# 服务端限流

**时间窗口算法**

所谓的滑动时间算法指的是以当前时间为截止时间，往前取一定的时间，比如往前取 60s 的时间，在这 60s 之内运行最大的访问数为 100，此时算法的执行逻辑为，先清除 60s 之前的所有请求记录，再计算当前集合内请求数量是否大于设定的最大请求数 100，如果大于则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端

可以借助 Redis 的有序集合 `ZSet` 来实现时间窗口算法限流，实现的过程是先使用 `ZSet` 的 key 存储限流的 ID，score 用来存储请求的时间，每次有请求访问来了之后，先清空之前时间窗口的访问量，统计现在时间窗口的个数和最大允许访问量对比，如果大于等于最大访问量则返回 false 执行限流操作，负责允许执行业务逻辑，并且在 `ZSet` 中添加一条有效的访问记录

**漏桶算法**

漏桶算法的实现步骤是，先声明一个队列用来保存请求，这个队列相当于漏斗，当队列容量满了之后就放弃新来的请求，然后重新声明一个线程定期从任务队列中获取一个或多个任务进行执行，这样就实现了漏桶算法

实现可以使用 `Redis 4.0` 版本中提供的 `Redis-Cell` 模块，该模块使用的是漏斗算法

**令牌算法**

在令牌桶算法中有一个程序以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，如果没有获取到令牌的请求可以选择等待或者放弃执行

我们可以使用 `Google` 开源的 `guava` 包，很方便的实现令牌桶算法