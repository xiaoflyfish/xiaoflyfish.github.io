---
title: 死锁
categories: 
- 并发编程
- 锁
---

死锁就是两个或多个线程（或进程）被无限期地阻塞，相互等待对方手中资源的一种状态

```java
public class DeadLock {
    private final String write_lock = new String();
    private final String read_lock = new String();

    public void read() {
        synchronized (read_lock) {
            System.out.println(Thread.currentThread().getName() + " got read lock and then i want to write");
            synchronized (write_lock) {
                System.out.println(Thread.currentThread().getName() + " got read lock and write lock");
            }
        }
    }

    public void write() {
        synchronized (write_lock) {
            System.out.println(Thread.currentThread().getName() + " got write lock and then i want to read");
            synchronized (read_lock) {
                System.out.println(Thread.currentThread().getName() + " got write lock and read lock");
            }
        }
    }

    public static void main(String[] args) {
        DeadLock deadLock = new DeadLock();
        new Thread(() -> {
            while (true) {
                deadLock.read();
            }
        },"read-first-thread").start();

        new Thread(() -> {
            while (true) {
                deadLock.write();
            }
        },"write-first-thread").start();
    }
}
```

**如何预防死锁**

1.尽量保证加锁顺序是一样的

例如有A,B,C三把锁。

Thread 1的加锁顺序为A、B、C这样的。

Thread 2的加锁顺序为A、C，这样就不会死锁。

如果Thread2的加锁顺序为B、A或者C、A这样顺序就不一致了，就会出现死锁问题。

2.尽量用超时放弃机制

Lock接口提供了`tryLock(long time, TimeUnit unit)`方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。可以避免死锁问题



