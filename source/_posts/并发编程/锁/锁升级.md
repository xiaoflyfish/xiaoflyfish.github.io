---
title: 锁升级
categories: 
- 并发编程
- 锁
---

锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁

随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级

从JDK 1.6中默认是开启偏向锁和轻量级锁的，可以通过`-XX:-UseBiasedLocking`来禁用偏向锁

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201230194359.png" style="zoom:20%;" />

# 偏向锁

为了减少同一线程获取锁的代价而引入偏向锁

偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时`Mark Word`的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能

**偏向锁的升级**

当线程1访问代码块并获取锁对象时，会在对象头和栈帧中记录偏向的锁的`threadID`，因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的`threadID`和对象头中的`threadID`是否一致，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；

如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的`threadID`），那么需要查看对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程

**偏向锁的取消：**

偏向锁是默认开启的，而且开始时间一般是比应用程序启动慢几秒，如果不想有这个延迟，那么可以使用`-XX:BiasedLockingStartUpDelay=0`；

如果不想要偏向锁，那么可以通过`-XX:-UseBiasedLocking = false`来设置；

# 轻量级锁

轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景

因为阻塞线程需要`CPU`从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放

**轻量级锁什么时候升级为重量级锁**

轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能

轻量级锁的获取主要由两种情况：

1.当关闭偏向锁功能时；

2.由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁

在代码进入同步块的时候，如果同步对象锁状态为无锁状态，虚拟机将首先在当前线程的栈帧中建立一个名为锁记录（`Lock Record`）的空间，用于存储锁对象目前的`Mark Word`的拷贝，然后将对象头中的`Mark Word`复制到锁记录中

拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 `Mark Word` 更新为指向 `Lock Record` 的指针，并将 `Lock Record` 里的 `owner` 指针指向对象的 Mark Word

如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象`Mark Word`的锁标志位设置为`00`，表示此对象处于轻量级锁定状态

如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的`Mark Word`是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁

若当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）

另外，当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁（锁膨胀）

**重量级锁把除了拥有锁的线程都阻塞，防止CPU空转**

# 重量级锁

重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态

重量级锁通过对象内部的监视器（`monitor`）实现，而其中 `monitor` 的本质是依赖于底层操作系统的 `Mutex Lock` 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高

简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源，导致性能低下