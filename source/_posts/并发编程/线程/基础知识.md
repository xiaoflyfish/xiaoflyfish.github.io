---
title: 基础知识
categories: 
- 并发编程
- 线程
---

# Callable

Callable 是一个类似于 Runnable 的接口，实现 Callable 接口的类和实现 Runnable 接口的类都是可以被其他线程执行的任务。 我们看一下 Callable 的源码：

```java
public interface Callable<V> {
     V call() throws Exception;
}
```

可以看出它也是一个 interface，并且它的 call 方法中已经声明了 throws Exception，前面还有一个 V 泛型的返回值，这就和之前的 Runnable 有很大的区别。实现 Callable 接口，就要实现 call 方法，这个方法的返回值是泛型 V，如果把 call 中计算得到的结果放到这个对象中，就可以利用 call 方法的返回值来获得子线程的执行结果了。

**Callable 和 Runnable 的不同之处**

方法名，Callable 规定的执行方法是 call()，而 Runnable 规定的执行方法是 run()；

返回值，Callable 的任务执行后有返回值，而 Runnable 的任务执行后是没有返回值的；

抛出异常，call() 方法可抛出异常，而 run() 方法是不能抛出受检查异常的；

和 Callable 配合的有一个 Future 类，通过 Future 可以了解任务执行情况，或者取消任务的执行，还可获取任务执行的结果，这些功能都是 Runnable 做不到的，Callable 的功能要比 Runnable 强大。

**既然Callable接口这么强大，那Callable是不是用来代替Runnable的**

不是的，它们并存，例如Thread类初始化时不接受Callable作为参数。

# Wait方法

**为什么 wait 必须在 synchronized 保护的同步代码中使用**

```java
synchronized (obj) {
     while (condition does not hold)
         obj.wait();
     ... // Perform action appropriate to condition
}
```

这里的**判断-执行**不是一个原子操作，它在中间被打断了，是线程不安全的

这里还存在一个**虚假唤醒**的问题，线程可能在既没有被notify/notifyAll，也没有被中断或者超时的情况下被唤醒，这种唤醒是我们不希望看到的。虽然在实际生产中，虚假唤醒发生的概率很小，但是程序依然需要保证在发生虚假唤醒的时候的正确性，所以就需要采用while循环的结构

这样即便被虚假唤醒了，也会再次检查while里面的条件，如果不满足条件，就会继续wait，也就消除了虚假唤醒的风险

**wait/notify 和 sleep 方法的异同**

它们都可以让线程阻塞。

它们都可以响应 interrupt 中断：在等待的过程中如果收到中断信号，都可以进行响应，并抛出 InterruptedException 异常。

但是它们也有很多的不同点：

- wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。
- 在同步代码中执行 sleep 方法时，并不会释放 monitor 锁，但执行 wait 方法时会主动释放 monitor 锁。
- wait/notify 是 Object 类的方法，而 sleep 是 Thread 类的方法

