---
title: 线程安全
categories: 
- 并发编程
- 线程
---

当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行问题，也不需要进行额外的同步，而调用这个对象的行为都可以获得正确的结果，那这个对象便是线程安全的

# 活跃性问题

活跃性问题就是程序始终得不到运行的最终结果，比如发生死锁会导致程序完全卡死，无法向下运行。

最典型的有三种，分别为死锁、活锁和饥饿

**死锁**

最常见的活跃性问题是死锁，死锁是指两个线程之间相互等待对方资源，但同时又互不相让，都想自己先执行

**活锁**

活锁与死锁非常相似，也是程序一直等不到结果，但对比于死锁，活锁是活的，什么意思呢？因为正在运行的线程并没有阻塞，它始终在运行中，却一直得不到结果

**饥饿**

饥饿是指线程需要某些资源时始终得不到，尤其是CPU 资源，就会导致线程一直不能运行而产生的问题。

在 Java 中有线程优先级的概念，Java 中优先级分为 1 到 10，1 最低，10 最高。

如果我们把某个线程的优先级设置为 1，这是最低的优先级，在这种情况下，这个线程就有可能始终分配不到 CPU 资源，而导致长时间无法运行。

**哪些场景需要额外注意线程安全问题**

1.访问共享变量或资源

第一种场景是访问共享变量或共享资源的时候，典型的场景有访问共享对象的属性，访问 static 静态变量，访问共享的缓存，等等

2.依赖时序的操作

第二个需要我们注意的场景是依赖时序的操作，如果我们操作的正确性是依赖时序的，而在多线程的情况下又不能保障执行的顺序和我们预想的一致，这个时候就会发生线程安全问题

```java
if (map.containsKey(key)) {
    map.remove(obj)
}
```

3.不同数据之间存在绑定关系

第三种需要我们注意的线程安全场景是不同数据之间存在相互绑定关系的情况

4.对方没有声明自己是线程安全的

第四种值得注意的场景是在我们使用其他类时，如果对方没有声明自己是线程安全的，那么这种情况下对其他类进行多线程的并发操作，就有可能会发生线程安全问题

