---
title: 生命周期
categories: 
- 并发编程
- 线程
---

线程的状态在 JDK 1.5 之后以枚举的方式被定义在 Thread 的源码中，它总共包含以下 6 个状态：

- **NEW**，新建状态，线程被创建出来，但尚未启动时的线程状态；
- **RUNNABLE**，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；
- **BLOCKED**，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 `synchronized` 代码块或者使用 synchronized 标记的方法；
- **WAITING**，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 `Object.wait()` 方法，那它就在等待另一个线程调用 `Object.notify()` 或 `Object.notifyAll() `方法；
- **TIMED_WAITING**，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 `Object.wait(long timeout)` 和 `Thread.join(long timeout)` 等这些方法时，它才会进入此状态；
- **TERMINATED**，终止状态，表示线程已经执行完成。

线程状态的源代码如下：

```java
public enum State {
    /**
     * 新建状态，线程被创建出来，但尚未启动时的线程状态
     */
    NEW,

    /**
     * 就绪状态，表示可以运行的线程状态，但它在排队等待来自操作系统的 CPU 资源
     */
    RUNNABLE,

    /**
     * 阻塞等待锁的线程状态，表示正在处于阻塞状态的线程
     * 正在等待监视器锁，比如等待执行 synchronized 代码块或者
     * 使用 synchronized 标记的方法
     */
    BLOCKED,

    /**
     * 等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作。
     * 例如，一个线程调用了 Object.wait() 它在等待另一个线程调用
     * Object.notify() 或 Object.notifyAll()
     */
    WAITING,

    /**
     * 计时等待状态，和等待状态 (WAITING) 类似，只是多了超时时间，比如
     * 调用了有超时时间设置的方法 Object.wait(long timeout) 和 
     * Thread.join(long timeout) 就会进入此状态
     */
    TIMED_WAITING,

    /**
     * 终止状态，表示线程已经执行完成
     */
}
```

**BLOCKED 和 WAITING 的区别**

BLOCKED 可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而 WAITING 则是因为自身调用了 `Object.wait() `或着是 `Thread.join()` 又或者是 `LockSupport.park() `而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 `Object.wait()` 而进入 WAITING 状态之后，则需要等待另一个线程执行 `Object.notify() `或 `Object.notifyAll()` 才能被唤醒。

**start() 和 run() 的区别**

首先从 Thread 源码来看，start() 方法属于` Thread` 自身的方法，并且使用了 `synchronized` 来保证线程安全，源码如下：

```java
public synchronized void start() {
    // 状态验证，不等于 NEW 的状态会抛出异常
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    // 通知线程组，此线程即将启动

    group.add(this);
    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            // 不处理任何异常，如果 start0 抛出异常，则它将被传递到调用堆栈上
        }
    }
}
```

run() 方法为 Runnable 的抽象方法，必须由调用类重写此方法，重写的 `run()` 方法其实就是此线程要执行的业务方法，源码如下：

```java
public class Thread implements Runnable {
 // 忽略其他方法......
  private Runnable target;
  @Override
  public void run() {
      if (target != null) {
          target.run();
      }
  }
}
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```

从执行的效果来说，start() 方法可以开启多线程，让线程从 NEW 状态转换成 RUNNABLE 状态，而 run() 方法只是一个普通的方法。

其次，它们可调用的次数不同，`start()` 方法不能被多次调用，否则会抛出 `java.lang.IllegalStateException`；而 run() 方法可以进行多次调用，因为它只是一个普通的方法而已

# 状态转换

**RUNNABLE 与 BLOCKED 的状态转换**

只有一种场景会触发这种转换，就是线程等待 `synchronized` 的隐式锁。`synchronized` 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。而当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。

**RUNNABLE 与 WAITING 的状态转换**

总体来说，有三种场景会触发这种转换。

第一种场景，获得 synchronized 隐式锁的线程，调用无参数的` Object.wait() `方法。

第二种场景，调用无参数的` Thread.join() `方法。其中的 join() 是一种线程同步方法，例如有一个线程对象 thread A，当调用` A.join()` 的时候，执行这条语句的线程会等待 thread A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 thread A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。

第三种场景，调用 `LockSupport.park()` 方法。其中的 LockSupport 对象，也许你有点陌生，其实 Java 并发包中的锁，都是基于它实现的。调用` LockSupport.park() `方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用` LockSupport.unpark(Thread thread) `可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。

**RUNNABLE 与 TIMED_WAITING 的状态转换**

有五种场景会触发这种转换：

1. 调用带超时参数的 `Thread.sleep(long millis) `方法；
2. 获得 synchronized 隐式锁的线程，调用带超时参数的 `Object.wait(long timeout)` 方法；
3. 调用带超时参数的` Thread.join(long millis) `方法；
4. 调用带超时参数的` LockSupport.parkNanos(Object blocker, long deadline)` 方法；
5. 调用带超时参数的` LockSupport.parkUntil(long deadline) `方法。

**从 NEW 到 RUNNABLE 状态**

Java 刚创建出来的 Thread 对象就是 NEW 状态，而创建 Thread 对象主要有两种方法。一种是继承 Thread 对象，重写 run() 方法。

另一种是实现 Runnable 接口，重写 `run()` 方法，并将该实现类作为创建 Thread 对象的参数。

NEW 状态的线程，不会被操作系统调度，因此不会执行。Java 线程要执行，就必须转换到 RUNNABLE 状态。从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 `start() `方法就可以了

**从 RUNNABLE 到 TERMINATED 状态**

线程执行完 run() 方法后，会自动转换到 TERMINATED 状态，当然如果执行 run() 方法的时候异常抛出，也会导致线程终止。有时候我们需要强制中断 run() 方法的执行，例如 run() 方法访问一个很慢的网络，我们等不下去了，想终止怎么办呢？Java 的 Thread 类里面倒是有个 stop() 方法，不过已经标记为 @Deprecated，所以不建议使用了。正确的姿势其实是调用` interrupt() `方法。

**stop() 和 interrupt() 方法的主要区别是什么**

stop() 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 ReentrantLock 锁，被 stop() 的线程并不会自动调用 ReentrantLock 的 unlock() 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有` suspend() `和 `resume() `方法，这两个方法同样也都不建议使用了

而 interrupt() 方法就温柔多了，interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被 interrupt 的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。

当线程 A 处于 WAITING、`TIMED_WAITING` 状态时，如果其他线程调用线程 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。上面我们提到转换到 WAITING、`TIMED_WAITING` 状态的触发条件，都是调用了类似 wait()、join()、sleep() 这样的方法，我们看这些方法的签名，发现都会 `throws InterruptedException` 这个异常。这个异常的触发条件就是：其他线程调用了该线程的 `interrupt()` 方法。

上面情况属于被中断的线程通过异常的方式获得了通知。还有一种是主动检测，如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，例如中断计算圆周率的线程 A，这时就得依赖线程 A 主动检测中断状态了。如果其他线程调用线程 A 的` interrupt()` 方法，那么线程 A 可以通过 `isInterrupted()` 方法，检测是不是自己被中断了。

# 线程优先级

在 Thread 源码中和线程优先级相关的属性有 3 个：

```java
// 线程可以拥有的最小优先级
public final static int MIN_PRIORITY = 1;

// 线程默认优先级
public final static int NORM_PRIORITY = 5;

// 线程可以拥有的最大优先级
public final static int MAX_PRIORITY = 10
```

线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。

在程序中我们可以通过` Thread.setPriority()` 来设置优先级

# 常用方法

**join()**

在一个线程中调用 `other.join()` ，这时候当前线程会让出执行权给 other 线程，直到 other 线程执行完或者过了超时时间之后再继续执行当前线程，join() 源码如下：

```java
public final synchronized void join(long millis)
throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;
    // 超时时间不能小于 0
    if (millis < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }
    // 等于 0 表示无限等待，直到线程执行完为之
    if (millis == 0) {
        // 判断子线程 (其他线程) 为活跃线程，则一直等待
        while (isAlive()) {
            wait(0);
        }
    } else {
        // 循环判断
        while (isAlive()) {
            long delay = millis - now;
            if (delay <= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
```

从源码中可以看出 join() 方法底层还是通过 `wait() `方法来实现的。

**yield()**

看 Thread 的源码可以知道 yield() 为本地方法，也就是说 yield() 是由 C 或 C++ 实现的，源码如下：

```java
public static native void yield();
```

yield() 方法表示给线程调度器一个当前线程愿意出让 CPU 使用权的暗示，但是线程调度器可能会忽略这个暗示

比如我们执行这段包含了` yield() `方法的代码，如下所示：

```java
public static void main(String[] args) throws InterruptedException {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                System.out.println("线程：" +
                        Thread.currentThread().getName() + " I：" + i);
                if (i == 5) {
                    Thread.yield();
                }
            }
        }
    };
    Thread t1 = new Thread(runnable, "T1");
    Thread t2 = new Thread(runnable, "T2");
    t1.start();
    t2.start();
}
```

当我们把这段代码执行多次之后会发现，每次执行的结果都不相同，这是因为 `yield() `执行非常不稳定，线程调度器不一定会采纳 yield() 出让 CPU 使用权的建议，从而导致了这样的结果

