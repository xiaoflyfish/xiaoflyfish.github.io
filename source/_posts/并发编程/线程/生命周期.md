---
title: 生命周期
categories: 
- 并发编程
- 线程
---

Java语言中线程共有六种状态，分别是：

1. NEW（初始化状态）
2. RUNNABLE（可运行 / 运行状态）
3. BLOCKED（阻塞状态）
4. WAITING（无时限等待）
5. TIMED_WAITING（有时限等待）
6. TERMINATED（终止状态）

**RUNNABLE 与 BLOCKED 的状态转换**

只有一种场景会触发这种转换，就是线程等待 synchronized 的隐式锁。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换到 BLOCKED 状态。而当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换到 RUNNABLE 状态。

**RUNNABLE 与 WAITING 的状态转换**

总体来说，有三种场景会触发这种转换。

第一种场景，获得 synchronized 隐式锁的线程，调用无参数的` Object.wait() `方法。

第二种场景，调用无参数的` Thread.join() `方法。其中的 join() 是一种线程同步方法，例如有一个线程对象 thread A，当调用` A.join()` 的时候，执行这条语句的线程会等待 thread A 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 thread A 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。

第三种场景，调用 `LockSupport.park()` 方法。其中的 LockSupport 对象，也许你有点陌生，其实 Java 并发包中的锁，都是基于它实现的。调用` LockSupport.park() `方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用` LockSupport.unpark(Thread thread) `可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。

**RUNNABLE 与 TIMED_WAITING 的状态转换**

有五种场景会触发这种转换：

1. 调用带超时参数的 `Thread.sleep(long millis) `方法；
2. 获得 synchronized 隐式锁的线程，调用带超时参数的 `Object.wait(long timeout)` 方法；
3. 调用带超时参数的` Thread.join(long millis) `方法；
4. 调用带超时参数的` LockSupport.parkNanos(Object blocker, long deadline)` 方法；
5. 调用带超时参数的` LockSupport.parkUntil(long deadline) `方法。

**从 NEW 到 RUNNABLE 状态**

Java 刚创建出来的 Thread 对象就是 NEW 状态，而创建 Thread 对象主要有两种方法。一种是继承 Thread 对象，重写 run() 方法。

另一种是实现 Runnable 接口，重写 run() 方法，并将该实现类作为创建 Thread 对象的参数。

NEW 状态的线程，不会被操作系统调度，因此不会执行。Java 线程要执行，就必须转换到 RUNNABLE 状态。从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 start() 方法就可以了

**从 RUNNABLE 到 TERMINATED 状态**

线程执行完 run() 方法后，会自动转换到 TERMINATED 状态，当然如果执行 run() 方法的时候异常抛出，也会导致线程终止。有时候我们需要强制中断 run() 方法的执行，例如 run() 方法访问一个很慢的网络，我们等不下去了，想终止怎么办呢？Java 的 Thread 类里面倒是有个 stop() 方法，不过已经标记为 @Deprecated，所以不建议使用了。正确的姿势其实是调用 interrupt() 方法。