---
title: 线程池
categories: 
- 并发编程
---

BlockingQueue，是java.util.concurrent 包提供的用于解决并发生产者 - 消费者问题的最有用的类

当阻塞队列是空的时候，从队列中获取元素的操作将会被阻塞；当队列满时，往队列中添加元素的操作将会被阻塞

**常见的阻塞队列**

* ArrayBlockingQueue：由数组结构组成的有界阻塞队列

- LinkedBlockingQueue：由链表结构组成的有界阻塞（默认大小`Integer.MAX_VALUE()`）队列
- PriorityBlockingQueue：支持优先级排序的无界阻塞队列
- DelayQueue：使用优先队列实现延迟无界阻塞队列
- SynchronizedQueue：不存储元素的阻塞队列，也即单个元素的队列

# ArrayBlockingQueue

队列基于数组实现,容量大小在创建ArrayBlockingQueue对象时已定义好

应用场景：在线程池中有比较多的应用，生产者消费者场景

工作原理：基于ReentrantLock保证线程安全，根据Condition实现队列满时的阻塞

# LinkedBlockingQueue

是一个基于链表的无界队列

blockingQueue 的容量将设置为 `Integer.MAX_VALUE`

使用无限 BlockingQueue 设计生产者 - 消费者模型时最重要的是 **消费者应该能够像生产者向队列添加消息一样快地消费消息** 。否则，内存可能会填满，然后就会得到一个 OutOfMemory 异常。

# DelayQueue

由优先级堆支持的、基于时间的调度队列，内部基于无界队列PriorityQueue实现

入队的对象必须要实现Delayed接口,而Delayed集成自Comparable接口

**应用场景：**电影票

工作原理：队列内部会根据时间优先级进行排序。延迟类线程池周期执行。

# SynchronizedQueue

与其它BlockingQueue不同，SynchronizedQueue是一个不存储元素的BlockingQueue，每一个put操作必须等待一个take操作，否则就不能继续添加元素，反之亦然。总之，**SynchronizedQueue，生产一个，消费一个**