---
title: CAS
categories: 
- 并发编程
---

CAS 全称是 compare and swap(比较并且交换)，是一种用于在多线程环境下实现同步功能的机制，其也是无锁优化，或者叫自旋，还有自适应自旋。

在jdk中，`CAS`加`volatile`关键字作为实现并发包的基石。没有CAS就不会有并发包，`java.util.concurrent`中借助了CAS指令实现了一种区别于synchronized的一种乐观锁

在不使用锁的情况下保证线程安全，CAS实现机制中有重要的三个操作数：

- 需要读写的内存位置(V)
- 预期原值(A)
- 新值(B)

首先先读取需要读写的内存位置(V)，然后比较需要读写的内存位置(V)和预期原值(A)，如果内存位置与预期原值的A相匹配，那么将内存位置的值更新为新值B。如果内存位置与预期原值的值不匹配，那么处理器不会做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值

**基本原理**

JAVA实现CAS的原理，`unsafe::compareAndSwapInt`是借助C来调用CPU底层指令实现的

**缺点**

> ABA问题

解决方法

- AtomicStampedReference：带有时间戳的对象引用来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

```java
public boolean compareAndSet(
            V      expectedReference,//预期引用
            V      newReference,//更新后的引用
           int    expectedStamp, //预期标志
           int    newStamp //更新后的标志

)
```

- version：在变量前面加上版本号，每次变量更新的时候变量的版本号都+1，即A->B->A就变成了1A->2B->3A

> 循环时间长开销大

自旋CAS（不成功，就一直循环执行，直到成功）如果长时间不成功，会给CPU带来极大的执行开销。

解决方法：

- 限制自旋次数，防止进入死循环

> 只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性

解决方法：

- 如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，
- 可以把多个共享变量合并成一个共享变量进行CAS操作。