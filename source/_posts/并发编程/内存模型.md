---
title: 内存模型
categories: 
- 并发编程
---

每个线程创建时都会为其创建一个工作内存，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问

线程对变量的操作必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，工作内存中存储着主内存中的变量副本拷贝

工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信必须通过主内存来完成。

**Happens Before原则**

从JDK5开始，Java使用新的JSR-133内存模型，提供了happens-before原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据

JMM为程序中的所有操作定义了一定的规则，叫做Happens-Before。无论两个操作是否在同一个线程，如果要想保证操作A能看到操作B的结果，那么A、B之间一定要满足Happens-Before关系。如果两者间不满足Hapen-Before关系，JVM可以对其任意重排序。

**内容如下**

1. 程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。
2. 锁规则，解锁操作必然发生在后续的同一个锁的加锁之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。
3. volatile规则，volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。
4. 线程启动规则，线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见
5. 传递性，A先于B ，B先于C 那么A必然先于C
6. 线程终止规则，线程的所有操作先于线程的终结，`Thread.join()`方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。
7. 线程中断规则，对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过`Thread.interrupted()`方法检测线程是否中断。
8. 对象终结规则，对象的构造函数执行，结束先于finalize()方法