---
title: MESI缓存一致性协议
categories: 
- 并发编程
---

CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题

这个CPU缓存即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。

由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率

**常见的为三级缓存结构**

- 一级Cache(L1 Cache)
- 二级Cache(L2 Cache)
- 三级Cache(L3 Cache)

**缓存一致性问题**

多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致,不让系统数据混乱。

> 以多核CPU为例

比如同时有 2 个线程执行这段代码， 假如初始时 i 的值为 0， 那么我们希望两个线程执行完之后 i 的值变为 2。 但是事实会是这样吗？

可能存在下面一种情况： 初始时， 两个线程分别读取 i 的值存入各自所在的CPU 的高速缓存当中， 然后线程 1 进行加 1 操作， 然后把 i 的最新值 1 写入到内存。 此时线程 2 的高速缓存当中 i 的值还是 0， 进行加 1 操作之后， i 的值为1， 然后线程 2 把 i 的值写入内存。

最终结果 i 的值是 1， 而不是 2。 这就是著名的缓存一致性问题。 通常称这种被多个线程访问的变量为共享变量。

也就是说， 如果一个变量在多个 CPU 中都存在缓存 ， 那么就可能存在缓存不一致的问题

**如何解决缓存一致性的问题**

通常来说有以下 2 种解决方法：

1. 通过在总线加 LOCK#锁的方式
2. 通过缓存一致性协议

**通过在总线加 LOCK#锁的方式**

在早期的 CPU 当中， 是通过在总线上加 LOCK#锁的形式来解决缓存不一致的问题。 因为 CPU 和其他部件进行通信都是通过总线来进行的， 如果对总线加 LOCK#锁的话， 也就是说阻塞了其他 CPU 对其他部件访问（如内存） ，从而使得只能有一个 CPU 能使用这个变量的内存。

比如上面例子中 如果一个线程在执行 i = i +1， 如果在执行这段代码的过程中， 在总线上发出了 LCOK#锁的信号， 那么只有等待这段代码完全执行完毕之后， 其他 CPU 才能从变量 i所在的内存读取变量， 然后进行相应的操作。 这样就解决了缓存不一致的问题。但是上面的方式会有一个问题， 由于在锁住总线期间， 其他 CPU 无法访问内存， 导致效率下。

但是上面的方式会有一个问题， 由于在锁住总线期间， 其他 CPU 无法访问内存， 导致效率低下。

**MESI缓存一致性协议**

该协议保证了每个缓存中使用的共享变量的副本是一致的。

它核心的思想是： 当 CPU 向内存写入数据时， 如果发现操作的变量是共享变量， 即在其他 CPU 中也存在该变量的副本， 会发出信号通知其他 CPU 将该变量的缓存行置为无效状态， 因此当其他 CPU 需要读取这个变量时， 发现自己缓存中缓存该变量的缓存行是无效的， 那么它就会从内存重新读取。

MESI 是指4个状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：

![img](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201210164259.png)