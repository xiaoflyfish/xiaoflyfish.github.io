---
title: 基本介绍
categories: 
- 并发编程
- 线程池
---

**线程池优势**

线程池最主要的工作在于控制运行线程的数量，从而做到线程复用、控制最大并发数量、管理线程。

其具体的优势在于：

- 降低资源消耗：通过重复利用已经创建的线程降低线程创建和销毁造成的消耗；
- 提高响应速度：当任务到达时，任务可以不需要等到线程创建就能执行；
- 提高线程的可管理性：线程是稀缺资源，不能无限创建，否则会消耗系统资源、降低系统的稳定性，使用线程可以进行统一分配，调优和监控；

**线程池的注意事项**

1.并发错误。 多线程应用要特别注意并发错误， 要从逻辑上保证程序的正确性， 注意避免死锁现象的发生。

2.线程泄漏。 这是线程池应用中一个严重的问题， 当任务执行完毕而线程没能返回池中就会发生线程泄漏现象。

**线程状态**

- RUNNING 自然是运行状态，指可以接受任务执行队列里的任务
- SHUTDOWN 指调用了` shutdown() `方法，不再接受新任务了，但是队列里的任务得执行完毕
- STOP 指调用了 `shutdownNow() `方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务
- TIDYING 所有任务都执行完毕，在调用 `shutdown()/shutdownNow()` 中都会尝试更新为这个状态
- TERMINATED 终止状态，当执行 `terminated()` 后会更新为这个状态

**业务中实践**

1.快速响应用户请求

比如：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户

2.快速处理批量任务

比如：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表

**关闭线程池**

`shutdown()`:执行后停止接受新任务，会把队列的任务执行完毕

`shutdownNow()`: 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop，两个方法都会中断线程，用户可自行判断是否需要响应中断

通常是按照以下方式关闭线程池的：

```java
long start = System.currentTimeMillis();
for (int i = 0; i <= 5; i++) {
    pool.execute(new Job());
}
pool.shutdown();
while (!pool.awaitTermination(1, TimeUnit.SECONDS)) {
    LOGGER.info("线程还在执行。。。");
}
long end = System.currentTimeMillis();
LOGGER.info("一共处理了{}", (end - start));
```

`pool.awaitTermination(1, TimeUnit.SECONDS)` 会每隔一秒钟检查一次是否执行完毕（状态为 TERMINATED），当从 while 循环退出时就表明线程池已经完全终止了 

**配置合理线程数量**

线程池合理配置线程数量需要考虑业务具体是CPU密集型还是IO密集型：

- CPU密集型：该任务需要大量运算，而没有阻塞，CPU一直在全速运行，CPU密集型只有在真正的多核CPU上才能进行加速。CPU密集型任务配置应该尽可能少的线程数量，一般公式为：

`CPU核数 + 1个线程的线程池`

- IO密集型：任务需要大量的IO操作，即大量的阻塞。在单线程上进行IO密集型的任务会浪费大量的CPU运算能力在等待操作上。所以在IO密集型任务中使用多线程可以大大加速程序运行：

`CPU核数 * 2`

Java并发编程实战的作者 Brain Goetz 推荐的计算方法：

> 线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）