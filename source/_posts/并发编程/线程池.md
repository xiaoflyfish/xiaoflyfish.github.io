---
title: 线程池
categories: 
- 并发编程
---

# 核心原理

```java
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler)
```

**默认情况下，在创建了线程池后，线程池中的线程数为0，当任务提交给线程池之后的处理策略如下：**

首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务

如果此时线程池中的数量小于 corePoolSize（核心池的大小），即使线程池中的线程都处于空闲状态， 也要创建新的线程来处理被添加的任务（也就是每来一个任务，就要创建一个线程来执行任务）

如果此时线程池中的数量大于等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列，则该任务会等待空闲线程将其取出去执行

如 果 此 时 线 程 池 中 的 数 量 大 于 等 于 corePoolSize，缓 冲 队 列workQueue 满， 并且线程池中的数量小于 maximumPoolSize（线程池最大线程数） ， 建新的线程来处理被添加的任务

如果 此时 线程 池中 的数量 大 于 等 于 corePoolSize， 缓 冲 队列workQueue 满， 并且线程池中的数量等于 maximumPoolSize， 那么通过RejectedExecutionHandler 所指定的策略(任务拒绝策略)来处理此任务

特别注意， 在 corePoolSize 和 maximumPoolSize 之间的线程数会被自动释放。 当线程池中线程数量大于 corePoolSize 时， 如果某线程空闲时间超过 keepAliveTime， 线程将被终止， 直至线程池中的线程数目不大于 corePoolSize， 这样， 线程池可以动态的调整池中的线程数

allowCoreThreadTimeout：允许核心线程超时

rejectedExecutionHandler：任务拒绝处理器

threadFactory：生成线程池中工作线程的线程工厂，一般使用默认即可

在Executor中，对线程的创建都是通过 ThreadFactory，禁止使用 new Thread 来创建

![](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201127161138.png)

![](https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201127161215.png)

**两种情况会拒绝处理任务：**

- 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务
- 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown，如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务

**拒绝策略**

线程池会调用rejectedExecutionHandler来处理这个任务，如果没有设置默认是AbortPolicy，会抛出异常

ThreadPoolExecutor类有几个内部实现类来处理这类情况：

- AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行
- CallerRunsPolicy：调用者运行的一种机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者
- DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入到队列中尝试再次提交当前任务
- DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常。如果任务允许丢失，那么该策略是最好的方案

实现RejectedExecutionHandler接口，可自定义处理器