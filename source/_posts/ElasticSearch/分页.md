---
title: 分页
categories: 
- ElasticSearch
---

ES提供了三种方式来解决分页和遍历的问题：from/size，scroll，search_after

**from/size:**

from：指明开始位置；

size：指明获取总数

```json
#使用from——size
GET my_index/_search
{
 "from":1,    #从第2个开始搜索
 "size":2     #获取2个长度
}
```

此时产生了一个经典的问题，也是分布式文件系统必定面对的问题：**深度分页**。

为了尽量避免深度分页为题，ES通过设定**index.max_result_window**限定最多到10000条数据。

**scroll:**

遍历文档集的API，以**快照**的方式来避免深度分页问题。

* 不能用来做实时搜索，因为数据不是实时的；

```json
#发起一个scroll search
GET my_index/_search?scroll=5m    #该快照的有效时间为5min
{
 "size"1    #指明每次scroll返回的文档数
}
```

会返回后续会用到的`scroll_id`

调用scroll search 的api，获取文档集合，不断迭代至返回hits数组为空时停止：

```json
POST _search/scroll
{
 "scroll":"5m",    #指明有效时间
 "scroll_id":"xxxxxx"    #上一步返回的_scroll_id
}
```

之后不断返回新的`scroll_id`，使用新的`scroll_id`进行查询，直到返回数组为空。

当不断的进行迭代，会产生很多scroll，导致大量内存被占用，可以通过clear api进行删除：

```json
#使用clear api对scroll进行删除
DELETE /_search/scroll
{
 "scroll_id":[
   "xxxxxx",    #_scroll_id
   "xxxxxx",    #_scroll_id
   ......
 ]
}
 
#删除所有的scroll
DELETE /_search/scroll/_all
```

**search_after:**

避免深度分页的性能问题，提供实时的下一页文档获取功能。

缺点：不能使用from参数，即：不能指定页数。且只能下一页，不能上一页

第一步：正常搜索，但是要指定sort值，并保证值唯一：

```json
#第一步，正常搜索
GET my_index/_search
{
 "size":1,
 "sort":{
  "age":"desc",
  "_id":"desc"
 }
}
```

第二步：使用上一步最后一个文档的sort值进行查询：

```json
#第二步，使用sort值进行查询
GET my_index/_search
{
 "size":1,
 "search_after":[28,"2"],    #28,"2"，是上一次搜索返回的sort值，分别对应age和id
 "sort":{
  "age":"desc",
  "_id":"desc"
 }
}
```

**如何避免深度分页问题**

这个问题目前连google都没能解决，所以只能最大程度避免

应用场景：

* from/size:需实时获取顶部的部分文档，且需自由翻页（实时）；

* scroll:需全部文档，如：导出所有数据的功能（非实时）；

* search_after:需全部文档，不需自由翻页（实时）。