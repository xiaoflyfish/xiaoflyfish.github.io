---
title: 变慢的Redis
categories: 
- 学习笔记
- Redis1
---

**查看 Redis 的响应延迟:**

- 大部分时候，Redis 延迟很低，但是在某些时刻，有些 Redis 实例会出现很高的响应延迟，甚至能达到几秒到十几秒，不过持续时间不长
- 当你发现 Redis 命令的执行时间突然就增长到了几秒，基本就可以认定 Redis 变慢了。

基于当前环境下的 Redis 基线性能:

- 基线性能: 一个系统在低压力、无干扰下的基本性能，这个性能只由当前的软硬件配置决定

怎么确定基线性能:

实际上，从 2.8.7 版本开始，redis-cli 命令提供了`–intrinsic-latency` 选项，可以用来监测和统计测试期间内的最大延迟，这个延迟可以作为 Redis 的基线性能。其中，测试时长可以用`–intrinsic-latency` 选项的参数来指定。

> 例子:

该命令会打印 120 秒内监测到的最大延迟。可以看到，这里的最大延迟是 119 微秒，也就是基线性能为 119 微秒。一般情况下，运行 120 秒就足够监测到最大延迟了，所以，我们可以把参数设置为 120。

```
./redis-cli --intrinsic-latency 120
Max latency so far: 17 microseconds.
Max latency so far: 44 microseconds.
Max latency so far: 94 microseconds.
Max latency so far: 110 microseconds.
Max latency so far: 119 microseconds.

36481658 total runs (avg latency: 3.2893 microseconds / 3289.32 nanoseconds per run).
Worst run took 36x longer than the average latency.
```

一般来说，你要把运行时延迟和基线性能进行对比，**如果你观察到的 Redis 运行时延迟是其基线性能的 2 倍及以上，就可以认定 Redis 变慢了。**

如果你想了解网络对 Redis 性能的影响，一个简单的方法是用 iPerf 这样的工具，测量从 Redis 客户端到服务器端的网络延迟。如果这个延迟有几十毫秒甚至是几百毫秒，就说明，Redis 运行的网络环境中很可能有大流量的其他应用程序在运行，导致网络拥塞了。这个时候，你就需要协调网络运维，调整网络的流量分配了

**慢查询命令**

Redis 的不同命令的复杂度:

- [redis commands](https://redis.io/commands/)

如果的确有大量的慢查询命令，有两种处理方式：

- 用其他高效命令代替
- 当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。

还有一个比较容易忽略的慢查询命令，就是 **KEYS**。

它用于返回和输入模式匹配的所有 key，例如，以下命令返回所有包含“name”字符串的 keys。

**过期 key 操作**

过期 key 的自动删除机制，它是 Redis 用来回收内存空间的常用机制，应用广泛，本身就**会引起 Redis 操作阻塞，导致性能变慢**，所以，你必须要知道该机制对性能的影响。

默认情况下，Redis 每 100 毫秒会删除一些过期 key，具体的算法如下：

- 采样 `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` 个数的 key，并将其中过期的 key 全部删除；
- 如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。

> 算法的第二条是怎么被触发的呢

其中一个重要来源，就是频繁使用带有相同时间参数的 EXPIREAT 命令设置过期 key，这就会导致，在同一秒内有大量的 key 同时过期

正常情况下，一秒内基本有 200 个过期 key 会被删除，并不会对 Redis 造成太大影响，但是如果触发第二条，Redis就会一直删除以释放空间。

删除操作是阻塞的(Redis 4.0 后可以用异步线程机制来减少阻塞影响)，一旦该条件触发，Redis 的线程就会一直执行删除，这样一来，就没办法正常服务其他的键值操作，就会进一步引起其他键值操作的延迟增加，Redis 就会变慢。

可以在过期时间参数上，加上一定大小范围内的随机数，这样，既保证 key 在一个邻近时间范围内被删除，又避免了同时过期造成的压力

**文件系统：AOF 模式**

AOF 日志提供了三种日志写回策略：no、everysec、always

- 这三种写回策略依赖文件系统的两个系统调用完成，也就是 write 和 fsync。
- write 只要把日志记录写到内核缓冲区，就可以返回了，并不需要等待日志实际写回到磁盘；而 fsync 需要把日志记录写回到磁盘后才能返回，时间较长。

**三种 写回策略所执行的系统调用**

everysec ：Redis 允许丢失一秒的操作记录。Redis 主线程并不需要确保每个操作记录日志都写回磁盘。

当写回策略配置为 everysec 时，Redis 会使用后台的子线程异步完成 fsync 的操作。

always ：Redis 需要确保每个操作记录日志都写回磁盘，always 策略使用主线程来执行fsync操作

Redis使用子进程来进行AOF重写，重写贵对磁盘进行大量IO操作，fsync又要求等到数据写到磁盘后才能返回，所以AOF重写压力比较大的时候，会导致fsync阻塞

虽然fsync是由后台子线程负责执行的，但主线程会监控fsync的执行进度

- 当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞。
- 如果后台子线程执行的 fsync 频繁阻塞的话(比如 AOF 重写占用了大量的磁盘 IO 带宽)，主线程也会阻塞，导致 Redis 性能变慢

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210225230953.png" style="zoom:13%;" />

由于 fsync 后台子线程和 AOF 重写子进程的存在，主 IO 线程一般不会被阻塞。但是，如果在重写日志时，AOF 重写子进程的写入量比较大， fsync 线程也会被阻塞，进而阻塞主线程，导致延迟增加。

**解决方案**

如果 AOF 写回策略使用了 everysec 或 always 配置，请先确认下业务方对数据可靠性的 要求，明确是否需要每一秒或每一个操作都记日志。

如果业务应用对延迟非常敏感，但同时允许一定量的数据丢失，那么，可以把配置项 no- appendfsync-on-rewrite 设置为 yes

这个配置项设置为 yes 时，表示在 AOF 重写时，不进行 fsync 操作。也就是说，Redis 实 例把写命令写到内存后，不调用后台线程进行 fsync 操作，就可以直接返回了。当然，如 果此时实例发生宕机，就会导致数据丢失。反之，如果这个配置项设置为 no(也是默认配 置)，在 AOF 重写时，Redis 实例仍然会调用后台线程进行 fsync 操作，这就会给实例带 来阻塞。

如果的确需要高性能，同时也需要高可靠数据保证，我建议你考虑采用高速的固态硬盘作 为 AOF 日志的写入设备。

**操作系统：swap**

Redis 是内存数据库，内存使用量大，如果没有控制好内存的使用量，或者和其他内存需求大的应用一起运行了，操作系统会启动 swap 机制，而导致性能变慢

内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写，所以，一旦触发 swap，无论是被换入数据的进程，还是被换出数据的进程，其性能都会受到慢速磁盘读写的影响。

这一点对于 Redis 内存数据库而言，显得更为重要：正常情况下，Redis 的操作是直接通过访问内存就能完成，一旦 swap 被触发了，Redis 的请求操作需要等到磁盘数据读写完成才行。而且，和我刚才说的 AOF 日志文件读写使用 fsync 线程不同，**swap 触发后影响的是 Redis 主 IO 线程**，这会极大地增加 Redis 的响应时间。

针对这个问题，我也给你提供一个解决思路：**增加机器的内存或者使用 Redis 集群**。

操作系统本身会在后台记录每个进程的 swap 使用情况，即有多少数据量发生了 swap。

你可以先通过下面的命令查看 Redis 的进程号，这里是 5332。

```
$ redis-cli info | grep process_id
process_id: 5332
```

然后，进入 Redis 所在机器的 /proc 目录下的该进程目录中：

```
$ cd /proc/5332
```

最后，运行下面的命令，查看该 Redis 进程的使用情况。在这儿，我只截取了部分结果：

```
$cat smaps | egrep '^(Swap|Size)'
Size: 584 kB
Swap: 0 kB
Size: 4 kB
Swap: 4 kB
Size: 4 kB
Swap: 0 kB
Size: 462044 kB
Swap: 462008 kB
Size: 21392 kB
Swap: 0 kB
```

当出现百 MB，甚至 GB 级别的 swap 大小时，就表明，此时，Redis 实例的内存压力很大，很有可能会变慢

所以，swap 的大小是排查 Redis 性能变慢是否由 swap 引起的重要指标

**操作系统：内存大页**

内存大页机制(Transparent Huge Page, THP)，也会影响 Redis 性能。

Linux 内核从 2.6.38 开始支持内存大页机制，该机制支持 2MB 大小的内存页分配，而常规的内存页分配是按 4KB 的粒度来执行的

Redis 使用内存大页就是一个典型的例子

虽然内存大页可以给 Redis 内存减少分配次数，但是Redis 为了提供数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，Redis 就会采用写时复制机制，也就是说，一旦有数据要被修 改，Redis 并不会直接修改内存中的数据，而是将这些数据拷贝一份，然后再进行修改。

如果采用了内存大页，那么客户端请求只修改 100B 的数据，Redis 也需要拷贝 2MB 的大页。

内存大页机制将导致大量的拷贝，这就会影响 Redis 正常的访存操作，最终导致性能变慢。

首先，我们要先排查下内存大页。方法是：在 Redis 实例运行的机器上执行如下命令:

```
cat /sys/kernel/mm/transparent_hugepage/enabled
```

- always：内存大页机制被启动
- never ： 内存大页机制被禁止