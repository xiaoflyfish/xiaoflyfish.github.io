---
title: 缓冲区
categories: 
- 学习笔记
- Redis1
---

如果往里面写入数据的速度持续地大于从里面读取数据的速度，就会导致缓冲区需要越来越多的内存来暂存数据

当缓冲区占用的内存超出了设定的上限阈值时，就会出现缓冲区溢出。

- 缓冲区是用来避免请求或数据丢失的惨案的，但也只有用对了，才能真正起到“避免”的作用。

缓冲区的使用场景:

- 在客户端和服务器端之间进行通信时，用来暂存客户端发送的命令数据，或者是服务器端返回给客户端的数据结果
- 在主从节点间进行数据同步时，用来暂存主节点接收的写命令和数据。

**客户端输入和输出缓冲区**

为了避免客户端和服务器端的请求发送和处理速度不匹配，服务器端给每个连接的客户端都设置了一个输入缓冲区和输出缓冲区，我们称之为客户端输入缓冲区和输出缓冲区

- 输入缓冲区会先把客户端发送过来的命令暂存起来，Redis 主线程再从输入缓冲区中读取命令，进行处理。
- 当 Redis 主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210226143704.png" style="zoom:23%;" />

**如何应对输入缓冲区溢出**

可能导致溢出的情况主要是下面两种：

- 写入了 bigkey，比如一下子写入了多个百万级别的集合类型数据；
- 服务器端处理请求的速度过慢，例如，Redis 主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多。

查看输入缓冲区的内存使用情况:

```
CLIENT LIST
id=5 addr=127.0.0.1:50487 fd=9 name= age=4 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client
```

- cmd，表示客户端最新执行的命令。这个例子中执行的是 CLIENT 命令。
- qbuf，表示输入缓冲区已经使用的大小。这个例子中的 CLIENT 命令已使用了 26 字节大小的缓冲区。
- qbuf-free，表示输入缓冲区尚未使用的大小。这个例子中的 CLIENT 命令还可以使用 32742 字节的缓冲区。qbuf 和 qbuf-free 的总和就是Redis 服务器端当前为已连接的这个客户端分配的缓冲区总大小。这个例子中总共分配了 26 + 32742 = 32768 字节，也就是 32KB 的缓冲区。

redis 为了防止发生溢出, 会把客户端连接关闭，结果就是业务程序无法进行数据存取了。

通常情况下，Redis 服务器端不止服务一个客户端，当多个客户端连接占用的内存总量，超过了 Redis 的 maxmemory 配置项时（例如 4GB），就会触发 Redis 进行**数据淘汰**。一旦数据被淘汰出 Redis，再要访问这部分数据，就需要去后端数据库读取，这就降低了业务应用的访问性能。此外，更糟糕的是，如果使用多个客户端，导致 Redis 内存占用过大，也会导致内存溢出（out-of-memory）问题，进而会引起 Redis 崩溃，给业务应用造成严重影响。

Redis 的客户端输入缓冲区大小的上限阈值，默认1GB。也就是说，Redis 服务器端允许为每个客户端最多暂存 1GB 的命令和数据。1GB 的大小，对于一般的生产环境已经是比较合适的了。一方面，这个大小对于处理绝大部分客户端的请求已经够用了；另一方面，如果再大的话，Redis 就有可能因为客户端占用了过多的内存资源而崩溃

**如何应对输出缓冲区溢出**

Redis 为每个客户端设置的输出缓冲区也包括两部分:

- 一个大小为 16KB 的固定缓冲空间，用来暂存 OK 响应和出错信息；
- 一个可以动态增加的缓冲空间，用来暂存大小可变的响应结果。

发生输出缓冲区溢出的情况:

- 服务器端返回 bigkey 的大量结果；
- 执行了 MONITOR 命令；
- 缓冲区大小设置得不合理。

MONITOR 命令是用来监测 Redis 执行的。执行这个命令之后，就会持续输出监测到的各个命令操作，如下所示：

```
MONITOR
OK
1600617456.437129 [0 127.0.0.1:50487] "COMMAND"
1600617477.289667 [0 127.0.0.1:50487] "info" "memory"
```

MONITOR 的输出结果会持续占用输出缓冲区，并越占越多，最后的结果就是发生溢出

所以，我要给你一个小建议：MONITOR 命令主要用在调试环境中，不要在线上生产环境中持续使用 MONITOR。当然，如果在线上环境中偶尔使用 MONITOR 检查 Redis 的命令执行情况，是没问题的。

可以通过 `client-output-buffer-limit` 配置项，来设置缓冲区的大小。具体设置的内容包括两方面：

- 设置缓冲区大小的上限阈值；
- 设置输出缓冲区持续写入数据的**数量上限阈值**，和持续写入数据的**时间的上限阈值**。

客户端的类型:

- 常规和 Redis 服务器端进行读写命令交互的普通客户端
- 订阅了 Redis 频道的订阅客户端
- 在 Redis 主从集群中，主节点上也有一类客户端（从节点客户端）用来和从节点进行数据同步

当我们给普通客户端设置缓冲区大小时，通常可以在 Redis 配置文件中进行这样的设置：

```
client-output-buffer-limit normal 0 0 0
```

normal: 普通客户端, 通常不限制

- 第 1 个 0 设置的是缓冲区大小限制

- 第 2 个 0 缓冲区持续写入量限制

- 第 3 个 0 持续写入时间限制

订阅客户端设置:

```
client-output-buffer-limit pubsub 8mb 2mb 60
```

pubsub: 对订阅客户端进行设置

- 如果连续 60 秒内对输出缓冲区的写入量超过 2MB 的话，服务器端也会关闭客户端连接。

- 8mb 表示输出缓冲区的大小上限 为 8MB，一旦实际占用的缓冲区大小要超过 8MB，服务器端就会直接关闭客户端的连接;

**主从集群中的缓冲区**

主从集群间的数据复制包括全量复制和增量复制两种。全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。无论在哪种形式的复制中，为了保证主从节点的数据一致，都会用到缓冲区

但是，这两种复制场景下的缓冲区，在溢出影响和大小设置方面并不一样。

> 复制缓冲区的溢出问题

在全量复制过程中，主节点在向从节点传输 RDB 文件的同时，会继续接收客户端发送的写命令请求。

这些写命令就会先保存在**复制缓冲区**中，等 RDB 文件传输完成后，再发送给从节点去执行。主节点上会**为每个从节点都维护一个复制缓冲区**，来保证主从节点间的数据同步

其实，**主节点上的复制缓冲区，本质上也是一个用于和从节点连接的客户端**（我们称之为从节点客户端），使用的输出缓冲区。复制缓冲区一旦发生溢出，主节点也会直接关闭和从节点进行复制操作的连接，导致全量复制失败

> 那如何避免复制缓冲区发生溢出呢

- 控制主节点保存的数据量大小。按通常的使用经验，我们会把主节点的数据量控制在 2~4GB，这样可以让全量同步执行得更快些，避免复制缓冲区累积过多命 令
- 使用` client-output-buffer-limit `配置项，来设置合理的复制缓冲区大小。设置的依据，就是主节点的数据量大小、主节点的写负载压力和主节点本身的内存大小

```
config set client-output-buffer-limit slave 512mb 128mb 60
```

slave: 该配置项是针对复制缓冲区的

- 如果连续 60 秒内的写入量超过 128MB 的话，也会触发缓冲区溢出。

关于复制缓冲区，我们还会遇到一个问题。**主节点上复制缓冲区的内存开销，会是每个从节点客户端输出缓冲区占用内存的总和**。

如果集群中的从节点数非常多的话，主节点的内存开销就会非常大。

所以，我们还必须得控制和主节点连接的从节点个数，**不要使用大规模的主从集群**。

**复制积压缓冲区的溢出问题**

主节点在把接收到的写命令同步给从节点时，同时会把这些写命令写入**复制积压缓冲区**。一旦从节点发生网络闪断，再次和主节点恢复连接后，从节点就会从复制积压缓冲区中，读取断连期间主节点接收到的写命令，进而进行增量同步

首先，复制积压缓冲区是一个大小有限的环形缓冲区。当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据。如果从节点还没有同步这些旧命令数据，就会造成主从节点间重新开始执行全量复制。

其次，为了应对复制积压缓冲区的溢出问题，我们可以调整复制积压缓冲区的大小，也就是设置 `repl_backlog_size` 这个参数的值