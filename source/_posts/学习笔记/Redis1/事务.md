---
title: 事务
categories: 
- 学习笔记
- Redis1
---

**事务的执行过程包含三个步骤**

1. 客户端要使用MULTI命令显式地表示一个事务的开启
2. 客户端把事务中本身要执行的具体操作（例如增删改数据）发送给服务器端。这些操作就是 Redis 本身提供的数据读写命令，例如 GET、SET 等。不过，这些命令虽然被客户端发送到了服务器端，但 Redis 实例只是把这些命令暂存到一个命令队列中，并不会立即执行。
3. 客户端向服务器端发送提交事务的命令，当服务器端收到 EXEC 命令后，才会实际执行命令队列中的所有命令

```
#开启事务
127.0.0.1:6379> MULTI
OK
#将a:stock减1，
127.0.0.1:6379> DECR a:stock
QUEUED
#将b:stock减1
127.0.0.1:6379> DECR b:stock
QUEUED
#实际执行事务
127.0.0.1:6379> EXEC
1) (integer) 4
2) (integer) 9
```

# 原子性

> 第一种情况

在执行 EXEC 命令前，客户端发送的操作命令本身就有错误（比如语法错误，使用了不存在的命令），在命令入队时就被 Redis 实例判断出来了。

对于这种情况，在命令入队时，Redis 就会报错并且记录下这个错误。此时，我们还能继续提交命令操作。等到执行了 EXEC 命令之后，Redis 就会**拒绝执行所有提交的命令操作**，返回事务失败的结果。这样一来，事务中的所有命令都不会再被执行了，**保证了原子性**。

> 第二种情况

事务操作入队时，命令和操作的数据类型不匹配，但 Redis 实例没有检查出错误

在执行完 EXEC 命令以后，Redis 实际执行这些事务操作时，就会报错。不过，需要注意的是，虽然 Redis 会对错误命令报错，但还是会把正确的命令执行完。在这种情况下，**事务的原子性就无法得到保证**了。

Redis 中并没有提供回滚机制。虽然 Redis 提供了 DISCARD 命令，但是，这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。

> 第三种情况

在执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败

在这种情况下，如果 Redis 开启了 AOF 日志，那么，只会有部分的事务操作被记录到 AOF 日志中。我们需要使用 `redis-check-aof` 工具检查 AOF 日志文件，这个工具可以把已完成的事务操作从 AOF 文件中去除。这样一来，我们**使用 AOF 恢复实例后，事务操作不会再被执行，从而保证了原子性**。

# 隔离性

事务的隔离性保证，会受到和事务一起执行的并发操作的影响。而事务执行又可以分成命令入队（EXEC 命令执行前）和命令实际执行（EXEC 命令执行后）两个阶段

**所以，我们就针对这两个阶段，分成两种情况来分析：**

> 一个事务的 EXEC 命令还没有执行时

事务的命令操作是暂存在命令队列中的。此时，如果有其它的并发操作，我们就需要看事务是否使用了 WATCH 机制。

WATCH 机制的作用是，在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏

> 并发操作在 EXEC 命令后执行，此时，隔离性可以保证

因为 Redis 是用单线程执行命令，而且，EXEC 命令执行后，Redis 会保证先把命令队列中的所有命令执行完。所以，在这种情况下，并发操作不会破坏事务的隔离性

