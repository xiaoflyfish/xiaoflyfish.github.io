---
title: 存储模型
categories: 
- 学习笔记
- MySQL1
---

**为什么不能直接更新磁盘上的数据**

磁盘随机读写的性能是最差的，所以直接更新磁盘文件，必然导致我们的数据库完全无法抗下任何一点点稍微高 并发一点的场景

通过这种方式保证，你每个更新请求，尽量就是更新内存，然后顺序写日志文件

更新内存的性能是极高的，然后顺序写磁盘上的日志文件的性能也是比较高的，因为顺序写磁盘文件，他的性能要远高于随机读写磁盘文件

**MySQL为什么要引入数据页这个概念**

我们每次都是把磁盘里的一条数据加载到内存里去进行更新，然后下次要更新别的数 据的时候，再从磁盘里加载另外一条数据到内存里去

这样每次都是一条数据一条数据的加载到内存里去更新，大家觉得效率高吗

很明显是不高的 所以innodb存储引擎在这里引入了一个数据页的概念，也就是把数据组织成一页一页的概念，每一页有16kb，然后每 次加载磁盘的数据到内存里的时候，是至少加载一页数据进去，甚至是多页数据进去

**一行数据在磁盘上是如何存储的**

行格式。我们可以对一个表指定他的行存储的格式是什么样的，比如我们这里用一个 COMPACT格式。

`CREATE TABLE table_name (columns) ROW_FORMAT=COMPACT `

`ALTER TABLE table_name ROW_FORMAT=COMPACT`

你可以在建表的时候，就指定一个行存储的格式，也可以后续修改行存储的格式。这里指定了一个COMPACT行存储 格式，在这种格式下，每一行数据他实际存储的时候，大概格式类似下面这样：

`变长字段的长度列表，null值列表，数据头，column01的值，column02的值，column0n的值......`

对于每一行数据，他其实存储的时候都会有一些头字段对这行数据进行一定的描述，然后再放上他这一行数据每一列 的具体的值，这就是所谓的行格式。除了COMPACT以外，还有其他几种行存储格式，基本都大同小异

# VARCHAR存储

**VARCHAR这种变长字段，在磁盘上到底是如何存储的**

平时你看到的表里的很多行数据，最终落地到磁盘里的时候，一大坨数据放在一个 磁盘文件里都挨着存储的

也就是说，你在存储“hello a a”这行数据的时候，要带上一些额外的附加信息，比如第一块就是他里面的变长字段 的长度列表

也就是说，这个hello是VARCHAR(10)类型的变长字段的值，那么这个“hello”字段值的长度到底是多少？ 

我们看到“hello”的长度是5，十六进制就是0x05，所以此时会在“hello a a”前面补充一些额外信息，首先就是变 长字段的长度列表，你会看到这行数据在磁盘文件里存储的时候，其实是类似如下的格式：0x05 null值列表 数据头 hello a a

你这行数据存储的时候应该是如上所示的！ 这个时候假设你有两行数据，还有一行数据可能就是：0x02 null值列表 数据头 hi a a，两行数据放在一起存储在磁盘 文件里，看起来是如下所示的： 

0x05 null值列表 数据头 hello a a 0x02 null值列表 数据头 hi a a

> 举个列子：

所以假设此时你要读取“hello a a”这行数据，你首先会知道这个表里的三个字段的类型是VARCHAR(10) CHAR(1) CHAR(1)，那么此时你先要读取第一个字段的值，那么第一个字段是变长的，到底他的实际长度是多少呢？

此时你会发现第一行数据的开头有一个变长字段的长度列表，里面会读取到一个0x05这个十六进制的数字，发现第一 个变长字段的长度是5，于是按照长度为5，读取出来第一个字段的值，就是“hello”

接着你知道后续两个字段都是CHAR(1)，长度都是固定的1个字符，于是此时就依次按照长度为1读取出来后续两个字 段的值，分别是“a”“a”，于是最终你会读取出来“hello a a”这一行数据！

接着假设你要读取第二行数据，你先看一下第二行数据后的变长字段长度列表，发现他第一个变长字段的长度是 0x02，于是就读取长度为2的字段值，就是“hi”，再读取两个长度固定为1的字符值，都是“a”，此时读取出来“hi a a”这行数据

> 如果有多个变长字段，如何存放他们的长度

比如一行数据有VARCHAR(10) VARCHAR(5) VARCHAR(20) CHAR(1) CHAR(1)，一共5个字段，其中三个是变长字 段，此时假设一行数据是这样的：hello hi hao a a

此时在磁盘中存储的，必须在他开头的变长字段长度列表中存储几个变长字段的长度，一定要注意一点，他这里是逆 序存储的！

也就是说先存放VARCHAR(20)这个字段的长度，然后存放VARCHAR(5)这个字段的长度，最后存放VARCHAR(10)这 个字段的长度。

现在hello hi hao三个字段的长度分别是0x05 0x02 0x03，但是实际存放在变长字段长度列表的时候，是逆序放的， 所以一行数据实际存储可能是下面这样的：

0x03 0x02 0x05 null值列表 头字段 hello hi hao a a

# NULL存储

**为什么一行数据里的NULL值不能直接存储**

假设这个字段的NULL值我们在磁盘上存储的时候，就是按照“NULL”这么个字符串来存储，是不是很浪费 存储空间

所以实际在磁盘上存储数据的时候，一行数据里的NULL值是肯定不会直接按照字符串的方式存放在磁盘上浪费空间 的

> NULL值是以二进制bit位来存储的

很简单，对所有的NULL值，不通过字符串在磁盘上存储，而是通过二进制的bit位来存储，一行数据里假设有多个字段 的值都是NULL，那么这多个字段的NULL，就会以bit位的形式存放在NULL值列表中

一行数据在磁盘上的存储格式应该是下面这样的：

变长字段长度列表 NULL值列表 头信息 column1=value1 column2=value2 ... columnN=valueN

这个NULL值列表是这样存放的，你所有允许值为NULL的字段，注意，是允许值为NULL，不 是说一定值就是NULL了，只要是允许你为NULL的字段，在这里每个字段都有一个二进制bit位的值，如果bit值是1说 明是NULL，如果bit值是0说明不是NULL

实际NULL值列表存放的时候，不会说仅仅是4个bit位，他一般起码是8个bit位的倍数，如果不足8个bit位 就高位补0，所以实际存放看起来是如下的： 0x09 0x04 00000101 头信息 column1=value1 column2=value2 ... columnN=valueN

# 数据头

每一行数据存储的时候，还得有40个bit位的数据头，这个数据头是用来描述这行数据的

这40个bit位里，第一个bit位和第二个bit位，都是预留位，是没任何含义的

然后接下来有一个bit位是`delete_mask`，他标识的是这行数据是否被删除了，其实看到这个bit位，很多人可能已经反 映过来了，这么说在MySQL里删除一行数据的时候，未必是立马把他从磁盘上清理掉，而是给他在数据头里搞1个bit 标记他已经被删了

没错，其实大家现在看这些数据头，只要先留有一个印象就可以了，知道每一行数据都有一些数据头，不同的数据头 都是用来描述这行数据的一些状态和附加信息的。 然后下一个bit位是`min_rec_mask`，他其实就是说在B+树里每一层的非叶子节点里的最小值都有这个标记。 

接下来有4个bit位是`n_owned`，这个暂时我们也先不用去管他，他其实就是记录了一个记录数

接着有13个bit位是`heap_no`，他代表的是当前这行数据在记录堆里的位置 

然后是3个bit位的`record_type`，这就是说这行数据的类型

0代表的是普通类型，1代表的是B+树非叶子节点，2代表的是最小值数据，3代表的是最大值数据

最后是16个bit的`next_record`，这个是指向他下一条数据的指针

# 实际数据存储

首先我们在存储真实数据的时候，并没什么特别的，无非就是按照我们那个字段里的数据值去存储就行了

比如我们之前说了一个例子，有一行数据是“jack NULL m NULL xx_school”，那么他真实存储大致如下所示：

0x09 0x04 00000101 0000000000000000000010000000000000011001 jack m xx_school 

刚开始先是他的变长字段的长度，用十六进制来存储，然后是NULL值列表，指出了谁是NULL，接着是40个bit位的数据头， 然后是真实的数据值，就放在后面。

在读取这个数据的时候，他会根据变长字段的长度，先读取出来jack这个值，因为他的长度是4，就读取4个长度的数据，jack 就出来了；

然后发现第二个字段是NULL，就不用读取了；

第三个字段是定长字段，直接读取1个字符就可以了，就是m这个值；

第四个字段是NULL，不用读取了；

第五个字段是变长字段长度是9，读取出来`xx_school`就可以了。

但是等等，大家觉得真正在磁盘上存储的时候，我们那些字符串就是直接这么存储在磁盘上吗？

显然不是的！

实际上字符串这些东西都是根据我们数据库指定的字符集编码，进行编码之后再存储的，所以大致看起来一行数据是如下所示 的：

0x09 0x04 00000101 0000000000000000000010000000000000011001 616161 636320 6262626262

大家会看到上面，我们的字符串和其他类型的数值最终都会根据字符集编码，搞成一些数字和符号存储在磁盘上

所以其实一行数据是如何存储的，我相信大家就都已经了解的很清晰了，在实际存储一行 数据的时候，会在他的真实数据部分，加入一些隐藏字段，这个隐藏字段跟后续的一些内容是有关联的，大家先了解一下。

首先有一个`DB_ROW_ID`字段，这就是一个行的唯一标识，是他数据库内部给你搞的一个标识，不是你的主键ID字段。如果我 们没有指定主键和unique key唯一索引的时候，他就内部自动加一个`ROW_ID`作为主键。 

接着是一个`DB_TRX_ID`字段，这是跟事务相关的，他是说这是哪个事务更新的数据，这是事务ID，这个后续我们讲解到事务的 时候会跟大家说的。

最后是`DB_ROLL_PTR`字段，这是回滚指针，是用来进行事务回滚的

所以如果你加上这几个隐藏字段之后，实际一行数据可能看起来如下所示：

0x09 0x04 00000101 0000000000000000000010000000000000011001 00000000094C（DB_ROW_ID） 00000000032D（DB_TRX_ID） EA000010078E（DB_ROL_PTR） 616161 636320 6262626262

我给上面几个隐藏字段都加了括号说明了，上面那基本就是最终在磁盘上一行数据是长成什么样的了

# 行溢出

实际上我们每一行数据都是放在一个数据页里的，这个数据页默认的大小是16KB

那么之前就有 人在后台提过一个问题：万一 一行数据的大小超过了页的大小怎么办呢？

 比如有一个表的字段类型是VARCHAR(65532)，意思就是最大可以包含65532个字符，那也就是65532个字节，这就远大于 16kb的大小了，也就是说这一行数据的这个字段都远超一个数据页的大小了！ 这个时候实际上会在那一页里存储你这行数据，然后在那个字段中，仅仅包含他一部分数据，同时包含一个20个字节的指针， 指向了其他的一些数据页，那些数据页用链表串联起来，存放这个VARCHAR(65532)超大字段里的数据

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210302234731.png" style="zoom:25%;" />

上面说的这个过程，其实就叫做行溢出，就是说一行数据存储的内容太多了，一个数据页都放不下了，此时只能溢出这个数据 页，把数据溢出存放到其他数据页里去，那些数据页就叫做溢出页。

包括其他的一些字段类型都是一样的，比如TEXT、BLOB这种类型的字段，都有可能出现溢出，然后一行数据就会存储在多个 数据页里。

每一行数据都是放在数据页里的，如果一行数据太大了，就会产生行溢出问题，导致一行数据溢出到多个数据页里去，那 么这行数据在Buffer Pool可能就是存在于多个缓存页里的，刷入到磁盘的时候，也是用磁盘上的多个数据页来存放这行数据 的

# 数据页

其实MySQL中进行数据操作的最小单位应该是数据页

现在我们都知道，一行一行的数据是放在数据页里的，所以接下来就该分析分析，数据页到底是长什么样子的了。

之前介绍过，每个数据页，实际上是默认有16kb的大小，那么这16kb的大小就是存放大量的数据行吗？ 明显不是的，其实一个数据页拆分成了很多个部分，大体上来说包含了文件头、数据页头、最小记录和最大记录、多 个数据行、空闲空间、数据页目录、文件尾部。

我下面有一个图，在图里包含了一个数据页的各个部分，大家可以看一下

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210302235047.png" style="zoom:25%;" />

其中文件头占据了38个字节，数据页头占据了56个字节，最大记录和最小记录占据了26个字节，数据行区域的大小是 不固定的，空闲区域的大小也是不固定的，数据页目录的大小也是不固定的，然后文件尾部占据8个字节。

其实也没什么好奇怪的，说白了，这个数据页就跟每一行数据一样，都是由MySQL开发人员设计出来的一个特殊的存 储格式。

也就是说通过这种特殊的存储格式在磁盘文件里去存放一个又一个的数据页，每个数据页在磁盘里实际存储的时候， 就是包含了上述一些特殊的数据，然后每个数据页里还有专门的区域包含了多个数据行，至于每个数据行，那就是用 我们之前讲解的那套存储格式来存储的了。

接着我们给大家讲一下这个把数据插入数据页的一个过程，因为大家都知道，刚开始一个数据页可能是空的，没有一 行数据的，此时这个数据页实际上是没有数据行那个区域的

**也就是说，此时看起来一个空的数据页就是下面图里那样的**

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210302235148.png" style="zoom:25%;" />

# 表空间

> 什么是表空间

简单来说，就是我们平时创建的那些表，其实都是有一个表空间的概念，在磁盘上都会对应着`“表名.ibd”`这样的一个 磁盘数据文件

所以其实在物理层面，表空间就是对应一些磁盘上的数据文件。

有的表空间，比如系统表空间可能对应的是多个磁盘文件，有的我们自己创建的表对应的表空间可能就是对应了一个` “表名.ibd”`数据文件。

然后在表空间的磁盘文件里，其实会有很多很多的数据页，因为大家都知道一个数据页不过就是16kb而已，总不可能 一个数据页就是一个磁盘文件吧。

所以一个表空间的磁盘文件里，其实是有很多的数据页的。

但是现在有一个问题，就是一个表空间里包含的数据页实在是太多了，不便于管理，所以在表空间里又引入了一个**数据区**的概念，英文就是extent

一个数据区对应着连续的64个数据页，每个数据页是16kb，所以一个数据区是1mb，然后256个数据区被划分为了一 组。

对于表空间而言，他的第一组数据区的第一个数据区的前3个数据页，都是固定的，里面存放了一些描述性的数据。比 如`FSP_HDR`这个数据页，他里面就存放了表空间和这一组数据区的一些属性。

`IBUF_BITMAP`数据页，里面存放的是这一组数据页的所有insert buffer的一些信息。

INODE数据页，这里也是存放了一些特殊的信息

大家暂时先不用了解这些东西具体是干什么的，你只要知道每一个组数据区的第一个数据区的前3个数据页，都是存放 一些特殊的信息的。

然后这个表空间里的其他各组数据区，每一组数据区的第一个数据区的头两个数据页，都是存放特殊信息的，比如 XDES数据页就是用来存放这一组数据区的一些相关属性的，其实就是很多描述这组数据区的东西

我们平时创建的那些表都是有对 应的表空间的，每个表空间就是对应了磁盘上的数据文件，在表空间里有很多组数据区，一组数据区是256个数据区， 每个数据区包含了64个数据页，是1mb

**然后表空间的第一组数据区的第一个数据区的头三个数据页，都是存放特殊信息的；**

表空间的其他组数据区的第一个数据区的头两个数据页，也都是存放特殊信息的

所以磁盘上的各个表空间的数据文件里是通过数据区的概念，划分了很多很多的数据页的，因此当我们需要执行crud 操作的时候，说白了，就是从磁盘上的表空间的数据文件里，去加载一些数据页出来到Buffer Pool的缓存页里去使 用。

我下面给出了一张图，图里就给出了一个表空间内部的存储结构，包括一组一组的数据区，每一组数据区是256个数据 区，然后一个数据区是64个数据页

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303101537.png" style="zoom:25%;" />