---
title: Explain
categories: 
- 学习笔记
- MySQL1
---

首先，当你执行explain命令之后，拿到的执行计划可能是类似下面这样的东西：

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304153212.png" style="zoom:25%;" />

大致来说，如果是一个简单的单表查询，可能这里就只有一条数据，也就是代表了他是打算如何访问这 一个表而已。 但是如果你的SQL语句极为的复杂，可能这里会有很多条数据，因为一个复杂的SQL语句的执行是要拆 分为很多步骤的，比如先访问表A，接着搞一个排序，然后来一个分组聚合，再访问表B，接着搞一个连 接，类似这样子

好，那么接下来我们就先来研究一下这个所谓的执行计划里包含的各个字段都是什么意思，首先是id这 个东西

这个id呢，就是说每个SELECT都会对应一个id，其实说穿了，就是一个复杂的SQL里可能会有很多个 SELECT，也可能会包含多条执行计划，每一条执行计划都会有一个唯一的id，这个没啥好说的。

select_type，顾名思义，说的就是这一条执行计划对应的查询是个什么查询类型，table就是表名，意 思是要查询哪个表，partitions是表分区的概念，这个所谓的分区表我们会在后面给大家讲，这里先不 用太关注他。

type，就是比较关键了，针对当前这个表的访问方法，这个之前我们都讲过很多，比如说const、ref、 range、index、all之类的，分别代表了使用聚簇索引、二级索引、全表扫描之类的访问方式。

possible_keys，这也很关键，他是跟type结合起来的，意思就是说你type确定访问方式了，那么到底 有哪些索引是可供选择，可以使用的呢，这都会放这里。key，就是在possible_keys里实际选择的那个 索引，而key_len就是索引的长度。

ref，就是使用某个字段的索引进行等值匹配搜索的时候，跟索引列进行等值匹配的那个目标值的一些信 息。

rows，是预估通过索引或者别的方式访问这个表的时候，大概可能会读取多少条数据。

ﬁltered， 就是经过搜索条件过滤之后的剩余数据的百分比。

extra是一些额外的信息，不是太重要。

**explain select * from t1 就这么一个简单的SQL语句**

那么假设他这个里面有大概几千条数据，此时执行计划看起来是什么样 的

首先呢，id是1，这个不用管他了，`select_type`是SIMPLE，这个先不说他什么意思，你要知道顾名思 义，这个表的查询类型是很普通的、而且简单的就可以了。

table是t1，这还用说么？表名就是t1，所以意思就是这里要访问t1这个表。

type是all，这就是我们之前 提到的多种访问方式之一了，all就是全表扫描，这没办法，你完全没加任何where条件，那当然只能是 全表扫描了！

rows是3457，这说明全表扫描会扫描这个表的3457条数据，说明这个表里就有3457条数据，此时你全 表扫描会全部扫描出来。

ﬁltered是100%，这个也很简单了，你没有任何where过滤条件，所以直接筛 选出来的数据就是表里数据的100%占比。

# 多表关联

**接着再来看一个SQL语句的执行计划：**

`explain select * from t1 join t2` 这是一个典型的多表关联语句

之前我们说过，这种关联语句，实际上会选择一个表先查询出来数据， 接着遍历每一条数据去另外一个表里查询可以关联在一起的数据，然后关联起来

这个执行计划就比较有意思了，因为是一个多表关联的执行计划。首先很明显，他的执行计划分为了两 条，也就是会访问两个表，先看他如何访问第一个表的，针对第一个表就是t1，明显是先用ALL方式全 表扫描他了，而且扫出了3457条数据。

接着对第二个表的访问，也就是t2表，同样是全表扫描，因为他这种多表关联方式，基本上是笛卡尔积 的效果

t1表的每条数据都会去t2表全表扫描所有4568条数据，跟t2表的每一条数据都会做一个关联， 而且extra里说了是Nested Loop，也就是嵌套循环的访问方式，跟我们之前讲解的关联语句的执行原理 都是匹配的

另外大家会发现上面两条执行计划的id都是1，是一样的，实际上一般来说，在执行计划里，一个 SELECT会对应一个id，因为这两条执行计划对应的是一个SELECT语句，所以他们俩的id都是1，是一 样。

如果你要是有一个子查询，有另外一个SELECT，那么另外一个SELECT子查询对应的执行计划的id就可 能是2了。

# 子查询

**来一起看一个包含子查询的SQL语句的执行 计划：**

`EXPLAIN SELECT * FROM t1 WHERE x1 IN (SELECT x1 FROM t2) OR x3 = 'xxxx';`

这个SQL就稍微有一点点的复杂了，因为主SELECT语句的WHERE筛选条件是依赖于一个子查询的，而 且除此之外还有一个自己的WHERE筛选条件，那么他的执行计划长什么样子呢？我们看看。

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304161918.png" style="zoom:25%;" />

这个执行计划值得我们好好分析一下，首先，第一条执行计划的id是1，第二条执行计划的id是2，这是 为什么

因为这个SQL里有两个SELECT，主查询SELECT的执行计划的id就是1，子查询SELECT的执行 计划的id就是2

其次，第一条执行计划里，`select_type`是PRIMARY，不是SIMPLE了，说明第一个执行计划的查询类型 是主查询的意思，对主查询而言，他有一个where条件是`x3='xxx'`，所以他的`possible_keys`里包含了 `index_x3`，就是x3字段的索引，但是他的key实际是NULL，而且type是ALL，所以说他最后没选择用x3 字段的索引，而是选择了全表扫描

> 这是为什么呢

其实很简单，可能他通过成本分析发现，使用x3字段的索引扫描xxx这个值，几乎就跟 全表扫描差不多，可能x3这个字段的值几乎都是xxx，所以最后就选择还不如直接全表扫描呢

接着第二条执行计划，他的`select_type`是SUBQUERY，也就是子查询，子查询针对的是t2这个表，当然 子查询本身就是一个全表查询，但是对主查询而言，会使用`x1 in` 这个筛选条件，他这里type是index， 说明使用了扫描`index_x1`这个x1字段的二级索引的方式，直接扫描x1字段的二级索引，来跟子查询的结 果集做比对。

# union查询

**接着我们来看另外一个union的SQL语句：**

`EXPLAIN SELECT * FROM t1 UNION SELECT * FROM t2`

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304163826.png" style="zoom:25%;" />

这个执行计划的第一条和第二条很好理解对吧？

两个SELECT字句对应两个id，就是分别从t1表和t2表里 进行全表扫描罢了

接着第三条执行计划是什么呢？

其实union字句默认的作用是把两个结果集合并起来还会进行去重，所 以第三条执行计划干的是个去重的活儿

所以上面他的table是`<union 1,2>`，这就是一个临时表的表名，而且你看他的extra里，有一个using temporary，也就是使用临时表的意思，他就是把结果集放到临时表里进行去重的，就这么个意思

当 然，如果你用的是union all，那么就不会进行去重了。

# select_type

**接着我们来看看这个select_type**

select_type之前我们似乎看到过几种，有什么SIMPLE的，还有 primary和subquery的，那么这些`select_type`都是什么意思？除此之外，还有哪几种`select_type`呢？

首先要告诉大家的是，一般如果单表查询或者是多表连接查询，其实他们的`select_type`都是SIMPLE， 这个之前大家也都看到过了，意思就是简单的查询罢了。

然后如果是union语句的话，就类似于`select * from t1 union select * from t2`，那么会对应两条执行 计划，第一条执行计划是针对t1表的，`select_type`是PRIMARY，第二条执行计划是针对t2表的， `select_type`是UNION，这就是在出现union语句的时候，他们就不一样了。

在使用union语句的时候，会有第三条执行计划，这个第三条执行计划意思是针 对两个查询的结果依托一个临时表进行去重，这个第三条执行计划的select_type就是`union_result`。

另外，之前我们还看到过，如果是在SQL里有子查询，类似于`select * from t1 where x1 in (select x1 ﬀrom t2) or x3='xxx'`，此时其实会有两条执行计划，第一条执行计划的`select_type`是PRIMARY，第二 条执行计划的`select_type`是SUBQUERY，这个我们之前也看到过了。

**那么现在我们来看一个稍微复杂一点的SQL语句：**

`EXPLAIN SELECT * FROM t1 WHERE x1 IN (SELECT x1 FROM t2 WHERE x1 = 'xxx' UNION SELECT x1 FROM t1 WHERE x1 = 'xxx');`

这个SQL语句就稍微有点复杂了，因为他有一个外层查询，还有一个内层子查询，子查询里还有两个 SELECT语句进行union操作，那么我们来看看他的执行计划会是什么样的呢

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304174231.png" style="zoom:25%;" />

第一个执行计划一看就是针对t1表查询的那个外层循环，`select_type`就是PRIMARY，因为这里涉及到了 子查询，所以外层查询的`select_type`一定是PRIMARY了。

然后第二个执行计划是子查询里针对t2表的那个查询语句，他的`select_type`是DEPENDENT SUBQUERY，第三个执行计划是子查询里针对t1表的另外一个查询语句，`select_type`是DEPENDENT UNION，因为第三个执行计划是在执行union后的查询，第四个执行计划的`select_type`是UNION RESULT，因为在执行子查询里两个结果集的合并以及去重。

**现在再来看一个更加复杂一点的SQL语句：**

`EXPLAIN SELECT * FROM (SELECT x1, count(*) as cnt FROM t1 GROUP BY x1) AS _t1 where cnt > 10;`

这个SQL可有点麻烦了，他是FROM子句后跟了一个子查询，在子查询里是根据x1字段进行分组然后进 行count聚合操作，也就是统计出来x1这个字段每个值的个数，然后在外层则是针对这个内层查询的结 果集进行查询通过where条件来进行过滤，看看他的执行计划：

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304165430.png" style="zoom:25%;" />

上面的执行计划里，我们其实应该先看第二条执行计划，他说的是子查询里的那个语句的执行计划，他 的`select_type`是derived，意思就是说，针对子查询执行后的结果集会物化为一个内部临时表，然后外 层查询是针对这个临时的物化表执行的。

大家可以看到，他这里执行分组聚合的时候，是使用的`index_x1`这个索引来进行的，type是index，意 思就是直接扫描偶了`index_x1`这个索引树的所有叶子节点，把x1相同值的个数都统计出来就可以了。

然后外层查询是第一个执行计划，`select_type`是PRIMARY，针对的table是，就是一个子查询结果集物 化形成的临时表，他是直接针对这个物化临时表进行了全表扫描根据where条件进行筛选的。

# type

**但是这个type就非常关键了**

因为他直接决定了对某个表是如何从里面查询数据的，关于这个查询方式 我们之前早就讲过了，包括了const、ref、range、index、all这几种方式，分别是根据主键/唯一索引 查询，根据二级索引查询，对二级索引进行全索引扫描，对聚簇索引进行全表扫描。

首先，假设是类似于`select * fromt1 where id=110`这样的SQL，直接根据主键进行等值匹配查询，那 执行计划里的type就会是const，意思就是极为快速，性能几乎是线性的。

事实也确实是极为快速的，因为主键值是不会重复的，这个唯一值匹配，在一个索引树里跳转查询，基 本上几次磁盘IO就可以定位到了。

接着我们来看一个SQL语句：

`EXPLAIN SELECT * FROM t1 INNER JOIN t2 ON t1.id = t2.id `

这里是通过两个表的id进行关联查询的

在这个执行计划里，我们会发现针对t1表是一个全表扫描，这个是必然的，因为关联的时候会先查询一 个驱动表，这里就是t1，他没什么where筛选条件，自然只能是全表扫描查出来所有的数据了。 

接着针对t2表的查询type是`eq_ref`，而且使用了PRIMARY主键。这个意思就是说，针对t1表全表扫描获 取到的每条数据，都会去t2表里基于主键进行等值匹配，此时会在t2表的聚簇索引里根据主键值进行快 速查找，所以在连接查询时，针对被驱动表如果基于主键进行等值匹配，那么他的查询方式就是`eq_ref `了。

而如果要是正常基于某个二级索引进行等值匹配的时候，type就会是ref，而如果基于二级索引查询的 时候允许值为null，那么查询方式就会是`ref_or_null`

另外之前讲过，有一些特殊场景下针对单表查询可能会基于多个索引提取数据后进行合并，此时查询方 式会是`index_merge`这种。

而查询方式是range的话就是基于二级索引进行范围查询，查询方式是index的时候是直接扫描二级索引 的叶子节点，也就是扫描二级索引里的每条数据，最后如果是all的话就是全表扫描，也就是对聚簇索引 的叶子节点扫描每条数据。

# possible_keys

**今天来先讲一下 possible_keys**

这个possible_keys，顾名思义，其实就是在针对一个表进行查询的时候有哪些潜在可以使用的索引。

比如你有两个索引，一个是KEY(x1, x2, x3)，一个是KEY(x1, x2, x4)，此时要是在where条件里要根据x1 和x2两个字段进行查询，那么此时明显是上述两个索引都可以使用的，那么到底要使用哪个呢

此时就需要通过我们之前讲解的成本优化方法，去估算使用两个索引进行查询的成本，看使用哪个索引 的成本更低，那么就选择用那个索引，最终选择的索引，就是执行计划里的key这个字段的值了。

而`key_len`，其实就是当你在key里选择使用某个索引之后，那个索引里的最大值的长度是多少，这个就 是给你一个参考，大概知道那个索引里的值最大能有多长，就这么个意思。

而执行计划里的 ref 也相对会关键一些，当你的查询方式是索引等值匹配的时候，比如const、ref、 eq_ref、`ref_or_null`这些方式的时候，此时执行计划的ref字段告诉你的就是：你跟索引列等值匹配的是 什么？是等值匹配一个常量值？还是等值匹配另外一个字段的值？

比如SQL语句：

`EXPLAIN SELECT * FROM t1 WHERE x1 = 'xxx' `

此时如果你看他的执行计划是下面这样的

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304171004.png" style="zoom:25%;" />

大家在上面的查询计划里可以看到，针对t1表的查询，type是ref方式的，也就是说基于普通的二级索引 进行等值匹配，然后`possible_keys`只有一个，就是index_x1，针对x1字段建立的一个索引，而实际使 用的索引也是index_x1，毕竟就他一个是可以用的。

然后`key_len`是589，意思就是说index_x1这个索引里的x1字段最大值的长度也就是589个字节，其实这 个不算是太大，不过基本可以肯定这个x1字段是存储字符串的，因为是一个不规律的长度。 比较关键的是ref字段，它的意思是说，既然你是针对某个二级索引进行等值匹配的，那么跟index_x1 索引进行等值匹配的是什么？是一个常量或者是别的字段？这里的ref的值是const，意思就是说，是使 用一个常量值跟index_x1索引里的值进行等值匹配的。

假设你要是用了类似如下的语句：

`EXPLAIN SELECT * FROM t1 INNER JOIN t2 ON t1.id = t2.id; `

此时执行计划里的ref肯定不是const，因为你跟t1表的id字段等值匹配的是另外一个表的id字段，此时 ref的值就是那个字段的名称了，执行计划如下：

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304171106.png" style="zoom:25%;" />

大家看执行计划，针对t1表作为驱动表执行一个全表扫描，接着针对t1表里每条数据都会去t2表根据t2 表的主键执行等值匹配，所以第二个执行计划的type是eq_ref，意思就是被驱动表基于主键进行等值匹 配，而且使用的索引是PRIMARY就是使用了t2表的主键。

# ref

至于ref，意思就是说，到底是谁跟t2表的聚簇索引里的主键值进行等值匹配呢？是常量值吗？

不是，是test_db这个库下的t1表的id字段，这里跟t2表的主键进行 等值匹配的是t1表的主键id字段，所 以ref这里显示的清清楚楚的。

最后简单说一下rows和ﬁltered，这个rows顾名思义，就是说你使用指定的查询方式，会查出来多少条 数据，而ﬁltered意思就是说，**在查询方式查出来的这波数据里再用上其他的不在索引范围里的查询条 件**，又会过滤出来百分之几的数据。

比如SQL语句：

`EXPLAIN SELECT * FROM t1 WHERE x1 > 'xxx' AND x2 = 'xxx' `

他只有一个x1字段建了索引，x2字段是没有索引的，此时执行计划如下：

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304171143.png" style="zoom:25%;" />

上面的执行计划清晰的表明了，针对t1表的查询方式是range，也就是基于索引进行范围查询，用的索 引是index_x1，也就是x1字段的索引，然后基于x1>'xxx'这个条件通过index_x1索引查询出来的数据大 概是1987条，接着会针对这1987条数据再基于where条件里的其他条件，也就是x2='xxx'进行过滤。

这个ﬁltered是13.00，意思是估算基于x2='xxx'条件过滤后的数据大概是13%，也就是说最终查出来的 数据大概是`1987 * 13% = 258`条左右。

# extra

## using index

这周其实我们主要就是研究一下执行计划里的extra这个字段里的内容都是代表什么的，其实很多人可 能以为extra字段是无关紧要的，其实并不是，因为除了extra字段以外的其他内容，最多就是告诉你针 对你SQL里的每个表是如何查询的，用了哪个索引，查出来了多少数据，但是很多时候，往往针对一个 表可不是那么简单的。

因为除了基于索引查询数据，可能同时还得基于where条件里的其他过滤条件去筛选数据，此时还会筛 选出来一些数据。

比如下面的SQL语句：

`EXPLAIN SELECT x1 FROM t1 WHERE x1 = 'xxx' `

这里我们可以看一下，这个执行计划现在什么意思，可以说是一清二楚。首先他是访问了t1表，使用的 是ref访问方法，也就是基于二级索引去查找，找的是index_x1这个索引，这个索引的最大数据长度是 456字节，查找的目标是一个const代表的常量值，通过索引可以查出来25条数据，经过其他条件筛选 过后，最终剩下数据是100%

好，那么我们看看extra的信息，是Using index，这是什么意思呢？其实就是说这次查询，仅仅涉及到 了一个二级索引，不需要回表，因为他仅仅是查出来了x1这个字段，直接从index_x1索引里查就行了。

如果没有回表操作，仅仅在二级索引里执行，那么extra里会告诉in是Using index。

另外，如果有个SQL语句是：

`SELECT * FROM t1 WHERE x1 > 'xxx' AND x1 LIKE '%xxx' `

此时他会先在二级索引index_x1里查找，查找出来的结果还会额外的跟x1 LIKE '%xxx'条件做比对，如 果满足条件的才会被筛选出来，这种情况下，extra显示的是Using index condition。

## using where

这个恐怕是最最常见的了，其实这个一般是见于你直接针对一个表扫描，没用到索引，然后where里好 几个条件，就会告诉你Using where，或者是你用了索引去查找，但是除了索引之外，还需要用其他的 字段进行筛选，也会告诉你Using where。

比如说下面的SQL语句：

`EXPLAIN SELECT * FROM t1 WHERE x2 = 'xxx' `

这里的x2是没有建立索引的

大家注意看，这里说了，针对t1表进行查询，用的是全表扫描方式，没有使用任何索引，然后全表扫 描，扫出来的是4578条数据，这个时候大家注意看extra里显示了Using where，意思就是说，他对每 条数据都用了`WHERE x2 = 'xxx'`去进行筛选。

最终ﬁltered告诉了你，过滤出来了15%的数据，大概就是说，从这个表里筛选出来了686条数据，就这 个意思

那么如果你的where条件里有一个条件是针对索引列查询的，有一个列是普通列的筛选，类似下面的 SQL语句：

`EXPLAIN SELECT * FROM t1 WHERE x1 = 'xxx' AND x2 = 'xxx' `

这个执行计划也是非常的清晰明了，这里针对t1表去查询，先通过ref方式直接在index_x1索引里查找， 是跟const代表的常量值去查找，然后查出来250条数据，接着再用Using where代表的方式，去使用 `AND x2 = 'xxx'`条件进行筛选，筛选后的数据比例是18%，最终所以查出来的数据大概应该是45条。

另外要给大家说的是，在多表关联的时候，有的时候你的关联条件并不是索引，此时就会用一种叫做 join buﬀer的内存技术来提升关联的性能，比如下面的SQL语句：

`EXPLAIN SELECT * FROM t1 INNER JOIN t2 ON t1.x2 = t2.x2 `

他们的连接条件x2是没有索引的，此时一起看看他的执行计划

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304173256.png" style="zoom:25%;" />

这个执行计划其实也很有意思，因为要执行join，那么肯定是先得查询t1表的数据，此时是对t1表直接 全表查询，查出来4578条数据，接着似乎很明确了，就是对每条数据的x2字段的值，跑到t2表里去查对 应的数据，进行关联

但是此时因为 t2 表也没法根据索引来查，也是属于全表扫描，所以每次都得对t2表全表扫描一下，根 据extra提示的Using where，就是根据t1表每条数据的x2字段的值去t2表查找对应的数据了，然后此时 会用join buﬀer技术，在内存里做一些特殊优化，减少t2表的全表扫描次数。

## using ﬁlesort

先来看看Using ﬁlesort是什么意思，首先大家要知道，有的时候我们在SQL语句里进行排序的时候， 如果排序字段是有索引的，那么其实是直接可以从索引里按照排序顺序去查找数据的，比如这个SQL：

`EXPLAIN SELECT * FROM t1 ORDER BY x1 LIMIT 10 `

这就是典型的一个排序后再分页的语句

大家可以看到，这个SQL语句，他是用了index方式访问的，意思就是说直接扫描了二级索引，而且实 际使用的索引也是index_x1，本质上来说，他就是在 index_x1索引里，按照顺序找你LIMIT 10要求的 10条数据罢了。

所以大家看到返回的数据是10条，也没别的过滤条件了，所以ﬁltered是100%，也就是10条数据都返回 了。

但是如果我们排序的时候是没法用到索引的，此时就会基于内存或者磁盘文件来排序，大部分时候得都 基于磁盘文件来排序，比如说这个SQL：

`EXPLAIN SELECT * FROM t1 ORDER BY x2 LIMIT 10 `

x2字段是没有索引的

这个SQL很明确了，他基于x2字段来排序，是没法直接根据有序的索引去找数据的，只能把所有数据写 入一个临时的磁盘文件，基于排序算法在磁盘文件里按照x2字段的值完成排序，然后再按照LIMIT 10的 要求取出来头10条数据。

所以大家以后要注意一下，这种把表全数据放磁盘文件排序的做法真的是相当的糟糕，性能其实会极差 的。

## using temporary

最后给大家讲一下，如果我们用group by、union、distinct之类的语法的时候，万一你要是没法直接利 用索引来进行分组聚合，那么他会直接基于临时表来完成，也会有大量的磁盘操作，性能其实也是极低 的。

比如这个SQL：

`EXPLAIN SELECT x2, COUNT(*) AS amount FROM t1 GROUP BY x2 `

这里的x2是没有索引的

这个SQL里只能对全表数据放到临时表里做大量的磁盘文件操作，然后才能完成对x2字段的不同的值去 分组，分组完了以后对不同x2值的分组去做聚合操作，这个过程也是相当的耗时的，性能是极低的。
