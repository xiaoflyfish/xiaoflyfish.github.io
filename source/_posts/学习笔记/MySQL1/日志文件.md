---
title: 日志文件
categories: 
- 学习笔记
- MySQL1
---

# binlog

binlog叫做归档日志，他里面记录的是偏向于逻辑性的日志

binlog不是InnoDB存储引擎特有的日志文件，是属于mysql server自己的日志文件

**提交事务的时候，同时会写入binlog** 

在我们提交事务的时候，会把redo log日志写入磁盘文件中去。然后其实在提交事务的时 候，我们同时还会把这次更新对应的binlog日志写入到磁盘文件中去

**binlog日志的刷盘策略分析**

对于binlog日志，其实也有不同的刷盘策略，有一个`sync_binlog`参数可以控制binlog的刷盘策略，他的默认值是0， 此时你把binlog写入磁盘的时候，其实不是直接进入磁盘文件，而是进入os cache内存缓存。

所以跟之前分析的一样，如果此时机器宕机，那么你在os cache里的binlog日志是会丢失的

如果要是把`sync_binlog`参数设置为1的话，那么此时会强制在提交事务的时候，把binlog直接写入到磁盘文件里去， 那么这样提交事务之后，哪怕机器宕机，磁盘上的binlog是不会丢失的

**基于binlog和redo log完成事务的提交**

当我们把binlog写入磁盘文件之后，接着就会完成最终的事务提交，此时会把本次更新对应的binlog文件名称和这次更新的binlog日志在文件里的位置，都写入到redo log日志文件里去，同时在redo log日志文件里写入一个commit标 记。 在完成这个事情之后，才算最终完成了事务的提交

**最后一步在redo日志中写入commit标记的意义是什么**

说白了，他其实是用来保持redo log日志与binlog日志一致的

必须是在redo log中写入最终的事务commit标记了，然后此时事务提交成功，而且redo log里有本次更新对应的日 志，binlog里也有本次更新对应的日志 ，redo log和binlog完全是一致的

**后台IO线程随机将内存更新后的脏数据刷回磁盘**

现在我们假设已经提交事务了，此时一次更新`“update users set name='xxx' where id=10”`，他已经把内存里的 buffer pool中的缓存数据更新了，同时磁盘里有redo日志和binlog日志，都记录了把我们指定的“id=10”这行数据 修改了“name='xxx'”

这个时候磁盘上的数据文件里的“id=10”这行数据的name字段还是等于 zhangsan这个旧的值啊

所以MySQL有一个后台的IO线程，会在之后某个时间里，随机的把内存buffer pool中的修改后的脏数据给刷回到磁 盘上的数据文件里去

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210210002203.png" style="zoom:33%;" />

# redo log

我们都知道，在更新完Buffer Pool中的缓存页之后，必须要写一条redo log，这样才能记录下来我们对数据库做 的修改

redo log可以保证我们事务提交之后，如果事务中的增删改SQL语句更新的缓存页还没刷到磁盘上去，此时MySQL宕 机了，那么MySQL重启过后，就可以把redo log重做一遍，恢复出来事务当时更新的缓存页，然后再把缓存页刷到磁 盘就可以了

**redo log本质是保证事务提交之后，修改的数据绝对不会丢失的**

首先我们都知道，执行增删改SQL语句的时候，都是针对一个表中的某些数据去执行的，此时的话，首先必须找到这 个表对应的表空间，然后找到表空间对应的磁盘文件，接着从磁盘文件里把你要更新的那批数据所在的数据页从磁盘 读取出来，放到Buffer Pool的缓存页里去

接着实际上你的增删改SQL语句就会针对Buffer Pool中的缓存页去执行你的更新逻辑，比如插入一行数据，或者更新 一行数据，或者是删除一行数据

所以大家都知道这个机制里最大的漏洞就在于，万一你一个事务里有增删改SQL更新了缓存页，然后事务提交了，结果万一你还没来得 及让IO线程把缓存页刷新到磁盘文件里，此时MySQL宕机了，然后内存数据丢失，你事务更新的数据就丢失了！

但是也不可能每次你事务一提交，就把你事务更新的缓存页都刷新回磁盘文件里去，因为大家之前也都知道，缓存页 刷新到磁盘文件里，是随机磁盘读写，性能是相当的差！这会导致你数据库性能和并发能力都很弱的！ 所以此时才会引入一个redo log机制，这个机制就是说，你提交事务的时候，绝对是保证把你对缓存页做的修改以日 志的形式，写入到redo log日志文件里去的

**这种日志大致的格式如下：对表空间XX中的数据页XX中的偏移量为XXXX的地方更新了数据XXX**

只要你事务提交的时候保证你做的修改以日志形式写入redo log日志，那么哪怕你此时突然宕机了，也没关系！

实际上，如果你把修改过的缓存页都刷入磁盘，这首先缓存页一个就是16kb，数据比较大，刷入磁盘比较耗时，而且 你可能就修改了缓存页里的几个字节的数据，难道也把完整的缓存页刷入磁盘吗

而且你缓存页刷入磁盘是随机写磁盘，性能是很差的，因为他一个缓存页对应的位置可能在磁盘文件的一个随机位 置，比如偏移量为45336这个地方。

但是如果是写redo log，第一个一行redo log可能就占据几十个字节，就包含表空间好、数据页号、磁盘文件偏移 量、更新值，这个写入磁盘速度很快。

此外，redo log写日志，是顺序写入磁盘文件，每次都是追加到磁盘文件末尾去，速度也是很快的。

所以你提交事务的时候，用redo log的形式记录下来你做的修改，性能会远远超过刷缓存页的方式，这也可以让你的 数据库的并发能力更强

## 基本结构

redo log里本质上记录的就是在对某个表空间的某个数据页的某个偏移量的地方修改了 几个字节的值，具体修改的值是什么，他里面需要记录的就是**表空间号+数据页号+偏移量+修改几个字节的值+具体 的值** 所以根据你修改了数据页里的几个字节的值

redo log就划分为了不同的类型，`MLOG_1BYTE`类型的日志指的就是修 改了1个字节的值，`MLOG_2BYTE`类型的日志指的就是修改了2个字节的值，以此类推，还有修改了4个字节的值的日 志类型，修改了8个字节的值的日志类型。

当然，如果你要是一下子修改了一大串的值，类型就是`MLOG_WRITE_STRING`，就是代表你一下子在那个数据页的某 个偏移量的位置插入或者修改了一大串的值。

所以其实一条redo log看起来大致的结构如下所示：

日志类型（就是类似`MLOG_1BYTE`之类的），表空间ID，数据页号，数据页中的偏移量，具体修改的数据

大致就是一条redo log中依次排列上述的一些东西，这条redo log表达的语义就很明确了，他的类型是什么，类型就 告诉了你他这次增删改操作修改了多少字节的数据；

然后在哪个表空间里操作的，这个就是跟你SQL在哪个表里执行的是对应的；接着就是在这个表空间的哪个数据页里 执行的，在数据页的哪个偏移量开始执行的，具体更新的数据是哪些呢。

**有了上述信息，就可以精准完美的还原出来一次数据增删改操作做的变动了。**

只不过如果是`MLOG_WRITE_STRING`类型的日志，因为不知道具体修改了多少字节的数据，所以其实会多一个修改数 据长度，就告诉你他这次修改了多少字节的数据，如下所示他的格式：

日志类型（就是类似`MLOG_1BYTE`之类的），表空间ID，数据页号，数据页中的偏移量，修改数据长度，具体修改的数据

## redo log block

MySQL内有另外一个数据结构，叫做redo log block，大概你可以理解为，平时我们的数据不是存放在数据页了 的么，用一页一页的数据页来存放数据。

那么对于redo log也不是单行单行的写入日志文件的，他是用一个redo log block来存放多个单行日志的。

一个redo log block是512字节，这个redo log block的512字节分为3个部分，一个是12字节的header块头，一个是 496字节的body块体，一个是4字节的trailer块尾

**在这里面，12字节的header头又分为了4个部分**

包括4个字节的block no，就是块唯一编号； 

2个字节的data length，就是block里写入了多少字节数据； 

2个字节的first record group。这个是说每个事务都会有多个redo log，是一个redo log group，即一组redo log。那么在这个block里的第一组redo log的偏移量，就是这2个字节存储的； 

4个字节的checkpoint on

其实对于我们的redo log而言，他确实是不停的追加写入到redo log磁盘文件里去的，但 是其实每一个redo log都是写入到文件里的一个redo log block里去的，一个block最多放496自己的redo log日志。

**此时可能有人会有疑问了，到底一个一个的redo log block在日志文件里是怎么存在的**

那么一条一条的redo log又 是如何写入日志文件里的redo log block里去的呢？估计很多人都很奇怪这个问题。 所以我们接下来就给大家解答这个问题。

大家先想一下，假设你有一个redo log日志文件，平时我们往里面写数据，你大致可以认为是从第一行开始，从左往 右写，可能会有很多行

假设你要写第一个redo log了，是不是应该起码是先在内存里把这个redo log给弄到一 个redo log block数据结构里去

然后似乎你应该是等内存里的一个redo log block的512字节都满了，再一次性把这个redo log block写入磁盘文件

然后其实按照我们所说的，一个redo log block就是512字节，那么是不是真正写入的时候，把这个redo log block的 512字节的数据，就写入到redo log文件里去就可以了？那么redo log文件里就多了一个block

其实有一定开发经验的朋友都知道，写文件的时候，可以按照字节，一个字节一个字节的写入的，文件里存放的东西 就是很多很多字节，依次排开，然后其中可能512个字节组合起来，就固定代表了一个redo log block。

那么如果依次在磁盘文件里的末尾追加不停的写字节数据，就是磁盘顺序写；但是假设现在磁盘文件里已经有很多很 多的redo log block了，此时要在磁盘里某个随机位置找到一个redo log block去修改他里面几个字节的数据，这就 是磁盘随机写

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303133428.png" style="zoom:25%;" />

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303133453.png" style="zoom:25%;" />

## redo log buffer

这个redo log到底是如何通过内存缓冲之后，再进入磁盘文件里去的，这就涉及到了一个新的组件， redo log buffer，他就是MySQL专门设计了用来缓冲redo log写入的。

这个redo log buffer其实就是MySQL在启动的时候，就跟操作系统申请的一块连续内存空间，大概可以认为相当于是buffer pool吧。那个buffer pool是申请之后划分了N多个空的缓存页和一些链表结构，让你把磁盘上的数据页加载到内存里来的。

redo log buffer也是类似的，他是申请出来的一片连续内存，然后里面划分出了N多个空的redo log block

通过设置mysql的`innodb_log_buffer_size`可以指定这个redo log buffer的大小，默认的值就是16MB，其实已经够大了，毕 竟一个redo log block才512字节而已，每一条redo log其实也就几个字节到几十个字节罢了。

其实redo log都是先写入内存里的redo log block数据结构里去的，然后完 事儿了才会把redo log block写入到磁盘文件里去的

这里我们看到了redo log buffer的结构，就很清晰的知道，当你要写一条redo log的时候，就会先从第一个redo log block开 始写入

写满了一个redo log block，就会继续写下一个redo log block，以此类推，直到所有的redo log block都写满。

**那么此时肯定有人会问了，万一要是redo log buffer里所有的redo log block都写满了呢？**

那此时必然会强制把redo log block刷入到磁盘中去的！

redo log block刷入磁盘文件中，其实就是把512字节的redo log block追加到redo log日志文件里 去就可以了

我们平时执行一个事务的过程中，每个事务会有多个增删改操作，那么就会有多个redo log，这多个redo log就是一组redo log，其实每次一组redo log都是先在别的地方暂存，然后都执行完了，再把一组redo log给写入到redo log buffer的block里去的。

如果一组redo log实在是太多了，那么就可能会存放在两个redo log block中

但是反之，如果说一个redo log group比较小，那么也可能多个redo log group是在一个redo log block里的

**redo log buﬀer中的缓冲日志，到底什么时候可以写入磁盘**

redo log在写的时 候，都是一个事务里的一组redo log，先暂存在一个地方，完事儿了以后把一组redo log写入redo log buﬀer。

写入redo log buﬀer的时候，是写入里面提前划分好的一个一个的redo log block的，选择有空闲空间 的redo log block去写入，然后redo log block写满之后，其实会在某个时机刷入到磁盘里去

> 首先，我们先来看看redo log block是哪些时候会刷入到磁盘文件里去：

1.如果写入redo log buﬀer的日志已经占据了redo log buﬀer总容量的一半了，也就是超过了8MB 的redo log在缓冲里了，此时就会把他们刷入到磁盘文件里去

2.一个事务提交的时候，必须把他的那些redo log所在的redo log block都刷入到磁盘文件里去，只 有这样，当事务提交之后，他修改的数据绝对不会丢失，因为redo log里有重做日志，随时可以恢复事 务做的修改

3.后台线程定时刷新，有一个后台线程每隔1秒就会把redo log buﬀer里的redo log block刷到磁盘 文件里去

4.MySQL关闭的时候，redo log block都会刷入到磁盘里去

忽略上面的第四条不说，因为关闭MySQL的时候必然会刷redo log到磁盘，其他三条其实我们都看到 了，也就是说，如果你瞬间执行大量的高并发的SQL语句，1秒内就产生了超过8MB的redo log，此时 占据了redo log buﬀer一半的空间了，必然会直接把你的redo log刷入磁盘里去

上面这种redo log刷盘的情况，在MySQL承载高并发请求的时候比较常见，比如每秒执行上万个增删改 SQL语句，每个SQL产生的redo log假设有几百个字节，此时却是会在瞬间生成超过8MB的redo log日 志，必然会触发立马刷新redo log到磁盘。

其次，第二种情况，其实就是平时执行一个事务，这个事务一般都是在几十毫秒到几百毫秒执行完毕 的，说实在的，一般正常性能情况下，MySQL单事务性能一般不会超过1秒，否则数据库操作就太慢 了。

那么如果在几十毫秒，或者几百毫秒的时候，执行完毕了一个事务，此时必然会立马把这个事务的redo log都刷入磁盘

第一种情况其实是不常见的，第二种情况是比较常见的，往往redo log刷盘都是以一个短事务提交时候 发生的，第三种情况就是后台线程每秒自动刷新redo log到磁盘去，这个就是说假设没有别的情况触 发，后台线程自己都会不停的刷新redo log到磁盘。

但是不管怎么说，主要是保证一个事务执行的时候，redo log都进入redo log buﬀer，提交事务的时 候，事务对应的redo log必须是刷入磁盘文件，接着才算是事务提交成功，否则事务提交就是失败，保 证这一点，就能确保事务提交之后，数据不会丢，有redo log在磁盘里就行了。

当然，绝对保证数据不丢，还得配置一个参数，提交事务把redo log刷入磁盘文件的os cache之后，还 得强行从os cache刷入物理磁盘。

最后给大家说一下redo log日志文件的问题，我们都知道平时不停的执行增删改，那么MySQL会不停的 产生大量的redo log写入日志文件

**那么日志文件就用一个写入全部的redo log？对磁盘占用空间越来 越大怎么办**

别担心，这些问题都可以解决，实际上默认情况下，redo log都会写入一个目录中的文件里，这个目录 可以通过`show variables like 'datadir'`来查看，可以通过`innodb_log_group_home_dir`参数来设置这个 目录的。

然后redo log是有多个的，写满了一个就会写下一个redo log，而且可以限制redo log文件的数量，通 过`innodb_log_ﬁle_size`可以指定每个redo log文件的大小，默认是48MB，通过 `innodb_log_ﬁles_in_group`可以指定日志文件的数量，默认就2个。

所以默认情况下，目录里就两个日志文件，分别为`ib_logﬁle0`和`ib_logﬁle1`，每个48MB，最多就这2个 日志文件，就是先写第一个，写满了写第二个。那么如果第二个也写满了呢？别担心，继续写第一个， 覆盖第一个日志文件里原来的redo log就可以了。

所以最多这个redo log，mysql就给你保留了最近的96MB的redo log而已，不过这其实已经很多了，毕 竟redo log真的很小，一条通常就几个字节到几十个字节不等，96MB足够你存储上百万条redo log 了

如果你还想保留更多的redo log，其实调节上述两个参数就可以了，比如每个redo log文件是96MB， 最多保留100个redo log文件

下面图里，给大家展示出来了多个redo log文件循环写入的示意

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303144623.png" style="zoom:25%;" />

# undo log

假设现在我们一个事务里要执行一些增删改的操作，那么必然是先把对 应的数据页从磁盘加载出来放buﬀer pool的缓存页里，然后在缓存页里执行一通增删改，同时记录 redo log日志

万一要是一个事务里的一通增删改操作执行到了一半，结果就回滚事务了呢

比如一个事务里有4个增删改操作，结果目前为止已经执行了2个增删改SQL了，已经更新了一些buﬀer pool里的数据了，但是还有2个增删改SQL的逻辑还没执行，此时事务要回滚了怎么办

所以在执行事务的时候，才必须引入另外一种日志，就是undo log回滚日志 这个回滚日志，他记录的东西其实非常简单，比如你要是在缓存页里执行了一个insert语句，那么此时 你在undo log日志里，对这个操作记录的回滚日志就必须是有一个主键和一个对应的delete操作，要能 让你把这次insert操作给回退了。

那么比如说你要是执行的是delete语句，那么起码你要把你删除的那条数据记录下来，如果要回滚，就 应该执行一个insert操作把那条数据插入回去。

如果你要是执行的是update语句，那么起码你要把你更新之前的那个值记录下来，回滚的时候重新 update一下，把你之前更新前的旧值给他更新回去。

如果你要是执行的是select语句呢？不好意思，select语句压根儿没有在buﬀer pool里执行任何修改， 所以根本不需要undo log！

## 基本结构

比如你执行了INSERT语句，那么你的undo log必须告诉你插入数据的主键ID，让你在回滚的时候可以 从缓存页里把这条数据给删除了；

如果你执行了DELETE语句，那么你的undo log必须记录下来被删除的数据，回滚的时候就得重新插入 一条数据；

如果你执行了UPDATE语句，那么你必须记录下来修改之前的数据，回滚的时候就得把数据给更新回 去

**INSERT语句的undo log的类型是TRX_UNDO_INSERT_REC，这个undo log里包含了以下一些东西：**

这条日志的开始位置 主键的各列长度和值 表id undo log日志编号 undo log日志类型 这条日志的结束位置 接下来我们来给大家解释一下，首先，一条日志必须得有自己的一个开始位置，这个没什么好说的是 吧？

那么主键的各列长度和值是什么意思？大家都知道，你插入一条数据，必然会有一个主键！

如果你自己指定了一个主键，那么可能这个主键就是一个列，比如id之类的，也可能是多个列组成的一 个主键，比如“id+name+type”三个字段组成的一个联合主键，也是有可能的。

所以这个主键的各列长度和值，意思就是你插入的这条数据的主键的每个列，他的长度是多少，具体的 值是多少。即使你没有设置主键，MySQL自己也会给你弄一个`row_id`作为隐藏字段，做你的主键。

接着是表id，这个就不用多说了，你插入一条数据必然是往一个表里插入数据的，那当然得有一个表 id，记录下来是在哪个表里插入的数据了。

undo log日志编号，这个意思就是，每个undo log日志都是有自己的编号的。

而在一个事务里会有多个SQL语句，就会有多个undo log日志，在每个事务里的undo log日志的编号都 是从0开始的，然后依次递增。

至于undo log日志类型，就是`TRX_UNDO_INSERT_REC`，insert语句的undo log日志类型就是这个东 西。

最后一个undo log日志的结束位置，这个自然也不用多说了，他就是告诉你undo log日志结束的位置是 什么。

那么接着我们用一个图画一下这个INSERT语句的undo log回滚日志的结构，大家来看一眼，感受一 下

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303152754.png" style="zoom:25%;" />

万一要是你现在在buﬀer pool的一个缓存页里插入了一条数据了，执行了insert语句，然后你写了一条 上面的那种undo log，现在事务要是回滚了，你直接就把这条insert语句的undo log拿出来。 然后在undo log里就知道在哪个表里插入的数据，主键是什么，直接定位到那个表和主键对应的缓存 页，从里面删除掉之前insert语句插入进去的数据就可以了，这样就可以实现事务回滚的效果了！

