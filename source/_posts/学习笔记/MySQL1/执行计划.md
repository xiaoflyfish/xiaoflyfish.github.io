---
title: 执行计划
categories: 
- 学习笔记
- MySQL1
---

# 单表查询

我们之前都知道，假设你写一个`select * from table where id=x`，或者`select * from table where name=x`的语句，直接就可以通过聚簇索引或者二级索引+聚簇索引回源，轻松查到你要的数据，这种 根据索引直接可以快速查找数据的过程，在执行计划里称之为const，意思就是性能超高的常量级的。

所以你以后在执行计划里看到const的时候，就知道他就是直接通过索引定位到数据，速度极快，这就 是const的意思。

但是这里有一个要点，你的二级索引必须是唯一索引，才是属于const方式的，也就是说你必须建立 unique key唯一索引，保证一个二级索引的每一个值都是唯一的，才可以。

那么如果你是一个普通的二级索引呢？就是个普通的KEY索引，这个时候如果你写一个`select * from table where name=x`的语句，name是个普通二级索引，不是唯一索引，那么此时这种查询速度也是很 快的，他在执行计划里叫做ref

如果你是包含多个列的普通索引的话，那么必须是从索引最左侧开始连续多个列都是等值比较才可以是 属于ref方式，就是类似于`select * from table where name=x and age=x and xx=xx`，然后索引可能是 个KEY(name,age,xx)。

然后一个例外，就是如果你用name IS NULL这种语法的话，即使name是主键或者唯一索引，还是只能 走ref方式。但是如果你是针对一个二级索引同时比较了一个值还有限定了IS NULL，类似于`select * from table where name=x and name IS NULL`，那么此时在执行计划里就叫做`ref_or_null`

说白了，就是在二级索引里搜你要的值以及是NULL的值，然后再回源去聚簇索引里查罢了，因为同时 有索引等值比较和NULL值查询，就叫做`ref_or_null`了

如果你看到了ref是什么意思？对，就是用了普通的索引，或者用主键/唯一索引搞了一个IS NULL/IS NOT NULL。

**先说说range这个东西，这个东西顾名思义，其实就是你SQL里有范围查询的时候就会走这个方式。**

比如写一个SQL是`select * from table where age>=x and age <=x`，假设age就是一个普通索引，此时就必然利用索引来进行范围筛选，一旦利用索引做了范围筛选，那么这种方式就是range。

接着停下脚步做个总结，假设你在执行计划里看到了const、ref和range，他们是什么意思

假设我们有一个表，里面完整的字段联合索引是KEY(x1,x2,x3)，好，现在我们写一个SQL语句是`select x1,x2,x3 from table where x2=xxx`，相信大多数同学看到这里，都会觉得，完蛋了，x2不是联合索引 的最左侧的那个字段啊！

对的，这个SQL是没办法直接从联合索引的索引树的根节点开始二分查找，快速一层一层跳转的，那么 他会怎么执行呢？不知道大家是否发现这个SQL里要查的几个字段，就是联合索引里的几个字段，巧 了！

所以针对这种SQL，在实际查询的时候，就会直接遍历KEY(x1,x2,x3)这个联合索引的索引树的叶子节 点，大家还记得聚簇索引和普通索引的叶子节点分别存放了什么吗

聚簇索引的叶子节点放的是完整的数据页，里面包含完整的一行一行的数据，联合索引的叶子节点放的 也是页，但是页里每一行就x1、x2、x3和主键的值！ 所以此时针对这个SQL，会直接遍历KEY(x1,x2,x3)索引树的叶子节点的那些页，一个接一个的遍历，然 后找到 x2=xxx 的那个数据，就把里面的x1，x2，x3三个字段的值直接提取出来就可以了！这个遍历二 级索引的过程，要比遍历聚簇索引快多了，毕竟二级索引叶子节点就包含几个字段的值，比聚簇索引叶 子节点小多了，所以速度也快！

也就是说，此时只要遍历一个KEY(x1,x2,x3)索引就可以了，不需要回源到聚簇索引去！针对这种只要遍 历二级索引就可以拿到你想要的数据，而不需要回源到聚簇索引的访问方式，就叫做index访问方式

现在我们停一下脚步，思考一下，之前说的const、ref和range，本质都是基于索引树的二分查找和多 层跳转来查询，所以性能一般都是很高的，然后接下来到index这块，速度就比上面三种要差一些了， 因为他是走遍历二级索引树的叶子节点的方式来执行了，那肯定比基于索引树的二分查找要慢多了，但 是还是比全表扫描好一些的。

# 执行计划1

首先，我们已经学习了const、ref、range、index几种执行计划里的访问方式，const、ref和range本 质都是基于索引查询，只要你索引查出来的数据量不是特别大，一般性能都极为高效，index稍微次一 点，需要遍历某个二级索引，但是因为二级索引比较小，所以遍历性能也还可以的。

另外最次的一种就是all了，all意思就是直接全表扫描，扫描你的聚簇索引的所有叶子节点，也就是一个 表里一行一行数据去扫描，如果一个表就几百条数据那还好，如果是有几万条，或者几十万，几百万数 据，全表扫描基本就得跪了。

首先大家看一个SQL语句：`select * from table where x1=xx or x2>=xx`，这个SQL语句要查一个表，用 了x1和x2两个字段，此时有人可能会说了，要是你对x1和x2建了一个联合索引，那不就直接可以通过 索引去扫描了？

但是万一要是你建的索引是两个呢？比如(x1,x3)，(x2,x4)，你建了两个联合索引，此时你这个SQL只能 选择其中一个索引去用，此时会选择哪个呢？这里MySQL负责生成执行计划的查询优化器，**一般会选择 在索引里扫描行数比较少的那个条件**。

比如说x1=xx，在索引里只要做等值比较，扫描数据比较少，那么可能就会挑选x1的索引，做一个索引 树的查找，在执行计划里，其实就是一个ref的方式，找到几条数据之后，接着做一个回表，回到聚簇索 引里去查出每条数据完整数据，接着加载到内存里，根据每条数据的x2字段的值，根据`x2>=xx`条件做 一个筛选。

这就是面对两个字段都能用索引的时候如何选择，以及如何进行处理的方式。

接着我们再来考虑另外一种情况，就是：`select * from table where x1=xx and c1=xx and c2>=xx and c3 IS NOT NULL`

其实我们平时经常会写出来类似这样的SQL语句，就是在一个SQL的所有筛选条件里，就一个x1是有索 引的，其他字段都是没有索引的。 这种情况其实也是非常常见的，一般我们在写好一个系统之后，针对所有的SQL分析时，当然不可能针 对所有的SQL里的每一个where里的字段都加一个索引，那是不现实的，最终我们只能在所有的SQL语 句里，抽取部分经常在where里用到的字段来设计两三个联合索引。

所以在这种情况下，必然很多SQL语句里，可能where后的条件有好几个，结果就一个字段可以用到索 引的，此时查询优化器生成的执行计划，就会仅仅针对x1字段走一个ref访问，直接通过x1字段的索引 树快速查找到指定的一波数据。

接着对这波数据都回表到聚簇索引里去，把每条数据完整的字段都查出来，然后都加载到内存里去。接 着就可以针对这波数据的c1、c2、c3字段按照条件进行筛选和过滤，最后 拿到的就是符合条件的数据 了。

所以你的x1索引的设计，必然尽可能是要让x1=xx这个条件在索引树里查找出来的数据量比较少，才能 保证后续的性能比较高。

# 执行计划2

今天我们来看一个比较奇特的SQL语句以及特殊的执行计划，之前我们都是说，一般一个SQL语句只能 用到一个二级索引，但是有一些特殊的情况下，可能会对一个SQL语句用到多个二级索引，这是怎么回 事呢？

比如有这么一个SQL：`select * from table where x1=xx and x2=xx`，然后x1和x2两个字段分别都有一个索引，其实也有一定的可能会让查询优化器生成一个执行计划，执行计划里，就先对x1字段的索引树 进行查找，查出一波数据，接着对x2的索引树查出一波数据，然后对两波数据，按照主键值做一个交 集。

这个交集就是符合两个条件的数据了，接着回表到聚簇索引去查完整数据就可以了。

但是其实之前我们对这种情况一直说的是，选择x1或者x2其中一个字段的索引，就查一个字段的索引， 找出一波数据，接着直接回表到聚簇索引查完整数据，然后根据另外一个字段的值进行过滤就可以了。

**那么到底什么情况下，会直接对两个字段的两个索引一起查，然后取交集再回表到聚簇索引呢**

也就是 什么情况下可能会对一个SQL执行的时候，一下子查多个索引树呢？其实很简单，大家可以思考一下。

假设就上面那个SQL语句吧，比如你x1和x2两个字段，如果你先查x1字段的索引，一下子弄出来上万条 数据，这上万条数据都回表到聚簇索引查完整数据，再根据x2来过滤，你有没有觉得效果不是太好？

那如果说同时从x2的索引树里也查一波数据出来，做一个交集，一下子就可以让交集的数据量变成几十 条，再回表查询速度就很快了。一般来说，查索引树速度都比较快，但是到聚簇索引回表查询会慢一 些。

所以如果同时查两个索引树取一个交集后，数据量很小，然后再回表到聚簇索引去查，此时会提升性 能。

但是如果要在一个SQL里用多个索引，那有很多硬性条件的要求，比如说如果有联合索引，你必须把联 合索引里每个字段都放SQL里，而且必须都是等值匹配；或者是通过主键查询+其他二级索引等值匹 配，也有可能会做一个多索引查询和交集。

其实大家看这个可能看的很迷惑，但是不用迷惑，其实你只要记住，在执行SQL语句的时候，有可能是 会同时查多个索引树取个交集，再回表到聚簇索引的，这个可能性是有的。大家只要记住这个结论就行 了，后续在分析真实执行计划的时候，我们会再提到这个。

# 执行计划3

之前讲了，有的时候可能会在一个SQL里同时用上多个索引，那么其实如果你在SQL里写了类似`x1=xx or x2=xx`的语句，也可能会用多个索引，只不过查多个大索引树之后，会取一个并集，而不是交集罢 了。

那么现在为止，我们要做一个小小的停顿和总结，就是现在大家已经知道写出来的SQL有哪些执行的方 式了

const、ref、range，都是性能最好的方式，说明在底层直接基于某个索引树快速查找了数据 了，但有的时候可能你在用了索引之后，还会在回表到聚簇索引里查完整数据，接着根据其他条件来过 滤。

然后index方式其实是扫描二级索引的意思，就是说不通过索引树的根节点开始快速查找，而是直接对 二级索引的叶子节点遍历和扫描，这种速度还是比较慢的，大家尽量还是别出现这种情况。

当然index方式怎么也比all方式好一些，all就是直接全表扫描了，也就是直接扫描聚簇索引的叶子节 点，那是相当的慢，index虽然扫描的是二级索引的叶子节点，但是起码二级索引的叶子节点数据量比 较小，相对all要快一些。

然后之前给大家说的可能一个SQL里用多个索引，意思就是可能对多个索引树进行查找，接着用 intersection交集、union并集的方式来进行合并，此时可能给你在执行计划里也会看到这些字样

那你 起码这里要知道是怎么回事，其实他就是告诉你，他查找了多个索引，做了一些结果集的交集或者是并 集，而且这种方式也不一定是会发生的。

# 多表关联

今天先来给大家讲解一个超级简单，最最基础的多表关联查询的执行原理，假设我们有一个SQL语句 是：

`select * from t1,t2 where t1.x1=xxx and t1.x2=t2.x2 and t2.x3=xxx`

首先，如果你在FROM字句后直接来了两个表名，这意思就是要针对两个表进行查询了，而且会把两个 表的数据给关联起来，假设你要是没有限定什么多表连接条件，那么可能会搞出一个笛卡尔积的东西。

举个例子，假设t1表有10条数据，t2表有5条数据，那么此时`select * from t1,t2`，其实会查出来50条数 据，因为t1表里的每条数据都会跟t2表里的每条数据连接起来返回给你

那么不就是会查出来`10 * 5 =50`条数据吗？这就是笛卡尔积

不过通常一般没人会傻到写类似这样的SQL语句，因为查出来这种数据实在是没什么意义。所以通常都 会在多表关联语句中的WHERE子句里引入一些关联条件，那么我们回头看看之前的SQL语句里的 WHERE子句：

`where t1.x1=xxx and t1.x2=t2.x2 and t2.x3=xxx`

首先呢，`t1.x1=xxx`，这个可以明确，绝对不是多表关联的连接条件，他是针对t1表的数据筛选条件， 本质就是从t1表里筛选一波数据出来再跟t2表做关联的意思

然后`t2.x3=xxx`，也不是关联条件，他也是 针对t2表的筛选条件。 其实真正的关联条件是`t1.x2=t2.x2`，这个条件，意思就是说，必须要让t1表里的每条数据根据自己的x2 字段的值去关联上t2表里的某条记录，要求是t1表里这条数据的x2值和t2表里的那条数据的x2字段值是 相等的。

举个例子，假设t1表里有1条数据的x2字段的值是265，然后t2表里有2条数据的x2字段的值也是265， 那么此时就会把t1表里的那条数据和t2表的2条数据分别关联起来，最终会返回给你两条关联后的数 据。

那么基本概念理解清楚了，具体到上面的SQL语句：

`select * from t1,t2 where t1.x1=xxx and t1.x2=t2.x2 and t2.x3=xxx`

其实这个SQL执行的过程可能是这样的，首先根据`t1.x1=xxx`这个筛选条件，去t1表里查出来一批数据， 此时可能是const、ref，也可能是index或者all，都有可能，具体看你的索引如何建的，他会挑一种执 行计划访问方式

然后假设从t1表里按照`t1.x1=xxx`条件筛选出2条数据，接着对这两条数据，根据每条数据的x2字段的 值，以及`t2.x3=xxx`这个条件，去t2表里找x2字段值和x3字段值都匹配的数据，比如说t1表第一条数据 的x2字段的值是265，此时就根据`t2.x2=265`和`t2.x3=xxx`这俩条件，找出来一波数据，比如找出来2条 吧。

此时就把t1表里x2字段为265的那个数据跟t2表里`t2.x2=265`和`t2.x3=xxx`的两条数据，关联起来，就可 以了，t1表里另外一条数据也是如法炮制而已，这就是多表关联最最基本的原理。

记住，他可能是先从一个表里查一波数据，这个表叫做“驱动表”，再根据这波数据去另外一个表里查一 波数据进行关联，另外一个表叫做“被驱动表”

# 成本优化

MySQL是如何对一个查询语句的多个执行 计划评估他的成本的

如何根据成本评估选择一个成本最低的执行计划，保证最佳的查询速度？

我们先了解一下MySQL里的成本是什么意思，简单来说，跑一个SQL语句，一般成本是两块，首先是那 些数据如果在磁盘里，你要不要从磁盘里把数据读出来？这个从磁盘读数据到内存就是IO成本，而且 MySQL里都是一页一页读的，读一页的成本的约定为1.0。

然后呢，还有一个成本，那就是说你拿到数据之后，是不是要对数据做一些运算？比如验证他是否符合 搜索条件了，或者是搞一些排序分组之类的事，这些都是耗费CPU资源的，属于CPU成本，一般约定读 取和检测一条数据是否符合条件的成本是0.2.

这个所谓1.0和0.2就是他自定义的一个成本值，代表的意思就是一个数据页IO成本就是1.0，一条数据检 测的CPU成本就是0.2，就这个意思罢了。

然后呢，当你搞一个SQL语句给MySQL的时候，比如：

`select * from t where x1=xx and x2=xx`

此时你有两个索引，分别是针对x1和x2建立的，就会先看看这个SQL可以用到哪几个索引，此时发现x1 和x2的索引都能用到，他们俩索引就是possible keys。

接着会针对这个SQL计算一下全表扫描的成本，这个全表扫描的话就比较坑了，因为他是需要先磁盘IO 把聚簇索引里的叶子节点上的数据页一页一页都读到内存里，这有多少数据页就得耗费多少IO成本，接 着对内存里的每一条数据都判断是否符合搜索条件的，这有多少条数据就要耗费多少CPU成本

所以说，此时就得计算一下这块成本有多少，怎么算呢？简单，教大家一个命令：

`show table status like "表名"`

可以拿到你的表的统计信息，你在对表进行增删改的时候，MySQL会给你维护这个表的一些统计信息， 比如这里可以看到rows和`data_length`两个信息，不过对于innodb来说，这个rows是估计值。

rows就是表里的记录数，`data_length`就是表的聚簇索引的字节数大小，此时用`data_length`除以1024 就是kb为单位的大小，然后再除以16kb（默认一页的大小），就是有多少页，此时知道数据页的数量 和rows记录数，就可以计算全表扫描的成本了。

IO成本就是：数据页数量 * 1.0 + 微调值

CPU成本就是：行记录数 * 0.2 + 微调值，他们俩相加，就是一个总的成本值，比如你有数据页100个，记录数有2万条，此时总成本值大致就是100 + 4000 = 4100，在这个左右

**这个使用索引访问数据的方式**

大家应该都还记得，其实很简单，除非你直接根据主键查，那就直接走 一个聚簇索引就ok了，否则普通索引，一般都是两步走，先从二级索引查询一波数据，再根据这波数据 的主键去聚簇索引回表查询。

这个过程的成本计算方法稍微有点特别，首先，在二级索引里根据条件查一波数据的IO成本，一般是看 你的查询条件涉及到几个范围，比如说name值在25~100，250~350两个区间，那么就是两个范围，否 则name=xx就仅仅是一个范围区间。

一般一个范围区间就粗暴的认为等同于一个数据页，所以此时可能一般根据二级索引查询的时候，这个 IO成本都会预估的很小，可能就是`1 * 1.0 = 1`，或者是`n * 1.0 = n`，基本就是个位数这个级别。

但是到此为止，还仅仅是通过IO读取了二级索引的数据页而已，这仅仅是二级索引读取的IO成本，但是 二级索引数据页到内存里以后，还得根据搜索条件去拿出来一波数据，拿这波数据的过程就是根据搜索 条件在二级索引里搜索的过程。

此时就要估算从二级索引里读取符合条件的数据的成本了，这需要估算一下在二级索引里会查出多少条 数据，这个过程就稍微有点复杂了，不细讲了，总之呢，他会根据一个不是怎么太准确的算法去估算一 下根据查询条件可能会在二级索引里查出多少条数据来。

估算出来之后，比如估算可能会查到100条数据，此时从二级索引里查询数据的CPU成本就是`100 * 0.2` + 微调值，总之就是20左右而已。

接着你拿到100条数据之后，就得回表到聚簇索引里去查询完整数据，此时先估算回表到聚簇索引的IO 成本，这里比较粗暴的直接默认1条数据就得回表到聚簇索引查询一个数据页，所以100条数据就是100 个数据页的IO成本，也就是`100 * 1.0` + 微调值，大致是100左右。

接着因为在二级索引里搜索到的数据是100条，然后通过IO成本最多回表到聚簇索引访问100个数据页 之后，就可以拿到这100条数据的完整值了，此时就可以针对这100条数据去判断，他们是否符合其他 查询条件了，这里耗费的CPU成本就是`100 * 0.2` + 微调值，就是20左右。

把上面的所有成本都加起来，就是1 + 20 + 100 + 20 = 141，这就是使用一个索引进行查询的成本的计 算方法，其实大家看明白这个过程了，那么每一个索引的成本计算过程就都明了了

假设你直接根据主键查询，那么也参考上述估算过程就可以了，那就不过是仅仅查询一个聚簇索引罢了。 

总之，上次讲到全表扫描发现成本是4100左右，这次根据索引查找可能就141，所以，很多时候，使用 索引和全表扫描，他的成本差距是非常之大的。所以一般就会针对全表扫描和各个索引的成本，都进行 估算，然后比较一下，选择一个成本最低的执行计划。

**那今天一起看看多表关 联查询是如何选择执行计划的**

其实多表查询的执行计划选择思路，基本跟单表查询的执行计划选择思路是类似的，因为大家应该都记 得，单表查询的时候，主要就是对这个表的多种访问方式（全表查询 ，各个索引查询）来根据一定的公 式计算出来每种访问方式的成本，接着选择一个成本最低的访问方式，那么就可以确定下来这个表怎么 访问了。

可能有的人看了之前的两讲，会觉得似乎这种成本计算的方式也不是太靠谱，因为里面有些过程感觉怪 怪的，不过这个没办法，其实即使让你来设计，也很难设计出完全公平、完全精准的成本预估算法来

因为要在一个查询执行之前，就可以针对不同的访问方法精准计算他的成本，那是根本不现实的，最后 只能是根据一些相对较为简单粗暴的办法，大致估算一下，估算结果可能不是太准确，但是也没办法 了，反正算出来也就这么比较就是了。

那么接着如果我们要看看多表关联的成本计算访问和执行计划选择方式，那就很简单了，因为大家应该 还记得，多表关联的语句，比如：

`select * from t1 join t2 on t1.x1=t2.x1 where t1.x2=xxx and t1.x3=xxx and t2.x4=xxx and t2.x5=xxx`

就这么一个语句，大家应该还记得他里面的访问过程

一般来说，都会先选择一个驱动表，比如t1作为驱动表，此时就需要根据`t1.x2=xxx`和`t1.x3=xxx`这个条 件从表里查询一波符合条件的数据出来，此时就有一个问题了，这里用到了t1的两个字段来筛选数据， 可能x2和x3字段都建了索引了，此时到底选择哪个索引呢？或者干脆直接就是全表扫描？

此时就会按照之前讲的那套方法来计算针对t1表查询的全表扫描和不同索引的成本，选择一个针对t1表 的最佳访问方式，用最低成本从t1表里查出符合条件的数据来，接着就根据这波数据得去t2表里查数 据，按照连接条件`t1.x1=t2.x1`去查，同时要符合`t2.x4=xxx`和`t2.x5=xxx`这两个条件。

此时一样会根据之前讲解的办法去估算，针对t2表的全表扫描以及基于x4、x5、x1几个字段不同索引的 访问的成本，挑选一个成本最低的方法，然后从t2表里把数据给查找出来，就可以，这就完成了多表关 联！ 

所以大家可以看到，其实多表关联的成本估算以及执行计划选择方式，跟单表关联基本上是差不多的， 只不过多表关联要多查几个表罢了。

# 规则优化

首先呢，要是MySQL觉得你的SQL里有很多括号，那么无关紧要的括号他会给你删除了，其次比如你有 类似于`i = 5 and j > i`这样的SQL，就会改写为`i = 5 and j > 5`，做一个常量替换。

还有比如`x = y and y = k and k = 3`这样的SQL，都会给你优化成`x = 3 and y = 3 and k = 3`，本质也是做 个常量替换。或者是类似于什么`b = b and a = a`这种一看就是乱写的SQL，一看就是没意义的，就直接 给你删了。

大家可能觉得很琐碎，其实不是的，这些SQL的改写，你会发现，他本质都是在优化SQL语句的清晰语 义，方便后续在索引和数据页里进行查找。

还有一些是比较有意思的改写，比如下面的SQL语句：

`select * from t1 join t2 on t1.x1=t2.x1 and t1.id=1`

这个SQL明显是针对t1表的id主键进行了查询，同时还要跟t2表进行关联，其实这个SQL语句就可能在 执行前就先查询t1表的id=1的数据，然后直接做一个替换，把SQL替换为：

`select t1表中id=1的那行数据的各个字段的常量值, t2.* from t1 join t2 on t1表里x1字段的常量值 =t2.x1`

上面的SQL就是直接把t1相关的字段都替换成了提前查出来的id=1那行数据的字段常量值了

**今天我们来讲一下子查询是如何执行的，以及他的执行计划是如何优化的。**

比如说类似于下面的 SQL语句：

`select * from t1 where x1 = (select x1 from t2 where id=xxx)`

这就是一个典型的子查询

也就是说上面的SQL语句在执行的时候，其实会被拆分为两个步骤：

第一个步骤先执行子查询，也就 是：`select x1 from t2 where id=xxx`，直接根据主键定位出一条数据的x1字段的值

接着再执行`select * from t1 where x1=子查询的结果值`，这个SQL语句。

这个第二个SQL执行，其实也无非就是跟之前讲的单表查询的方式是一样的，其实大家看到最后会发 现，这个SQL语句最核心的就是单表查询的几种执行方式，其他的多表关联，子查询，这些都是差不多 这个意思。

最多就是在排序、分组聚合的时候，可能有的时候会直接用上索引，有的时候用不上索引就会基于内存 或者临时磁盘文件执行。

> 另外还有一种子查询，就是：

`select * from t1 where x1 = (select x1 from t2 where t1.x2=t2.x2)`

这种时候，你会发现子查询里的where条件依赖于t1表的字段值，所以这种查询就会效率很低下，他需 要遍历t1表里每一条数据，对每一条数据取出x2字段的值，放到子查询里去执行，找出t2表的某条数据 的x1字段的值，再放到外层去判断，是否符合跟t1表的x1字段匹配。

**今天我们重点来讲一下IN语句结合子查询的一个优化手段，假设有如下的一个SQL语句：**

`select * from t1 where x1 in (select x2 from t2 where x3=xxx)`

这个SQL语句就是典型的一个子查询运用，子查询查一波结果，然后判断t1表哪些数据的x1值在这个结 果集里。

这个可能大家会想当然的认为先执行子查询，然后对t1表再进行全表扫描，判断每条数据是否在这个子 查询的结果集里，但是这种方式其实效率是非常低下的

所以其实对于上述的子查询，执行计划会被优化为，先执行子查询，也就是`select x2 from t2 where x3=xxx`这条SQL语句，把查出来的数据都写入一个临时表里，也可以叫做**物化表**，意思就是说，把这个 中间结果集进行物化。

这个物化表可能会基于memory存储引擎来通过内存存放，如果结果集太大，则可能采用普通的b+树聚 簇索引的方式放在磁盘里。但是无论如何，这个物化表都会建立索引，所以大家要清楚，这波中间结果 数据写入物化表是有索引的。

接着大家可能会想，此时是不是全表扫描t1表，对每条数据的x1值都去物化表里根据索引快速查找一下 是否在这个物化表里？如果是的话，那么就符合条件了。但是这里还有一个优化的点，那就是他可以反 过来思考。

也就是说，假设t1表的数据量是10万条，而物化表的数据量只有500条，那么此时完全可以改成全表扫 描物化表，对每个数据值都到t1表里根据x1这个字段的索引进行查找，查找物化表的这个值是否在t1表 的x1索引树里，如果在的话，那么就符合条件了。

所以基于IN语句的子查询执行方式，实际上会在底层被优化成如上所述

**今天我们来给大家讲解MySQL里对子查询的执行计划进行优化的一种方式，就是semi join，也就是半 连接**

这个半连接是什么意思呢，其实就是假设你有一个子查询语句：

`select * from t1 where x1 in (select x2 from t2 where x3=xxx)`

此时其实可能会在底层把他转化为一个半连接，有点类似于下面的样子：

`select t1.* from t1 semi join t2 on t1.x1=t2.x2 and t2.x3=xxx`

当然，其实并没有提供semi join这种语法，这是MySQL内核里面使用的一种方式，上面就是给大家说 那么个意思，其实上面的semi join的语义，是和IN语句+子查询的语义完全一样的，他的意思就是说， 对于t1表而言，只要在t2表里有符合`t1.x1=t2.x2`和`t2.x3=xxx`两个条件的数据就可以了，就可以把t1表 的数据筛选出来了。


