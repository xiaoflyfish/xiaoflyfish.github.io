---
title: 锁机制
categories: 
- 学习笔记
- MySQL1
---

# 脏写

脏写是绝对不允许的，那么这个脏写是靠什么防止的呢

说白了，就是靠锁机制，依靠锁机制让多个事务更新一行数据的时候串行化，避免同时更新一行数据

在MySQL里，假设有一行数据摆在那儿不动，此时有一个事务来了要更新这行数据，这个时候他会先琢 磨一下，看看这行数据此时有没有人加锁？

一看没人加锁，太好了，说明他是第一个人，捷足先登了。

此时这个事务就会创建一个锁，里面包含了自己的`trx_id`和等待状态，然后把锁跟这行数据关联在一 起。

同时大家应该还记得，更新一行数据必须把他所在的数据页从磁盘文件里读取到缓存页里来才能更新 的，所以说，此时这行数据和关联的锁数据结构，都是在内存里的，大家要明确这一点

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303200459.png" style="zoom:25%;" />

大家注意看上面的那个图，因为事务A给那行数据加了锁，所以此时就可以说那行数据已经被加锁了

那么既然被加锁了，此时就不能再让别人访问了

现在呢，有另外一个事务B过来了，这个事务B就也想更新那行数据，此时就会检查一下，当前这行数据 有没有别人加锁

然而他一下子发现，真是糟糕啊，事务A这家伙太不地道了，居然抢先给这行数据加锁了，这怎么办 呢？

事务B这个时候一想，那行，我也加个锁，然后等着排队不就得了，这个时候事务B也会生成一个锁数据 结构，里面有他的`trx_id`，还有自己的等待状态，但是他因为是在排队等待，所以他的等待状态就是 true了，意思是我在等着呢

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303200609.png" style="zoom:25%;" />

接着事务A这个时候更新完了数据，就会把自己的锁给释放掉了。锁一旦释放了，他就会去找，此时还 有没有别人也对这行数据加锁了呢？他会发现事务B也加锁了

于是这个时候，就会把事务B的锁里的等待状态修改为false，然后唤醒事务B继续执行，此时事务B就获 取到锁了

# 共享锁和独占锁

其实多个事 务同时更新一行数据，此时都会加锁，然后都会排队等待，必须一个事务执行完毕了，提交了，释放了 锁，才能唤醒别的事务继续执行。 

那么在这多个事务运行的时候，他们加的是什么锁呢？ 其实是X锁，也就是Exclude独占锁，当有一个事务加了独占锁之后，此时其他事务再要更新这行数据， 都是要加独占锁的，但是只能生成独占锁在后面等待。 

**那么这个时候我想问大家一个问题，当有人在更新数据的时候，其他的事务可以读取这行数据吗**

默认 情况下需要加锁吗？ 答案是：不用，因为默认情况下，有人在更新数据的时候，然后你要去读取这行数据，直接默认就是开启mvcc机制 的。 

也就是说，此时对一行数据的读和写两个操作默认是不会加锁互斥的，因为MySQL设计mvcc机制就是 为了解决这个问题，避免频繁加锁互斥。 此时你读取数据，完全可以根据你的ReadView，去在undo log版本链条里找一个你能读取的版本，完 全不用去顾虑别人在不在更新。 就算你真的等他更新完毕了还提交了，基于mvcc机制你也读不到他更新的值啊！因为ReadView机制是 不允许的，所以你默认情况下的读，完全不需要加锁，不需要去care其他事务的更新加锁问题，直接基 于mvcc机制读某个快照就可以了。 

那么假设万一要是你在执行查询操作的时候，就是想要加锁呢？ 那也是ok的，MySQL首先支持一种共享锁，就是S锁，这个共享锁的语法如下：`select * from table lock in share mode`，你在一个查询语句后面加上lock in share mode，意思就是查询的时候对一行数 据加共享锁。

如果此时有别的事务在更新这行数据，已经加了独占锁了，此时你的共享锁能加吗？ 当然不行了，共享锁和独占锁是互斥的！此时你这个查询就只能等着了。 

那么如果你先加了共享锁，然后别人来更新要加独占锁行吗？当然不行了，此时锁是互斥的，他只能等 待。 

那么如果你在加共享锁的时候，别人也加共享锁呢？此时是可以的，你们俩都是可以加共享锁的，共享 锁和共享锁是不会互斥的。 

所以这里可以先看出一个规律，就是更新数据的时候必然加独占锁，独占锁和独占锁是互斥的，此时别 人不能更新；但是此时你要查询，默认是不加锁的，走mvcc机制读快照版本，但是你查询是可以手动 加共享锁的，共享锁和独占锁是互斥的，但是共享锁和共享锁是不互斥的，如下规律

| 锁类型 | 独占锁 | 共享锁 |
| ------ | ------ | ------ |
| 独占锁 | 互斥   | 互斥   |
| 共享锁 | 互斥   | 不互斥 |

不过说实话，一般开发业务系统的时候，其实你查询主动加共享锁，这种情况较为少见，数据库的行锁 是实用功能，但是一般不会在数据库层面做复杂的手动加锁操作，反而会用基于redis/zookeeper的分 布式锁来控制业务系统的锁逻辑。

另外就是，查询操作还能加互斥锁，他的方法是：`select * from table for update`。

这个意思就是，我查出来数据以后还要更新，此时我加独占锁了，其他闲杂人等，都不要更新这个数据 了。

一旦你查询的时候加了独占锁，此时在你事务提交之前，任何人都不能更新数据了，只能你在本事务里 更新数据，等你提交了，别人再更新数据。

# 表级锁

在多个事务并发更新数据的时候，都是要在行级别加独占锁的，这就是行锁，独占锁都是互斥的，所以 不可能发生脏写问题，一个事务提交了才会释放自己的独占锁，唤醒下一个事务执行。

**如果你此时去读取别的事务在更新的数据，有两种可能：**

第一种可能是基于mvcc机制进行事务隔离，读取快照版本，这是比较常见的； 

第二种可能是查询的同时基于特殊语法去加独占锁或者共享锁。

如果你查询的时候加独占锁，那么跟其他更新数据的事务加的独占锁都是互斥的；如果你查询的时候加 共享锁，那么跟其他查询加的共享锁是不互斥的，但是跟其他事务更新数据就加的独占锁是互斥的，跟 其他查询加的独占锁也是互斥的。

当然一般我个人从多年研发经验而言，不是太建议在数据库粒度去通过行锁实现复杂的业务锁机制，而 更加建议通过redis、zookeeper来用分布式锁实现复杂业务下的锁机制，其实更为合适一些。

为什么呢？因为如果你把分布式系统里的复杂业务的一些锁机制依托数据库查询的时候，在SQL语句里 加共享锁或者独占锁，会导致这个加锁逻辑隐藏在SQL语句里，在你的Java业务系统层面其实是非常的 不好维护的，所以一般是不建议这么做的。

比较正常的情况而言，其实还是多个事务并发运行更新一条数据，默认加独占锁互斥，同时其他事务读 取基于mvcc机制进行快照版本读，实现事务隔离。

在数据库里，你不光可以通过查询中的特殊语法加行锁，比如lock in share mode、for update等等， 还可以通过一些方式在表级别去加锁。 有些人可能会以为当你执行增删改的时候默认加行锁，然后**执行DDL语句的时候，比如alter table之类 的语句，会默认在表级别加表锁**。这么说也不太正确，但是也有一定的道理，因为确实你执行DDL的时 候，会阻塞所有增删改操作；执行增删改的时候，会阻塞DDL操作。

但这是通过MySQL通用的**元数据锁**实现的，也就是Metadata Locks，但这还不是表锁的概念。因为表 锁其实是InnoDB存储引擎的概念，InnoDB存储引擎提供了自己的表级锁，跟这里DDL语句用的元数据 锁还不是一个概念。

只不过DDL语句和增删改操作，确实是互斥的，大家要知道这一点
