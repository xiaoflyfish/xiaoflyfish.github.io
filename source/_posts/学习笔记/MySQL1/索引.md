---
title: 索引
categories: 
- 学习笔记
- MySQL1
---

# 磁盘数据页

大家都知道，数据库最终所有的数据（包括我们建的各种表以及表里的数据）都是要存放在磁 盘上的文件里的，然后在文件里存放的物理格式就是数据页，那么大量的数据页在磁盘文件里是怎么存 储的呢

首先大家要明白的一点是，大量的数据页是按顺序一页一页存放的，然后两两相邻的数据页之间会采用 双向链表的格式互相引用

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303223330.png" style="zoom:25%;" />

其实一个数据页在磁盘文件里就是一段数据，可能是二进制或者别的特殊格式的数据，然后数据页里包 含两个指针，一个指针指向自己上一个数据页的物理地址，一个指针指向自己下一个数据页的物理地 址，大概可以认为类似下面这样

```
DataPage: xx=xx, xx=xx, linked_list_pre_pointer=15367, linked_list_next_pointer=34126 || 
DataPage: xx=xx, xx=xx, linked_list_pre_pointer=23789, linked_list_next_pointer=46589 || 
DataPage: xx=xx, xx=xx, linked_list_pre_pointer=33198, linked_list_next_pointer=55681
```

上面那段示例数据，当然不能完全认为是MySQL数据库的磁盘文件里的存储格式，但是我这里就是给你 看一些类似的东西，其实MySQL实际存储大致也是类似这样的，就是每个数据页在磁盘文件里都是连续 的一段数据。

然后每个数据页里，可以认为就是DataPage打头一直到 || 符号的一段磁盘里的连续的数据，你可以认 为每一个数据页就是磁盘文件里这么一段连续的东西。

然后每个数据页，都有一个指针指向自己上一个数据页在磁盘文件里的起始物理位置，比如 `linked_list_pre_pointer=15367`，就是指向了上一个数据页在磁盘文件里的起始物理位置，那个15367 可以认为就是在磁盘文件里的position或者oﬀset，同理，也有一个指针指向自己下一个数据页的物理 位置。

现在你再回头看一下上面那个图，是不是就理解了一个磁盘文件里的多个数据页是如何通过指针组成一 个双向链表的！

然后一个数据页内部会存储一行一行的数据，也就是平时我们在一个表里插入的一行一行的数据就会存 储在数据页里，然后数据页里的每一行数据都会按照主键大小进行排序存储，同时每一行数据都有指针 指向下一行数据的位置，组成单向链表

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303223538.png" style="zoom:25%;" />

**假设没有任何索引，数据库是如何根据查询语句搜索数据的**

每个数据页里都会有一个页目录，里面根据数据行的主键存放了一个目录，同时数据行是被分散存 储到不同的槽位里去的，所以实际上每个数据页的目录里，就是这个页里每个主键跟所在槽位的映射关 系

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303223721.png" style="zoom:25%;" />

所以假设你要根据主键查找一条数据，而且假设此时你数据库里那个表就没几条数据，那个表总共就一个数据页，那么就太简单了！首先就会先到数据页的页目录里根据主键进行二分查找

然后通过二分查找在目录里迅速定位到主键对应的数据是在哪个槽位里，然后到那个槽位里去，遍历槽 位里每一行数据，就能快速找到那个主键对应的数据了。每个槽位里都有一组数据行，你就是在里面遍 历查找就可以了。

> 但是假设你要是根据非主键的其他字段查找数据呢

那就尴尬了，此时你是没办法使用主键的那种页目录来二分查找的，只能进入到数据页里，根据单向链 表依次遍历查找数据了，这就性能很差了。

好，那么现在假如我们有很多数据页呢？ 对了，一个表里往往都是有大量数据的，可能有多达成百上千个数据页，这些数据页就存放在物理磁盘 文件里

所以此时是如何查询数据的呢

你一个表里所有数据页都是组成双向链表的吧？好，有链表就好办了，直接从第一个数据页开始遍历所 有数据页，从第一个数据页开始，你得先把第一个数据页从磁盘上读取到内存buﬀer pool的缓存页里 来。

然后你就在第一个数据页对应的缓存页里，按照上述办法查找，假设是根据主键查找的，你可以在数据 页的页目录里二分查找，假设你要是根据其他字段查找的，只能是根据数据页内部的单向链表来遍历查 找

> 那么假设假设第一个数据页没找到你要的那条数据呢

没办法，只能根据数据页的双向链表去找下一个数据页，然后读取到buﬀer pool的缓存页里去，然后按 一样的方法在一个缓存页内部查找那条数据。

如果依然还是查找不到呢

那只能根据双向链表继续加载下一个数据页到缓存页里来了，以此类推，循环往复。 不知道大家看到这个过程有什么感想没有？有没有觉得，你似乎是在做一个数据库里很尴尬的操作：全 表扫描

对了，其实上述操作过程，就是全表扫描，在你没有任何索引数据结构的时候，无论如何查找数据，说 白了都是一个全表扫描的过程，就是根据双向链表依次把磁盘上的数据页加载到缓存页里去，然后在一 个缓存页内部来查找那条数据。

最坏的情况下，你就得把所有数据页里的每条数据都得遍历一遍，才能找到你需要的那条数据，这就是 全表扫描！

# 页分裂

正常情况下我们在一个表里插入一些数据后，他们都会进入到一个数据页里去，在数据页 内部，他们会组成一个单向链表，这个数据页内部的单向链表大致如下所示

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303234450.png" style="zoom:25%;" />

看上面的图，里面就是一行一行的数据，刚开始第一行是个起始行，他的行类型是2，就是最小的 一行，然后他有一个指针指向了下一行数据，每一行数据都有自己每个字段的值，然后每一行通过一个 指针不停的指向下一行数据，普通的数据行的类型都是0，最后一行是一个类型为3的，就是代表最大的 一行。

上面就是一个典型的数据页内部的情况

是这样的，假设你不停的在表里插入数据，那么刚开始是不是就是不停的在一个数据页插入数据？接着 数据越来越多，越来越多，此时就要再搞一个数据页了

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303234529.png" style="zoom:25%;" />

后续我们会讲到索引这块机制，索引运作的一个核心基础就是要求你后一个 数据页的主键值都大于前面一个数据页的主键值，但是如果你的主键是自增的，那还可以保证这一点， 因为你新插入后一个数据页的主键值一定都大于前一个数据页的主键值。

但是有时候你的主键并不是自增长的，所以可能会出现你后一个数据页的主键值里，有的主键是小于前 一个数据页的主键值的。

比如在第一个数据页里有一条数据的主键是10，第二个数据页里居然有一条数据的主键值是8，那此时 肯定有问题了。

所以此时就会出现一个过程，叫做页分裂，就是万一你的主键值都是你自己设置的，那么在增加一个新 的数据页的时候，实际上会把前一个数据页里主键值较大的，挪动到新的数据页里来，然后把你新插入 的主键值较小的数据挪动到上一个数据页里去，保证新数据页里的主键值一定都比上一个数据页里的主 键值大。

大家看下图，假设新数据页里，有两条数据的主键值明显是小于上一个数据页的主键值的

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303234655.png" style="zoom:25%;" />

如上图所示，第一个数据页里有1、5、6三条数据，第二个数据页里有2、3、4三条数据，明显第二个 数据页里的数据的主键值比第一个数据页里的5和6两个主键都小，所以这个是不行的。

此时就会出现页分裂的行为，把新数据页里的两条数据挪动到上一个数据页，上一个数据页里挪两条数 据到新数据页里去

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303234733.png" style="zoom:25%;" />

所以上述就是一个页分裂的过程，核心目标就是保证下一个数据页里的主键值都比上一个数据页里的主 键值要大

# 主键索引

假设我们有多个数据页，然后我们想要根据主键来查询数据，那么直接查询的话也是不 行的，因为我们也不知道主键到底是在哪里，是不是

现在假设你要搜id=4的数据，你怎么知道在哪个数据页里？没有任何证据可以告诉你他到底是在哪个数 据页里啊！

所以假设还是这个样子的话，你也就只能全表扫描了，从第一个数据页开始，每个数据页都进入到页目 录里查找主键，最坏情况下，所有数据页你都得扫描一遍，还是很坑的。 所以其实此时就需要针对主键设计一个索引了，针对主键的索引实际上就是主键目录，这个主键目录 呢，就是把每个数据页的页号，还有数据页里最小的主键值放在一起，组成一个索引的目录

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303234944.png" style="zoom:25%;" />

现在我们有了上图的主键目录就方便了，直接就可以到主键目录里去搜索，比如你要找id=3的数据，此 时就会跟每个数据页的最小主键来比，首先id=3大于了数据页2里的最小主键值1，接着小于了数据页8 里的最小主键值4。

所以既然如此，你直接就可以定位到id=3的数据一定是在数据页2里的！

假设你有很多的数据页，在主键目录里就会有很多的数据页和最小主键值，此时你完全可以根据二分查 找的方式来找你要找的id到底在哪个数据页里！

所以这个效率是非常之高的，而类似上图的主键目录，就可以认为是主键索引。

而大家都知道我们的数据页都是一坨一坨的连续数据放在很多磁盘文件里的，所以只要你能够根据主键 索引定位到数据所在的数据页，此时假设我们有别的方式存储了数据页跟磁盘文件的对应关系，此时你 就可以找到一个磁盘文件。

而且我们假设数据页在磁盘文件里的位置也就是oﬀset偏移量，你也是可以知道的，此时就可以直接通 过随机读的方式定位到磁盘文件的某个oﬀset偏移量的位置，然后就可以读取连续的 一大坨数据页了！

# B+树

你的表里的数据可能很多很多，比如有几百万，几千万，甚至单表几亿条数据都是 有可能的，所以此时你可能有大量的数据页，然后你的主键目录里就要存储大量的数据页和最小主键 值，这怎么行呢？

所以在考虑这个问题的时候，实际上是采取了一种把索引数据存储在数据页里的方式来做的

也就是说，你的表的实际数据是存放在数据页里的，然后你表的索引其实也是存放在页里的，此时索引 放在页里之后，就会有索引页，假设你有很多很多的数据页，那么此时你就可以有很多的索引页

但是现在又会存在一个问题了，你现在有很多索引页，但是此时你需要知道，你应该到哪个索引页里去 找你的主键数据，是索引页20？还是索引页28？这也是个大问题

于是接下来我们又可以把索引页多加一个层级出来，在更高的索引层级里，保存了每个索引页和索引页 里的最小主键值

现在就好了，假设我们要查找id=46的，直接先到最顶层的索引页35里去找，直接通过二分查找可以定 位到下一步应该到索引页20里去找，接下来到索引页20里通过二分查找定位，也很快可以定位到数据应 该在数据页8里，再进入数据页8里，就可以找到id=46的那行数据了。

那么现在问题再次来了，假如你最顶层的那个索引页里存放的下层索引页的页号也太多了，怎么办呢？

此时可以再次分裂，再加一层索引页，比如下面图里那样子

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303235405.png" style="zoom:25%;" />

没错了，这就是一颗B+树，属于数据结构里的一种树形数据结构，所以一直说MySQL的索引是用B+树 来组成的，其实就是这个意思。

我们就以最简单最基础的主键索引来举例，当你为一个表的主键建立起来索引之后，其实这个主键的索 引就是一颗B+树，然后当你要根据主键来查数据的时候，直接就是从B+树的顶层开始二分查找，一层 一层往下定位，最终一直定位到一个数据页里，在数据页内部的目录里二分查找，找到那条数据。

这就是索引最真实的物理存储结构，采用跟数据页一样的页结构来存储，一个索引就是很多页组成的一 颗B+树。

# 聚簇索引

现在假设我们要搜索一个主键id对应的行，此时你就应该先去顶层的索引页88里去找，通过二 分查找的方式，很容易就定位到你应该去下层哪个索引页里继续找

比如现在定位到了下层的索引页35里去继续找，此时在索引页35里也有一些索引条目的，分别都是下层 各个索引页（20，28，59）和他们里面最小的主键值，此时在索引页35的索引条目里继续二分查找， 很容易就定位到，应该再到下层的哪个索引页里去继续找

这是基于索引数据结构去查找主键的一个过程，那么大家有没有发现一件事情，其实最下层的索引 页，都是会有指针引用数据页的，所以实际上索引页之间跟数据页之间是有指针连接起来的

同一层级内的索引页组成双向链表，就跟数据页自己组成双向链表是一样的

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303235845.png" style="zoom:25%;" />

不知道大家把上面的图连起来看，有没有发现一些特点，就是说假设你把索引页和数据页综合起来看， 他们都是连接在一起的，看起来就如同一颗完整的大的B+树一样，从根索引页88开始，一直到所有的 数据页，其实组成了一颗巨大的B+树。

在这颗B+树里，最底层的一层就是数据页，数据页也就是B+树里的叶子节点了！

所以，如果一颗大的B+树索引数据结构里，叶子节点就是数据页自己本身，那么此时我们就可以称这颗 B+树索引为聚簇索引！

也就是说，上图中所有的索引页+数据页组成的B+树就是聚簇索引！

其实在InnoDB存储引擎里，你在对数据增删改的时候，就是直接把你的数据页放在聚簇索引里的，数 据就在聚簇索引里，聚簇索引就包含了数据！比如你插入数据，那么就是在数据页里插入数据。 如果你的数据页开始进行页分裂了，他此时会调整各个数据页内部的行数据，保证数据页内的主键值都 是有顺序的，下一个数据页的所有主键值大于上一个数据页的所有主键值

同时在页分裂的时候，会维护你的上层索引数据结构，在上层索引页里维护你的索引条目，不同的数据 页和最小主键值。

然后如果你的数据页越来越多，一个索引页放不下了，此时就会再拉出新的索引页，同时再搞一个上层 的索引页，上层索引页里存放的索引条目就是下层索引页页号和最下主键值。

按照这个顺序，以此类推，如果你的数据量越大，此时可能就会多出更多的索引页层级来，不过说实 话，一般索引页里可以放很多索引条目，所以通常而言，即使你是亿级的大表，基本上大表里建的索引 的层级也就三四层而已。

这个聚簇索引默认是按照主键来组织的，所以你在增删改数据的时候，一方面会更新数据页，一方面其 实会给你自动维护B+树结构的聚簇索引，给新增和更新索引页，这个聚簇索引是默认就会给你建立的。

# 二级索引

假设你要是针对其他字段建立索引，比如name、age之类的字段，这都是一样的原理，简单来 说，比如你插入数据的时候，一方面会把完整数据插入到聚簇索引的叶子节点的数据页里去，同时维护 好聚簇索引，另一方面会为你其他字段建立的索引，重新再建立一颗B+树。

比如你基于name字段建立了一个索引，那么此时你插入数据的时候，就会重新搞一颗B+树，B+树的叶 子节点也是数据页，但是这个数据页里仅仅放主键字段和name字段

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304000447.png" style="zoom:25%;" />

大家注意，这可是独立于聚簇索引之外的另外一个索引B+树了，严格来说是name字段的索引B+树，所 以在name字段的索引B+树里，叶子节点的数据页里仅仅放主键和name字段的值，至于排序规则之类 的，都是跟以前说的一样的。

也就是说，name字段的索引B+树里，叶子节点的数据页中的name值都是按大小排序的，同时下一个 数据页里的name字段值都大于上一个数据页里的name字段值，这个整体的排序规则都跟聚簇索引按 照主键的排序规则是一样的。

然后呢，name字段的索引B+树也会构建多层级的索引页，这个索引页里存放的就是下一层的页号和最 小name字段值，整体规则都是一样的，只不过存放的都是name字段的值，根据name字段值排序罢 了

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304000536.png" style="zoom:25%;" />

所以假设你要根据name字段来搜索数据，那搜索过程简直都一样了，不就是从name字段的索引B+树 里的根节点开始找，一层一层往下找，一直找到叶子节点的数据页里，定位到name字段值对应的主键值。 然后呢

此时针对`select * from table where name='xx'`这样的语句，你先根据name字段值在name字段的索引B+树里找，找到叶子节点也仅仅可以找到对应的主键值，而找不到这行数据完整的所有字段。

所以此时还需要进行“回表”，这个回表，就是说还需要根据主键值，再到聚簇索引里从根节点开始，一 路找到叶子节点的数据页，定位到主键对应的完整数据行，此时才能把`select *`要的全部字段值都拿出 来。

因为我们根据name字段的索引B+树找到主键之后，还要根据主键去聚簇索引里找，所以一般把name 字段这种普通字段的索引称之为二级索引，一级索引就是聚簇索引，这就是普通字段的索引的运行原 理。

其实我们也可以把多个字段联合起来，建立联合索引，比如name+age

此时联合索引的运行原理也是一样的，只不过是建立一颗独立的B+树，叶子节点的数据页里放了 id+name+age，然后默认按照name排序，name一样就按照age排序，不同数据页之间的name+age值 的排序也如此。

然后这个name+age的联合索引的B+树的索引页里，放的就是下层节点的页号和最小的name+age的 值，以此类推，所以当你根据name+age搜索的时候，就会走name+age联合索引的这颗B+树了，搜索 到主键，再根据主键到聚簇索引里去搜索。

# 插入数据

根页里存放的数据页索引条目越来越多，连你的索引页都放不下了， 那你就让一个索引页分裂成两个索引页，然后根页继续往上走一个层级引用了两个索引页

你的数据页越来越多，那么根页指向的索引页也会不停分裂，分裂出更多的索引 页，当你下层的索引页数量太多的时候，会导致你的根页指向的索引页太多了，此时根页继续分裂成多 个索引页，根页再次往上提上去去一个层级

其实就是你增删改的时候，整个聚簇索引维护的一个过程，其实其他的二级索引也是类似的一个原理

比如你name字段有一个索引，那么刚开始的时候你插入数据，一方面在聚簇索引的唯一的数据页里插 入，一方面在name字段的索引B+树唯一的数据页里插入。

然后后续数据越来越多了，你的name字段的索引B+树里唯一的数据页也会分裂，所以你插入数据的时候，本身就会自动去维护你的各个索引的B+树。

另外给大家补充一点，你的name字段的索引B+树里的索引页中，其实除了存放页号和最小name字段 值以外，每个索引页里还会存放那个最小name字段值对应的主键值

这是因为有时候会出现多个索引页指向的下层页号的最小name字段值是一样的，此时就必须根据主键 判断一下。

比如你插入了一个新的name字段值，此时他需要根据name字段的B+树索引的根页面开始，去逐层寻 找和定位自己这个新的name字段值应该插入到叶子节点的哪个数据页里去

此时万一遇到一层里不同的索引页指向不同的下层页号，但是name字段值一样，此时就得根据主键值 比较一下。

新的name字段值肯定是插入到主键值较大的那个数据页里去的

**一个表里是不是索引搞的越多越好**

我们都知道，正常我们在一个表里灌入数据的时候，都会基于主键给我们自动建立聚簇索引

随着我们不停的在表里插入数据，他就会不停的在数据页里插入数据，然后一个数据页放满了就会分裂 成多个数据页，这个时候就需要索引页去指向各个数据页

然后如果数据页太多了，那么索引页里里的数据页指针也就会太多了，索引页也必然会放满的，此时索 引页也会分裂成多个，再形成更上层的索引页。

默认情况下MySQL给我们建立的聚簇索引都是基于主键的值来组织索引的，聚簇索引的叶子节点都是数 据页，里面放的就是我们插入的一行一行的完整的数据了！

在一个索引B+树中，他有一些特性，那就是数据页/索引页里面的记录都是组成一个单向链表的，而且 是按照数据大小有序排列的；然后数据页/索引页互相之间都是组成双向链表的，而且也都是按照数据 大小有序排列的，所以其实B+树索引是一个完全有序的数据结构，无论是页内还是页之间

正是因为这个有序的B+树索引结构，才能让我们查找数据的时候，直接从根节点开始按照数据值大小一 层一层往下找，这个效率是非常高的。

然后如果是针对主键之外的字段建立索引的话，实际上本质就是为那个字段的值重新建立另外一颗B+树 索引，那个索引B+树的叶子节点，存放的都是数据页，里面放的都是你字段的值和主键值，然后每一层 索引页里存放的都是下层页的引用，包括页内的排序规则，页之间的排序规则，B+树索引的搜索规则， 都是一样的。

但是唯一要清晰记住的一点是，假设我们要根据其他字段的索引来搜索，那么只能基于其他字段的索引 B+树快速查找到那个值所对应的主键，接着再次做回表查询，基于主键在聚簇索引的B+树里，重新从 根节点开始查找那个主键值，找到主键值对应的完整数据。

> 索引当然有缺点了，主要是两个缺点，一个是空间上的，一个是时间上的。

空间上而言，你要是给很多字段创建很多的索引，那你必须会有很多棵索引B+树，每一棵B+树都要占 用很多的磁盘空间啊！所以你要是搞的索引太多了，是很耗费磁盘空间的。

其次，你要是搞了很多索引，那么你在进行增删改查的时候，每次都需要维护各个索引的数据有序性， 因为每个索引B+树都要求页内是按照值大小排序的，页之间也是有序的，下一个页的所有值必须大于上 一个页的所有值！

所以你不停的增删改查，必然会导致各个数据页之间的值大小可能会没有顺序，比如下一个数据页里插 入了一个比较小的值，居然比上一个数据页的值要小！此时就没办法了，只能进行数据页的挪动，维护 页之间的顺序。

或者是你不停的插入数据，各个索引的数据页就要不停的分裂，不停的增加新的索引页，这个过程都是 耗费时间的。 所以你要是一个表里搞的索引太多了，很可能就会导致你的增删改的速度就比较差了，也许查询速度确 实是可以提高，但是增删改就会受到影响，因此通常来说，我们是不建议一个表里搞的索引太多的

# 联合索引

我们可以针对学生班级、学生姓名和科目名称建立一个联合索引。

下面有两个数据页，第一个数据页里有三条数据，每条数据都包含了联合索引的三个字段的值和主键 值，数据页内部是按照顺序排序的。

首先按照班级字段的值来排序，如果一样则按照学生姓名字段来排序，如果一样，则按照科目名称来排 序，所以数据页内部都是按照三个字段的值来排序的，而且还组成了单向链表。

然后数据页之间也是有顺序的，第二个数据页里的三个字段的值一定都大于上一个数据页里三个字段的 值，比较方法也是按照班级名称、学生姓名、科目名称依次来比较的，数据页之间组成双向链表。

索引页里就是两条数据，分别指向两个数据页，索引存放的是每个数据页里最小的那个数据的值，大家 看到，索引页里指向两个数据页的索引项里都是存放了那个数据页里最小的值！ 索引页内部的数据页是组成单向链表有序的，如果你有多个索引页，那么索引页之间也是有序的，组成 了双向链表。

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304103411.png" style="zoom:25%;" />

好了，那么现在假设我们想要搜索：1班+张小强+数学的成绩，此时你可能会写一个类似下面的SQL语 句

`select * from student_score where class_name='1班' and student_name='张小强' and subject_name='数学'`

此时就涉及到了一个索引使用的规则，那就是你发起的SQL语句里，where条件里的几个字段都是基于 等值来查询，都是用的等于号！而且where条件里的几个字段的名称和顺序也跟你的联合索引一模一 样！此时就是等值匹配规则，上面的SQL语句是百分百可以用联合索引来查询的。

那么查询的过程也很简单了，首先到索引页里去找，索引页里有多个数据页的最小值记录，此时直接在 索引页里基于二分查找法来找就可以了，先是根据班级名称来找1班这个值对应的数据页，直接可以定 位到他所在的数据页

然后你就直接找到索引指向的那个数据页就可以了，在**数据页内部本身也是一个单向链表，你也是直接 就做二分查找就可以了**，先按1班这个值来找，你会发现几条数据都是1班，此时就可以按照张小强这个 姓名来二分查找，此时会发现多条数据都是张小强，接着就按照科目名称数学来二分查找。 很快就可以定位到一条数据，1班的张小强的数学科目，他对应的数据的id是127

然后就根据主键id=127到聚簇索引里按照一样的思路，从索引根节点开始二分查找迅速定位下个层级的 页，再不停的找，很快就可以找到id=127的那条数据，然后从里面提取所有字段，包括分数，就可以 了

对于联合索引而言，就是依次按照各个字段来进行二分查找，先定位到第一个字段对应的值在哪个页 里，然后如果第一个字段有多条数据值都一样，就根据第二个字段来找，以此类推，一定可以定位到某 条或者某几条数据！

# 使用规则

上次我们讲的是**等值匹配规则**，就是你where语句中的几个字段名称和联合索引的字段完全一样，而且 都是基于等号的等值匹配，那百分百会用上我们的索引，这个大家是没有问题的，即使你where语句里 写的字段的顺序和联合索引里的字段顺序不一致，也没关系，MySQL会自动优化为按联合索引的字段顺 序去找。

现在看第二个规则，就是**最左侧列匹配**，这个意思就是假设我们联合索引是`KEY(class_name, student_name, subject_name)`，那么不一定必须要在where语句里根据三个字段来查，其实只要根据 最左侧的部分字段来查，也是可以的。

比如你可以写`select * from student_score where class_name='' and student_name=''`，就查某个学

生所有科目的成绩，这都是没有问题的。

但是假设你写一个`select * from student_score where subject_name=''`，那就不行了，因为联合索引

的B+树里，是必须先按`class_name`查，再按`student_name`查，不能跳过前面两个字段，直接按最后一 个`subject_name`查的。

另外，假设你写一个`select * from student_score where class_name='' and subject_name=''`，那么 只有`class_name`的值可以在索引里搜索，剩下的`subject_name`是没法在索引里找的，道理同上。

所以在建立索引的过程中，你必须考虑好联合索引字段的顺序，以及你平时写SQL的时候要按哪几个字 段来查。

第三个规则，是**最左前缀匹配原则**，即如果你要用like语法来查，比如`select * from student_score where class_name like '1%'`，查找所有1打头的班级的分数，那么也是可以用到索引的。

因为你的联合索引的B+树里，都是按照`class_name`排序的，所以你要是给出`class_name`的确定的最左 前缀就是1，然后后面的给一个模糊匹配符号，那也是可以基于索引来查找的，这是没问题的。 但是你如果写`class_name like '%班'`，在左侧用一个模糊匹配符，那他就没法用索引了，因为不知道你 最左前缀是什么

第四个规则，就是**范围查找规则**，这个意思就是说，我们可以用`select * from student_score where class_name>'1班' and class_name<'5班'`这样的语句来范围查找某几个班级的分数。

这个时候也是会用到索引的，因为我们的索引的最下层的数据页都是按顺序组成双向链表的，所以完全 可以先找到'1班'对应的数据页，再找到'5班'对应的数据页，两个数据页中间的那些数据页，就全都是在 你范围内的数据了

但是如果你要是写`select * from student_score where class_name>'1班' and class_name<'5班' and student_name>''`，这里只有`class_name`是可以基于索引来找的，`student_name`的范围查询是没法用 到索引的！

这也是一条规则，就是你的where语句里如果有范围查询，那只有对联合索引里最左侧的列进行范围查 询才能用到索引！

第五个规则，就是**等值匹配+范围匹配的规则**，如果你要是用`select * from student_score where class_name='1班' and student_name>'' and subject_name<''`，那么此时你首先可以用`class_name`在 索引里精准定位到一波数据，接着这波数据里的`student_name`都是按照顺序排列的，所以` student_name>''`也会基于索引来查找，但是接下来的`subject_name<''`是不能用索引的

# SQL排序

假设我们建立了一个`INDEX(xx1,xx2,xx3)`这样的一个联合索引，这个时 候默认情况下在索引树里本身就是依次按照xx1,xx2,xx3三个字段的值去排序的，那么此时你再运行 `select * from table order by xx1,xx2,xx3 limit 100`这样的SQL语句

直接就按照索引树里的顺序，把xx1,xx2,xx3三个字段按照从小到大的值获取前面 100条就可以了

然后拿到100条数据的主键再去聚簇索引里回表查询剩余所有的字段

# SQL分组

因为在我们的索引树里默认都是按照指定的一些字段都排序好的，其实字段值相同的数据都是在一起 的，假设要是走索引去执行分组后再聚合，那性能一定是比临时磁盘文件去执行好多了。

所以通常而言，对于group by后的字段，最好也是按照联合索引里的最左侧的字段开始，按顺序排列开 来，这样的话，其实就可以完美的运用上索引来直接提取一组一组的数据，然后针对每一组的数据执行 聚合函数就可以了。

其实大家会发现，这个group by和order by用上索引的原理和条件都是差不多的，本质都是在group by 和order by之后的字段顺序和联合索引中的从最左侧开始的字段顺序一致，然后就可以充分利用索引树 里已经完成排序的特性，快速的根据排序好的数据执行后续操作了。

# 回表查询

即使我们根据索引树按照条件找到了需要的数据，那也仅仅是索引里的几个字段的值和主键值，万一你 搞了一个`select *`还需要很多其他的字段，那还得走一个回表操作，根据主键跑到主键的聚簇索引里去 找，聚簇索引的叶子节点是数据页，找到数据页里才能把一行数据的所有字段值提取出来。

所以其实大家可以思考一下，假设你是类似`select * from table order by xx1,xx2,xx3`的语句，可能你 就是得从联合索引的索引树里按照顺序取出来所有数据，接着对每一条数据都走一个主键的聚簇索引的查找，其实性能也是不高的

有的时候MySQL的执行引擎甚至可能会认为，你要是类似`select * from table order by xx1,xx2,xx3`的 语句，相当于是得把联合索引和聚簇索引，两个索引的所有数据都扫描一遍了，那还不如就不走联合索引了，直接全表扫描得了，这样还就扫描一个索引而已。

但是你如果要是`select * from table order by xx1,xx2,xx3 limit 10`这样的语句，那执行引擎就知道了，

你先扫描联合索引的索引树拿到10条数据，接着对10条数据在聚簇索引里查找10次就可以了，那么就 还是会走联合索引的。

**覆盖索引**

其实覆盖索引不是一种索引，他就是一种基于索引查 询的方式罢了。 他的意思就是针对类似`select xx1,xx2,xx3 from table order by xx1,xx2,xx3`这样的 语句，这种情况下，你仅仅需要联合索引里的几个字段的值，那么其实就只要扫描联合索引的索引树就可以了，不需要 回表去聚簇索引里找其他字段了。

所以这个时候，需要的字段值直接在索引树里就能提取出来，不需要回表到聚簇索引，这种查询方式就 是覆盖索引

也正是这样，所以在写SQL语句的时候，一方面是你要注意一下也许你会用到联合索引，但是是否可能 会导致大量的回表到聚簇索引，如果需要回表到聚簇索引的次数太多了，可能就直接给你做成全表扫描 不走联合索引了；

一方面是尽可能还是在SQL里指定你仅仅需要的几个字段，不要搞一个`select *`把所有字段都拿出来， 甚至最好是直接走覆盖索引的方式，不要去回表到聚簇索引。

即使真的要回表到聚簇索引，那你也尽可能用limit、where之类的语句限定一下回表到聚簇索引的次 数，就从联合索引里筛选少数数据，然后再回表到聚簇索引里去，这样性能也会好一些

# 设计索引

**第一个索引设计原则就来了**

针对你的SQL语句里的where条件、order by条件以及 group by条件去设计索引

也就是说，你的where条件里要根据哪些字段来筛选数据？order by要根据哪些字段来排序？group by 要根据哪些字段来分组聚合？

此时你就可以设计一个或者两三个联合索引，每一个联合索引都尽量去包含上你的`where、order by、 group by`里的字段，接着你就要仔细审查每个SQL语句，是不是每个`where、order by、group by`后面 跟的字段顺序，都是某个联合索引的最左侧字段开始的部分字段

比如你有一个联合索引是`INDEX(a,b,c)`，此时你一看发现有三个SQL，包含了`where a=? and b=?， order by a,b，group by a`这些部分，那么此时`where、order by、group by`后续跟的字段都是联合索 引的最左侧开始的部分字段，这就可以了，说明你的每个SQL语句都会用上你的索引了。

所以在设计索引的时候，首先第一条，就是要按照这个原则，去保证你的每个SQL语句的`where、 order by和group by`都可以用上索引。

**一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，那么才能发挥出B+树快速二分 查找的优势来**

其次的话，你尽量是对那些字段的类型比较小的列来设计索引，比如说什么`tinyint`之类的，因为他的字 段类型比较小，说明这个字段自己本身的值占用磁盘空间小，此时你在搜索的时候性能也会比较好一 点。

不过当然了，这个所谓的字段类型小一点的列，也不是绝对的，很多时候你就是要针对varchar(255)这 种字段建立索引，哪怕多占用一些磁盘空间，那你也得去设计这样的索引，比较关键的其实还是尽量别 把基数太低的字段包含在索引里，因为意义不是太大。

那当然了，万一要是你真的有那种varchar(255)的字段，可能里面的值太大了，你觉得都放索引树里太 占据磁盘空间了，此时你仔细考虑了一下，发现完全可以换一种策略，也就是仅仅针对这个 varchar(255)字段的前20个字符建立索引，就是说，对这个字段里的每个值的前20个字符放在索引树里 而已。

此时你建立出来的索引其实类似于`KEY my_index(name(20),age,course)`，就这样的一个形式，假设 name是varchar(255)类型的，但是在索引树里你对name的值仅仅提取前20个字符而已。

此时你在where条件里搜索的时候，如果是根据name字段来搜索，那么此时就会先到索引树里根据 name字段的前20个字符去搜索，定位到之后前20个字符的前缀匹配的部分数据之后，再回到聚簇索引 提取出来完整的name字段值进行比对就可以了

但是假如你要是order by name，那么此时你的name因为在索引树里仅仅包含了前20个字符，所以这 个排序是没法用上索引了！group by也是同理的。所以这里大家要对前缀索引有一个了解

**尽量不要让你的查询语句里的字段搞什么函数，或者是搞个计算。**

现在设计索引的时候需要注意的点都已经讲完了，其实就是好好设计索引，让你的查询语句都能用上索 引，同时注意一下字段基数、前缀索引和索引列套函数的问题，尽量让你的查询都能用索引，别因为一 些原因用不上索引了。

你插入数据肯定有主键吧，那有主键就得更新聚簇索引树，你插入一条数据肯定会包含索引里各个字段 的值吧，那你的联合索引的B+树是不是也要更新？

对了，你不停的增删改数据，就会不停的更新你的索引树。

所以因为你插入的数据值可能根本不是按照顺序来的，很可能会导致索引树里的某个页就会自动分裂， 这个页分裂的过程就很耗费时间，因此一般让大家设计索引别太多，建议两三个联合索引就应该覆盖掉 你这个表的全部查询了。

否则索引太多必然导致你增删改数据的时候性能很差，因为要更新多个索引树。 另外很关键一点，建议大家主键一定是自增的，别用UUID之类的，因为主键自增，那么起码你的聚簇 索引不会频繁的分裂，主键值都是有序的，就会自然的新增一个页而已，但是如果你用的是UUID，那 么也会导致聚簇索引频繁的页分裂。
