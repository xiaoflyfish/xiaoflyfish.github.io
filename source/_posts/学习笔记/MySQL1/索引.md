---
title: 索引
categories: 
- 学习笔记
- MySQL1
---

# 磁盘数据页

大家都知道，数据库最终所有的数据（包括我们建的各种表以及表里的数据）都是要存放在磁 盘上的文件里的，然后在文件里存放的物理格式就是数据页，那么大量的数据页在磁盘文件里是怎么存 储的呢

首先大家要明白的一点是，大量的数据页是按顺序一页一页存放的，然后两两相邻的数据页之间会采用 双向链表的格式互相引用

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303223330.png" style="zoom:25%;" />

其实一个数据页在磁盘文件里就是一段数据，可能是二进制或者别的特殊格式的数据，然后数据页里包 含两个指针，一个指针指向自己上一个数据页的物理地址，一个指针指向自己下一个数据页的物理地 址，大概可以认为类似下面这样

```
DataPage: xx=xx, xx=xx, linked_list_pre_pointer=15367, linked_list_next_pointer=34126 || 
DataPage: xx=xx, xx=xx, linked_list_pre_pointer=23789, linked_list_next_pointer=46589 || 
DataPage: xx=xx, xx=xx, linked_list_pre_pointer=33198, linked_list_next_pointer=55681
```

上面那段示例数据，当然不能完全认为是MySQL数据库的磁盘文件里的存储格式，但是我这里就是给你 看一些类似的东西，其实MySQL实际存储大致也是类似这样的，就是每个数据页在磁盘文件里都是连续 的一段数据。

然后每个数据页里，可以认为就是DataPage打头一直到 || 符号的一段磁盘里的连续的数据，你可以认 为每一个数据页就是磁盘文件里这么一段连续的东西。

然后每个数据页，都有一个指针指向自己上一个数据页在磁盘文件里的起始物理位置，比如 `linked_list_pre_pointer=15367`，就是指向了上一个数据页在磁盘文件里的起始物理位置，那个15367 可以认为就是在磁盘文件里的position或者oﬀset，同理，也有一个指针指向自己下一个数据页的物理 位置。

现在你再回头看一下上面那个图，是不是就理解了一个磁盘文件里的多个数据页是如何通过指针组成一 个双向链表的！

然后一个数据页内部会存储一行一行的数据，也就是平时我们在一个表里插入的一行一行的数据就会存 储在数据页里，然后数据页里的每一行数据都会按照主键大小进行排序存储，同时每一行数据都有指针 指向下一行数据的位置，组成单向链表

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303223538.png" style="zoom:25%;" />

**假设没有任何索引，数据库是如何根据查询语句搜索数据的**

每个数据页里都会有一个页目录，里面根据数据行的主键存放了一个目录，同时数据行是被分散存 储到不同的槽位里去的，所以实际上每个数据页的目录里，就是这个页里每个主键跟所在槽位的映射关 系

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303223721.png" style="zoom:25%;" />

所以假设你要根据主键查找一条数据，而且假设此时你数据库里那个表就没几条数据，那个表总共就一个数据页，那么就太简单了！首先就会先到数据页的页目录里根据主键进行二分查找

然后通过二分查找在目录里迅速定位到主键对应的数据是在哪个槽位里，然后到那个槽位里去，遍历槽 位里每一行数据，就能快速找到那个主键对应的数据了。每个槽位里都有一组数据行，你就是在里面遍 历查找就可以了。

> 但是假设你要是根据非主键的其他字段查找数据呢

那就尴尬了，此时你是没办法使用主键的那种页目录来二分查找的，只能进入到数据页里，根据单向链 表依次遍历查找数据了，这就性能很差了。

好，那么现在假如我们有很多数据页呢？ 对了，一个表里往往都是有大量数据的，可能有多达成百上千个数据页，这些数据页就存放在物理磁盘 文件里

所以此时是如何查询数据的呢

你一个表里所有数据页都是组成双向链表的吧？好，有链表就好办了，直接从第一个数据页开始遍历所 有数据页，从第一个数据页开始，你得先把第一个数据页从磁盘上读取到内存buﬀer pool的缓存页里 来。

然后你就在第一个数据页对应的缓存页里，按照上述办法查找，假设是根据主键查找的，你可以在数据 页的页目录里二分查找，假设你要是根据其他字段查找的，只能是根据数据页内部的单向链表来遍历查 找

> 那么假设假设第一个数据页没找到你要的那条数据呢

没办法，只能根据数据页的双向链表去找下一个数据页，然后读取到buﬀer pool的缓存页里去，然后按 一样的方法在一个缓存页内部查找那条数据。

如果依然还是查找不到呢

那只能根据双向链表继续加载下一个数据页到缓存页里来了，以此类推，循环往复。 不知道大家看到这个过程有什么感想没有？有没有觉得，你似乎是在做一个数据库里很尴尬的操作：全 表扫描

对了，其实上述操作过程，就是全表扫描，在你没有任何索引数据结构的时候，无论如何查找数据，说 白了都是一个全表扫描的过程，就是根据双向链表依次把磁盘上的数据页加载到缓存页里去，然后在一 个缓存页内部来查找那条数据。

最坏的情况下，你就得把所有数据页里的每条数据都得遍历一遍，才能找到你需要的那条数据，这就是 全表扫描！

# 页分裂

正常情况下我们在一个表里插入一些数据后，他们都会进入到一个数据页里去，在数据页 内部，他们会组成一个单向链表，这个数据页内部的单向链表大致如下所示

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303234450.png" style="zoom:25%;" />

看上面的图，里面就是一行一行的数据，刚开始第一行是个起始行，他的行类型是2，就是最小的 一行，然后他有一个指针指向了下一行数据，每一行数据都有自己每个字段的值，然后每一行通过一个 指针不停的指向下一行数据，普通的数据行的类型都是0，最后一行是一个类型为3的，就是代表最大的 一行。

上面就是一个典型的数据页内部的情况

是这样的，假设你不停的在表里插入数据，那么刚开始是不是就是不停的在一个数据页插入数据？接着 数据越来越多，越来越多，此时就要再搞一个数据页了

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303234529.png" style="zoom:25%;" />

后续我们会讲到索引这块机制，索引运作的一个核心基础就是要求你后一个 数据页的主键值都大于前面一个数据页的主键值，但是如果你的主键是自增的，那还可以保证这一点， 因为你新插入后一个数据页的主键值一定都大于前一个数据页的主键值。

但是有时候你的主键并不是自增长的，所以可能会出现你后一个数据页的主键值里，有的主键是小于前 一个数据页的主键值的。

比如在第一个数据页里有一条数据的主键是10，第二个数据页里居然有一条数据的主键值是8，那此时 肯定有问题了。

所以此时就会出现一个过程，叫做页分裂，就是万一你的主键值都是你自己设置的，那么在增加一个新 的数据页的时候，实际上会把前一个数据页里主键值较大的，挪动到新的数据页里来，然后把你新插入 的主键值较小的数据挪动到上一个数据页里去，保证新数据页里的主键值一定都比上一个数据页里的主 键值大。

大家看下图，假设新数据页里，有两条数据的主键值明显是小于上一个数据页的主键值的

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303234655.png" style="zoom:25%;" />

如上图所示，第一个数据页里有1、5、6三条数据，第二个数据页里有2、3、4三条数据，明显第二个 数据页里的数据的主键值比第一个数据页里的5和6两个主键都小，所以这个是不行的。

此时就会出现页分裂的行为，把新数据页里的两条数据挪动到上一个数据页，上一个数据页里挪两条数 据到新数据页里去

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303234733.png" style="zoom:25%;" />

所以上述就是一个页分裂的过程，核心目标就是保证下一个数据页里的主键值都比上一个数据页里的主 键值要大

# 主键索引

假设我们有多个数据页，然后我们想要根据主键来查询数据，那么直接查询的话也是不 行的，因为我们也不知道主键到底是在哪里，是不是

现在假设你要搜id=4的数据，你怎么知道在哪个数据页里？没有任何证据可以告诉你他到底是在哪个数 据页里啊！

所以假设还是这个样子的话，你也就只能全表扫描了，从第一个数据页开始，每个数据页都进入到页目 录里查找主键，最坏情况下，所有数据页你都得扫描一遍，还是很坑的。 所以其实此时就需要针对主键设计一个索引了，针对主键的索引实际上就是主键目录，这个主键目录 呢，就是把每个数据页的页号，还有数据页里最小的主键值放在一起，组成一个索引的目录

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303234944.png" style="zoom:25%;" />

现在我们有了上图的主键目录就方便了，直接就可以到主键目录里去搜索，比如你要找id=3的数据，此 时就会跟每个数据页的最小主键来比，首先id=3大于了数据页2里的最小主键值1，接着小于了数据页8 里的最小主键值4。

所以既然如此，你直接就可以定位到id=3的数据一定是在数据页2里的！

假设你有很多的数据页，在主键目录里就会有很多的数据页和最小主键值，此时你完全可以根据二分查 找的方式来找你要找的id到底在哪个数据页里！

所以这个效率是非常之高的，而类似上图的主键目录，就可以认为是主键索引。

而大家都知道我们的数据页都是一坨一坨的连续数据放在很多磁盘文件里的，所以只要你能够根据主键 索引定位到数据所在的数据页，此时假设我们有别的方式存储了数据页跟磁盘文件的对应关系，此时你 就可以找到一个磁盘文件。

而且我们假设数据页在磁盘文件里的位置也就是oﬀset偏移量，你也是可以知道的，此时就可以直接通 过随机读的方式定位到磁盘文件的某个oﬀset偏移量的位置，然后就可以读取连续的 一大坨数据页了！

# B+树

你的表里的数据可能很多很多，比如有几百万，几千万，甚至单表几亿条数据都是 有可能的，所以此时你可能有大量的数据页，然后你的主键目录里就要存储大量的数据页和最小主键 值，这怎么行呢？

所以在考虑这个问题的时候，实际上是采取了一种把索引数据存储在数据页里的方式来做的

也就是说，你的表的实际数据是存放在数据页里的，然后你表的索引其实也是存放在页里的，此时索引 放在页里之后，就会有索引页，假设你有很多很多的数据页，那么此时你就可以有很多的索引页

但是现在又会存在一个问题了，你现在有很多索引页，但是此时你需要知道，你应该到哪个索引页里去 找你的主键数据，是索引页20？还是索引页28？这也是个大问题

于是接下来我们又可以把索引页多加一个层级出来，在更高的索引层级里，保存了每个索引页和索引页 里的最小主键值

现在就好了，假设我们要查找id=46的，直接先到最顶层的索引页35里去找，直接通过二分查找可以定 位到下一步应该到索引页20里去找，接下来到索引页20里通过二分查找定位，也很快可以定位到数据应 该在数据页8里，再进入数据页8里，就可以找到id=46的那行数据了。

那么现在问题再次来了，假如你最顶层的那个索引页里存放的下层索引页的页号也太多了，怎么办呢？

此时可以再次分裂，再加一层索引页，比如下面图里那样子

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303235405.png" style="zoom:25%;" />

没错了，这就是一颗B+树，属于数据结构里的一种树形数据结构，所以一直说MySQL的索引是用B+树 来组成的，其实就是这个意思。

我们就以最简单最基础的主键索引来举例，当你为一个表的主键建立起来索引之后，其实这个主键的索 引就是一颗B+树，然后当你要根据主键来查数据的时候，直接就是从B+树的顶层开始二分查找，一层 一层往下定位，最终一直定位到一个数据页里，在数据页内部的目录里二分查找，找到那条数据。

这就是索引最真实的物理存储结构，采用跟数据页一样的页结构来存储，一个索引就是很多页组成的一 颗B+树。

# 聚簇索引

现在假设我们要搜索一个主键id对应的行，此时你就应该先去顶层的索引页88里去找，通过二 分查找的方式，很容易就定位到你应该去下层哪个索引页里继续找

比如现在定位到了下层的索引页35里去继续找，此时在索引页35里也有一些索引条目的，分别都是下层 各个索引页（20，28，59）和他们里面最小的主键值，此时在索引页35的索引条目里继续二分查找， 很容易就定位到，应该再到下层的哪个索引页里去继续找

这是基于索引数据结构去查找主键的一个过程，那么大家有没有发现一件事情，其实最下层的索引 页，都是会有指针引用数据页的，所以实际上索引页之间跟数据页之间是有指针连接起来的

同一层级内的索引页组成双向链表，就跟数据页自己组成双向链表是一样的

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303235845.png" style="zoom:25%;" />

不知道大家把上面的图连起来看，有没有发现一些特点，就是说假设你把索引页和数据页综合起来看， 他们都是连接在一起的，看起来就如同一颗完整的大的B+树一样，从根索引页88开始，一直到所有的 数据页，其实组成了一颗巨大的B+树。

在这颗B+树里，最底层的一层就是数据页，数据页也就是B+树里的叶子节点了！

所以，如果一颗大的B+树索引数据结构里，叶子节点就是数据页自己本身，那么此时我们就可以称这颗 B+树索引为聚簇索引！

也就是说，上图中所有的索引页+数据页组成的B+树就是聚簇索引！

其实在InnoDB存储引擎里，你在对数据增删改的时候，就是直接把你的数据页放在聚簇索引里的，数 据就在聚簇索引里，聚簇索引就包含了数据！比如你插入数据，那么就是在数据页里插入数据。 如果你的数据页开始进行页分裂了，他此时会调整各个数据页内部的行数据，保证数据页内的主键值都 是有顺序的，下一个数据页的所有主键值大于上一个数据页的所有主键值

同时在页分裂的时候，会维护你的上层索引数据结构，在上层索引页里维护你的索引条目，不同的数据 页和最小主键值。

然后如果你的数据页越来越多，一个索引页放不下了，此时就会再拉出新的索引页，同时再搞一个上层 的索引页，上层索引页里存放的索引条目就是下层索引页页号和最下主键值。

按照这个顺序，以此类推，如果你的数据量越大，此时可能就会多出更多的索引页层级来，不过说实 话，一般索引页里可以放很多索引条目，所以通常而言，即使你是亿级的大表，基本上大表里建的索引 的层级也就三四层而已。

这个聚簇索引默认是按照主键来组织的，所以你在增删改数据的时候，一方面会更新数据页，一方面其 实会给你自动维护B+树结构的聚簇索引，给新增和更新索引页，这个聚簇索引是默认就会给你建立的。

# 二级索引

假设你要是针对其他字段建立索引，比如name、age之类的字段，这都是一样的原理，简单来 说，比如你插入数据的时候，一方面会把完整数据插入到聚簇索引的叶子节点的数据页里去，同时维护 好聚簇索引，另一方面会为你其他字段建立的索引，重新再建立一颗B+树。

比如你基于name字段建立了一个索引，那么此时你插入数据的时候，就会重新搞一颗B+树，B+树的叶 子节点也是数据页，但是这个数据页里仅仅放主键字段和name字段

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304000447.png" style="zoom:25%;" />

大家注意，这可是独立于聚簇索引之外的另外一个索引B+树了，严格来说是name字段的索引B+树，所 以在name字段的索引B+树里，叶子节点的数据页里仅仅放主键和name字段的值，至于排序规则之类 的，都是跟以前说的一样的。

也就是说，name字段的索引B+树里，叶子节点的数据页中的name值都是按大小排序的，同时下一个 数据页里的name字段值都大于上一个数据页里的name字段值，这个整体的排序规则都跟聚簇索引按 照主键的排序规则是一样的。

然后呢，name字段的索引B+树也会构建多层级的索引页，这个索引页里存放的就是下一层的页号和最 小name字段值，整体规则都是一样的，只不过存放的都是name字段的值，根据name字段值排序罢 了

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210304000536.png" style="zoom:25%;" />

所以假设你要根据name字段来搜索数据，那搜索过程简直都一样了，不就是从name字段的索引B+树 里的根节点开始找，一层一层往下找，一直找到叶子节点的数据页里，定位到name字段值对应的主键值。 然后呢

此时针对`select * from table where name='xx'`这样的语句，你先根据name字段值在name字段的索引B+树里找，找到叶子节点也仅仅可以找到对应的主键值，而找不到这行数据完整的所有字段。

所以此时还需要进行“回表”，这个回表，就是说还需要根据主键值，再到聚簇索引里从根节点开始，一 路找到叶子节点的数据页，定位到主键对应的完整数据行，此时才能把`select *`要的全部字段值都拿出 来。

因为我们根据name字段的索引B+树找到主键之后，还要根据主键去聚簇索引里找，所以一般把name 字段这种普通字段的索引称之为二级索引，一级索引就是聚簇索引，这就是普通字段的索引的运行原 理。

其实我们也可以把多个字段联合起来，建立联合索引，比如name+age

此时联合索引的运行原理也是一样的，只不过是建立一颗独立的B+树，叶子节点的数据页里放了 id+name+age，然后默认按照name排序，name一样就按照age排序，不同数据页之间的name+age值 的排序也如此。

然后这个name+age的联合索引的B+树的索引页里，放的就是下层节点的页号和最小的name+age的 值，以此类推，所以当你根据name+age搜索的时候，就会走name+age联合索引的这颗B+树了，搜索 到主键，再根据主键到聚簇索引里去搜索。
