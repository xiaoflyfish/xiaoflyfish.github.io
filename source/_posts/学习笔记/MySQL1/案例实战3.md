---
title: 案例实战3
categories: 
- 学习笔记
- MySQL1
---

大家玩过陌生人社交APP没有，市面上有很多，相信一些非单身的朋友可能玩儿的比较少， 但是很多单身的年轻人可能都会去玩儿这类APP，他本身的核心主旨，其实就是你进入APP的时候，需 要录入一系列的你的个人信息。

接着APP自己会通过一定的算法推荐一些可能适合你的人给你进行线上交友，当然也有可能是你自己通 过一定的条件去搜索和筛选，查找APP上的哪些用户可能比较符合你的期望，你希望去跟对方进行交 友。

这里我们忽略掉APP基于算法自动推荐潜在感兴趣的好友给你的部分，就来看看你通过一系列的条件去 筛选一些好友的过程。

**我们来思考一下，在你筛选的时候，是针对社交APP的哪个表进行查询**

明显是用户信息表吧，我们可以叫做`user_info`这么一个表。

那这个表里往往会具备哪些用户的个人信息呢

大致会包含你的地区（你在哪个省份、哪个城市，这个很关键，否则不在一个城市，可能线上聊的好， 线下见面的机会都没有），性别，年龄，身高，体重，兴趣爱好，性格特点，还有照片，当然肯定还有 最近一次在线时间

另外如果支持交友过程中让其他人对他进行评价，那么可能还需要包含这个人的一个综合评分。 针对这个用户表进行搜索，可不仅仅是筛选那么简单的，因为你想一下，你除了`select xx from user_info where xx=xx `有一系列的条件之外，APP肯定得支持分页展示吧？所以肯定还得跟上`limit xx,xx`的分页语句。

同时，很关键的一点是，你搜索的时候，肯定不是随便胡乱排序的吧，总得根据一定的规则对筛选出来 的结果进行一个排序，把最符合你的条件和期望的用户排列在最上面才可以，各位想想是不是

那么最终你的SQL语句可能是类似于：`select xx from user_info where xx=xx order by xx limit xx,xx`

那问题来了，假设你的SQL需要按照年龄进行范围筛选，同时需要按照用户的评分进行排序，类似下面 的SQL：`select xx from user_info where age between 20 and 25 order by score`，那就有问题了。

假设你就一个联合索引，age在最左侧，那你的where是可以用上索引来筛选的，但是排序是基于score 字段，那就不可以用索引了。那假设你针对age和score分别设计了两个索引，但是在你的SQL里假设基 于age索引进行了筛选，是没法利用另外一个score索引进行排序的。

所以说，针对这个实际场景，你要明白的第一个难题就是，往往在类似这种SQL里，你的where筛选和 order by排序实际上大部分情况下是没法都用到索引的！所谓鱼与熊掌不可兼得，就是这个意思

**实际场景中，往往where和order by是没法都用到索引的，这是第一个我们要注意的问题**

在where和order by出现索引设计冲突，鱼与熊掌不可兼得的时候， 到底是针对where去设计索引，还是针对order by设计索引？到底是让where去用上索引，还是让order by用上索引

其实这个问题的本质就是说，你是要让where语句先基于联合索引去进行一个筛选，筛选出来一部分用 户指定的数据，接着再把数据加载到内存或者是基于临时磁盘文件去进行指定条件的排序，最后用limit 语句拿到一页数据吗

还是说要让order by语句按照你的索引的顺序去找，找的过程中基于where里的条件筛选出来指定的数 据，然后再根据limit语句拿出来一页数据

说实话，一般这种时候往往都是让where条件去使用索引来快速筛选出来一部分指定的数据，接着再进 行排序，最后针对排序后的数据拿出来一页数据

因为基于索引进行where筛选往往可以最快速度筛选出你要的少部分数据，如果筛选出来的数据量不是 太大的话，那么后续排序和分页的成本往往不会太大！

好，那么假设我们打定主意要针对where条件去设计索引的话，此时又要犯难了，因为这个时候你要去 考虑，用户在搜索潜在好友的时候，一般会用上哪些条件呢？我们到底要把哪些字段包含到索引里去？ 到底在联合索引里，字段的顺序要如何排列呢

> 其实开门见山要告诉大家的一点就是，我们首先应该在联合索引里包含省份、城市、性别，这三个字 段！

因为这三个字段都是在搜索里几乎必定包含的三个字段，假设你要搜索潜在好友，那么必定是会搜索跟 你同一个地方的，然后搜索某个性别的的其他用户，这几个条件在APP里完全可以做成必选项，用户也 几乎必定会指定。

但是此时有人就会说了，之前不是说过么，基数太低的字段最好别放到索引里去，那省份、城市和性 别，都是基数非常小的几个字段，可选的值就那么几个，为什么要放到索引里去

> 这是个好问题，但是规则是死的，人是活的

假设你就因为省份、城市和性别几个字段的基数太小了，此时就不把他们几个包含到联合索引里去，那 么你实际查询的时候都要基于这几个字段去搜索，此时你就只能把这几个字段放在where条件的最后， 那么最后每次查询都必须要先用联合索引查询出来一部分数据，接着数据加载到内存里去，再根据 where条件最后的省份、城市和性别几个字段进行过滤筛选，每次查询都得多这么一个步骤。

所以与其如此，还**不如就把省份、城市和性别三个字段，放在联合索引的最左侧**，这样跟其他字段组合 联合索引后，让大部分的查询都可以直接通过索引树就可以把where条件指定的数据筛选出来了。

好，那么到今天为止，我们还是在分析这个案例，我们已经分析到了可以把基数较低但是频繁查询（几 乎每次查询都会指定）的省份、城市和性别几个字段放到联合索引的最左侧去，此时就可以让每次查询 时指定的省份、城市和性别，都直接从索引树里进行筛选。

那么联合索引中除了（province, city, sex）三个字段以外，还需要哪些其他的字段呢？其他字段该如何设计呢？是否还要设计其他的索引呢

**接着我们今天继续分析这个联合索引里还要放 哪些字段**

分析这个问题之前，我们先来分析一个问题，那就是假设查询的时候，不指定性别，就指定了省份，城 市，还有加了一个年龄，也就是说`where province=xx and city=xx and age between xx and xx`，那么 此时怎么办呢？因为age不在索引里，所以就根本没法通过age去在索引里进行筛选了。

那如果把索引设计成（province, city, sex, age），此时你的语句写成`where province=xx and city=xx and age>=xx and age<=xx`，也是没法让age用上索引去筛选的，因为city和age中间差了一个sex，所 以此时就不符合最左侧连续多个字段的原则了。

其实针对这个问题，大家完全没必要太担心，因为假设有上述场景，那么我们完全是可以把age放入联 合索引的，设计成（province, city, sex, age）这样的索引，那么在搜索的时候就根据省份、城市和年龄 来筛选，性别是不限的，此时就可以把where语句写成：`where province=xx and city=xx and sex in ('female', 'male') and age >=xx and age<=xx`

如果我们把语句写成上面那样子，那么就可以让整个where语句里的条件全部都在索引树里进行筛选和 搜索了！

另外，假设我们在查询语句里还有一些频繁使用的条件，通常都是兴趣爱好和性格特点，这个兴趣爱好 和性格特点，往往都是有固定的一些枚举值的

比如兴趣爱好可以有下述的值可选：运动、电影、旅游、烹饪，性格特点可能包含下面的值：温柔、霸 气、御姐、体贴、善良，等等。

那么针对这样的一些频繁使用的包含枚举值范围的一些字段，也完全可以加入到联合索引里去，可以设 计成（province, city, sex, hobby, character, age）这样的一个联合索引，此时假设出现了这样一个查 询，按照省份、城市、性格和年龄进行搜索，此时SQL怎么写

还是用之前的那个策略和思路，就是写成`where province=xx and city=xx and sex in(xx, xx) and hobby in (xx, xx, xx, xx) and character=xx and age>=xx and age<=xx` 也就是说，即使你不需要按性别和爱好进行筛选，但是在SQL里你可以对这两个字段用in语句，把他们 所有的枚举值都放进去。这样的话，就可以顺利的让province，city，character和age四个真正要筛选 的字段用上索引，直接在索引里进行筛选都是没有问题的

> 那么我们为什么一直强调，age字段必须要放在联合索引的最后一个呢

很简单，因为之前我们讲索引使用规则的时候说过，假设你where语句里有等值匹配，还有范围匹配， 此时必须是先让联合索引最左侧开始的多个字段使用等值匹配，接着最后一个字段是范围匹配。

就比如上面的语句`where province=xx and city=xx and sex in(xx, xx) and hobby in (xx, xx, xx, xx) and character=xx and age>=xx and age<=xx`，他们完全是按照联合索引最左侧开始的，province、 city、sex、hobby、character都是联合索引最左侧开始的多个字段，他们都是等值匹配，然后最后一 个age字段使用的是范围匹配，这种就是可以完全用上索引的。

但是假设你要是在联合索引里把age放在中间的位置，设计一个类似（province, city, sex, age, hobby, character）的联合索引，接着SQL写成`where province=xx and city=xx and sex in(xx, xx) and age>=xx and age<=xx and hobby in (xx, xx, xx, xx) and character=xx`的话，那么不好意思，只有 province, city, sex, age几个字段可以用上索引。

因为在SQL里，一旦你的一个字段做范围查询用到了索引，那么这个字段接下来的条件都不能用索引 了，这就是规则

所以说，实际设计索引的时候，必须把经常用做范围查询的字段放在联合索引的最后一个，才能保证你 SQL里每个字段都能基于索引去查询。

**假设在查询的时候还有一个条件**

是要根据用户最近登录时间在7天 之内来进行筛选，筛选最近7天登录过APP的用户，那么实际上可能你的用户表里有这么一个字段，` latest_login_time`

你要是在where条件里加入这么一个`latest_login_time <= 7`天内语句，肯定这个是没法用上索引了。因 为你这里必然会用一些计算或者是函数，才能进行一些时间的比对。

而且假设你的查询里还有age进行范围查询，那么我们之前说过，范围查询的时候，也就只有第一个范 围查询是可以用上索引的，第一个范围查询之后的其他范围查询是用不上索引的。

也就是说，即使你索引设计成这样：（province, city, sex, hobby, character, age, latest_login_time），然后你的where语句写成这样：`where xx xxx and age>=xx and age<=xxx and latest_login_time>=xx`，虽然age和`latest_login_time`都在联合索引里，但是按照规则，只有age范围查 询可以用到索引，`latest_login_time`始终是用不到索引的。

所以此时有一个技巧可以教给大家，你在设计表的时候，就必须考虑到这个问题，此时你完全可以设计 一个字段为：`does_login_in_latest_7_days`，也就是说，这个人是否在最近7天内登录过APP。

假设在7天内登录了这个APP，那么这个字段就是1，否则超过7天没登录，这个字段就是0！这样就把一 个时间字段转换为了一个枚举值的字段。

接下来的解决方案就简单化了，可以设计一个联合索引为：（`province, city, sex, hobby, character, does_login_in_latest_7_days, age`），然后搜索的时候，一定会在where条件里带上一个`does_login_in_latest_7_days=1`，最后再跟上age范围查询，这样就可以让你的where条件里的字段都 用索引来筛选

实际上一般来说，假设你要是where语句里通过上述联合索引就可以过滤掉大部分的数据，就保留小部 分数据下来基于磁盘文件进行order by语句的排序，最后基于limit进行分页，那么一般性能还是比较高 的。

**但有时候又怕一个问题，就是说万一你要是就仅仅使用联合索引里一些基数特别小的字段来筛选呢**

比如就基于性别来筛选，比如一下子筛选出所有的女性，可能有上百万用户数据，接着还要磁盘文件进 行排序再分页？那这个性能可能就会极为的差劲了

所以针对上述问题，可以针对那种基数很低的字段再加上排序字段单独额外设计一个辅助索引，专门用 于解决where条件里都是基数低的字段，然后还要排序后分页的问题

> 比如说就可以设计一个联合索引 为：（sex, score）

此时万一你要是写出如下SQL：`select xx from user_info where sex='female' order by score limit xx,xx`	

此时假设用之前设计的那个联合索引，那绝对是完蛋了，因为根本没法用索引，但是用我们设计的那个辅助的（sex, score）索引呢

此时因为where条件里的字段是等值匹配，而且还是等于某个常量值，所以虽然order by后跟的score 字段是（sex, score）索引里的第二个字段，order by没有从索引最左侧字段开始排列，但是他也可以 使用到索引来排序

因为具体到使用索引的层面，他会先对where条件里的`sex='female'`在索引树里筛选到这部分数据，接 着在`sex='female'`的数据里，这些数据实际上都是排列在一起的，因为在索引里，会按照sex和score两 个字段去进行排序，所以`sex='female'`的数据都是在一块儿的。

然后找到这部分数据之后，接着就可以确定，这部分数据肯定是按照score字段进行排序的，此时就可 以按照score字段值的顺序，去读取你的limit语句指定的数据分页出来就可以了

所以此时你这种针对**sex低基数的字段的筛选和基于评分排序**的语句，整体运行的效率是非常高的，完 全可以基于辅助索引来实现。

以此类推，完全可以通过对查询场景的分析，用（`province, city, sex, hobby, character, does_login_in_latest_7_days, age`）这样的联合索引去抗下复杂的where条件筛选的查询，此时走索引筛选速度很快，筛选出的数据量较少，接着进行排序和limit分页。

同时针对一些低基数字段筛选+评分排序的查询场景，可以设计类似（sex, score）的辅助索引来应对， 让他快速定位到一大片低基数字段对应的数据，然后按照索引顺序去走limit语句获取指定分页的数据， 速度同样会很快
