---
title: 事务
categories: 
- 学习笔记
- MySQL1
---

**脏写**

他的意思就是说有两个事务，事务A和事务B同时在更新一条数据，事务A先把他更新为 A值，事务B紧接着就把他更新为B值

此时事务A更新之后会记录一条undo log日志，大家应该还记得吧。事务A是先更新的， 他在更新之前，这行数据的值为NULL

所以此时事务A的undo log日志大概就是：更新之前这行数据的值为NULL，主键为XX

好，那么此时事务B更新完了数据的值为B，结果此时事务A突然回滚了，那么就会用他的undo log日志 去回滚。

此时事务A一回滚，直接就会把那行数据的值更新回之前的NULL值！所以此时事务A回滚了，可能看起 来这行数据的值就是NULL了

然后事务B一看，我的妈呀，为什么我更新的B值没了

所以对于事务B看到的场景，就是自己明明更新了，结果值却没了，这就是脏写！

他的本质就是事务B去修改了事务A修改过的值，但是此时事务A还没提交，所以事务A随时会回滚， 导致事务B修改的值也没了

**脏读**

假设事务A更新了一行数据的值为A值，此时事务B去查询了一下这行数据的值，看到的值是不是A值

接着坑爹的事情发生了，事务A突然回滚了事务，导致他刚才更新的A值没了，此时那行数据的值回 滚为NULL值

他的本质其实就是事务B去查询了事务A修改过的数据，但是此时事务A还没提 交，所以事务A随时会回滚导致事务B再次查询就读不到刚才事务A修改的数据了

无论是脏写还是脏读，都是因为一个事务去更新或者查询了另外一个还没提交的事务 更新过的数据。

因为另外一个事务还没提交，所以他随时可能会反悔会回滚，那么必然导致你更新的数据就没了，或者 你之前查询到的数据就没了

**不可重复读**

**幻读**

幻读指的就是你一个事务用一样的SQL多次查询，结果每次查询都会发现查到了一些之前没看到过的数 据

# 隔离级别

**read uncommitted**

是不允许发生脏写的

也就是说，不可能两个事务在没提交的情况下去更新同一行数据的值，但是在这种隔离级别下，可能发生脏读，不可重复读，幻读。

因为脏读的话，就是人家事务在没提交 情况下修改的值，居然被你读到了，人家随时可能会回滚的！而且你执行期间多次查询一行数据，可能 读到的值都不同，因为别的事务随时会修改值再提交，这个值是不可重复读的！幻读更不用说了，肯定 会发生。

**read committed**

不会发生脏写和脏读 也就是说，人家事务没提交的情况下修改的值，你是绝对读不到的！

但是呢，可能会发生不可重复读和 幻读问题，因为一旦人家事务修改了值然后提交了，你事务是会读到的，所以可能你多次读到的值是不 同的！

你只要记住，这个级别在别的事务已经提交之后读到他们修改过的值就可以了，但是别的事务没提交的 时候，绝对不会读到人家修改的值。

**REPEATABLE READ**

这个级别下，不会发生脏写、脏读和不可重复读的问题，因为你一个事务多次查询一个数据的值，哪怕 别的事务修改了这个值还提交了，没用，你不会读到人家提交事务修改过的值，你事务一旦开始，多次 查询一个值，会一直读到同一个值！

**serializable**

这种级别，根本就不允许你多个事务并发执行，只能串行起 来执行，先执行事务A提交，然后执行事务B提交，接着执行事务C提交，所以此时你根本不可能有幻读 的问题，因为事务压根儿都不并发执行！

# Spring事务注解

MySQL里执行的事务，默认情况下不会发生脏写、脏读、不可重复读和幻读的问题

依托这个MVCC机制，就能让RR级别避免不可重复读和幻 读的问题

Spring里的@Transactional注解来做事务

@Transactional注解里是有一个isolation参数的，里面是可以设置事务隔离级别的

具体的设置方式 如下： `@Transactional(isolation=Isolation.DEFAULT)`，然后默认的就是DEFAULT值，这个就是MySQL默认支 持什么隔离级别就是什么隔离级别。

那MySQL默认是RR级别，自然你开发的业务系统的事务也都是RR级别的了。

