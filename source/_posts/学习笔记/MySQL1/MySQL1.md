---
title: MySLQ1
categories: 
- 学习笔记
- MySQL1
---

[如何执行一条 SQL语句](https://blog.csdn.net/qq_42046105/article/details/103982282)

# SQL更新

**缓冲池**

InnoDB存储引擎中有一个非常重要的放在内存里的组件，就是缓冲池（Buffer Pool），这里面会缓存很多的数据， 以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了

引擎要执行更新语句的时候 ，比如对`id=10`这一行数据，他其实会先将`id=10`这一行数据看看是否在缓冲池里，如果不在的 话，那么会直接从磁盘里加载到缓冲池里来，而且接着还会对这行记录加独占锁。

因为我们想一下，在我们更新`id=10`这一行数据的时候，肯定是不允许别人同时更新的，所以必须要对这行记录加 独占锁

**undo日志文件：如何让你更新的数据可以回滚**

接着下一步，假设“id=10”这行数据的name原来是“zhangsan”，现在我们要更新为“xxx”，那么此时我们得先 把要更新的原来的值“zhangsan”和“id=10”这些信息，写入到undo日志文件中去。 

**更新buffer pool中的缓存数据**

当我们把要更新的那行记录从磁盘文件加载到缓冲池，同时对他加锁之后，而且还把更新前的旧值写入undo日志文件 之后，我们就可以正式开始更新这行记录了，更新的时候，先是会更新缓冲池中的记录，此时这个数据就是脏数据 了。

这里所谓的更新内存缓冲池里的数据，意思就是把内存里的“id=10”这行数据的name字段修改为“xxx”

那么为什么说此时这行数据就是脏数据了呢

因为这个时候磁盘上“id=10”这行数据的name字段还是“zhangsan”，但是内存里这行数据已经被修改了，所以 就会叫他是脏数据。

**Redo Log Buffer：万一系统宕机，如何避免数据丢失**

现在已经把内存里的数据进行了修改，但是磁盘上的数据还没修改

那么此时万一MySQL所在的机器宕机了，必然会导致内存里修改过的数据丢失，这可怎么办呢

这个时候，就必须要把对内存所做的修改写入到一个Redo Log Buffer里去，这也是内存里的一个缓冲区，是用来存放redo日志的

所谓的redo日志，就是记录下来你对数据做了什么修改，比如对“id=10这行记录修改了name字段的值为xxx”，这 就是一个日志

**提交事务的时候将redo日志写入磁盘中** 

接着我们想要提交一个事务了，此时就会根据一定的策略把redo日志从redo log buffer里刷入到磁盘文件里去

此时这个策略是通过`innodb_flush_log_at_trx_commit`来配置的，他有几个选项。 当这个参数的值为0的时候，那么你提交事务的时候，不会把redo log buffer里的数据刷入磁盘文件的，此时可能你都 提交事务了，结果mysql宕机了，然后此时内存里的数据全部丢失。 相当于你提交事务成功了，但是由于MySQL突然宕机，导致内存中的数据和redo日志都丢失了

当这个参数的值为1的时候，你提交事务的时候，就必须把redo log从内存刷入到磁盘文件里去，只要事务提交成功，那么redo log就 必然在磁盘里了

如果`innodb_flush_log_at_trx_commit`参数的值是2

他的意思就是，提交事务的时候，把redo日志写入磁盘文件对应的os cache缓存里去，而不是直接进入磁盘文件，可 能1秒后才会把os cache里的数据写入到磁盘文件里去。

这种模式下，你提交事务之后，redo log可能仅仅停留在os cache内存缓存里，没实际进入磁盘文件，万一此时你要 是机器宕机了，那么os cache里的redo log就会丢失，同样会让你感觉提交事务了，结果数据丢了

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210209234102.png" style="zoom:33%;" />

# 生产经验

**生产经验：真实生产环境下的数据库机器配置如何规划**

根据我们大量的经验 观察而言，4核8G的机器部署普通的Java应用系统，每秒大致就是抗下几百的并发访问，从每秒一两百请求到每秒七八百请 求，都是有可能的，关键是看你每个请求处理需要耗费多长时间

假设你每个请求花费1s可以处理完，那么你一 台机器每秒也许只可以处理100个请求，但是如果你每个请求只要花费100ms就可以处理完，那么你一台机器每秒也许就可以 处理几百个请求

一般8核16G的机器部署的MySQL数据库，每秒抗个一两千并发请求是没问题的，但是如果你 的并发量再高一些，假设每秒有几千并发请求，那么可能数据库就会有点危险了，因为数据库的CPU、磁盘、IO、内存的负载 都会很高，弄不数据库压力过大就会宕机

对于16核32G的机器部署的MySQL数据库而言，每秒抗个两三千，甚至三四千的并发请求也都是可以的，但是如果你达到每 秒上万请求，那么数据库的CPU、磁盘、IO、内存的负载瞬间都会飙升到很高，数据库也是可能会扛不住宕机的

**生产经验：互联网公司的生产环境数据库是如何进行性能测试的**

QPS就是说，你的这个数据库每秒可以处理多少个请求，大致可以理解为，一次请求就是一条SQL语句，也就是说这个数据库每秒可以处理多少个SQL语句

TPS其实就是每秒可处理的事务量，这个TPS往往是用在 数据库中较多一些，其实从字面意思就能看的出来，他就是说数据库每秒会处理多少次事务提交或者回滚

IOPS：这个指的是机器的随机IO并发处理的能力，比如机器可以达到200 IOPS，意思就是说每秒可以执行200个随机 IO读写请求

在内存中更新的脏数据库，最后都会由后台IO线程在不确 定的时间，刷回到磁盘里去，这就是随机IO的过程。如果说IOPS指标太低了，那么会导致你内存里的脏数据刷回磁盘的效率就会不高

> 吞吐量：这个指的是机器的磁盘存储每秒可以读写多少字节的数据量

所以一台机器他的存储每秒可以读写多少字节的数据量，就决定了他每秒可以把多少redo log之类的日志写入到磁盘里去

一 般来说我们写redo log之类的日志，都是对磁盘文件进行顺序写入的，也就是一行接着一行的写，不会说进行随机的读写，那 么一般普通磁盘的顺序写入的吞吐量每秒都可以达到200MB左右

> latency：这个指标说的是往磁盘里写入一条数据的延迟

因为我们执行SQL语句和提交事务的时候，都需要顺序写redo log磁盘文件，所以此时你写一条日志到 磁盘文件里去，到底是延迟1ms，还是延迟100us，这就对你的数据库的SQL语句执行性能是有影响的

[生产经验：如何对生产环境中的数据库进行360度无死角压测](https://www.cnblogs.com/klvchen/articles/12901727.html)

**生产经验：在数据库的压测过程中，如何360度无死角观察机器性能**

如何观察机器的磁盘IO情况：使用dstat -d命令

观察网卡的流量情况：可以使用dstat -n命令

**生产经验：如何为生产环境中的数据库部署监控系统**

Prometheus其实就是一个监控数据采集和存储系统，他可以利用监控数据采集组件（比如`mysql_exporter`）从你 指定的MySQL数据库中采集他需要的监控数据，然后他自己有一个时序数据库，他会把采集到的监控数据放入自己的时序数 据库中，其实本质就是存储在磁盘文件里

Grafana就是一个可视化的监控数据展示系统，他可以把Prometheus采集到的大量的MySQL监控数据展示成各种精美的报表，让我们可以直观的看到MySQL的监控情况

**生产经验：Linux操作系统的存储系统软件层原理剖析以及IO调度优化原理**

MySQL执行的数据页随机读写，redo log日志文件顺序读写的磁盘IO操作，在Linux的存储 系统中是如何执行的。

简单来说，Linux的存储系统分为VFS层、文件系统层、Page Cache缓存层、通用Block层、IO调度层、Block设备驱 动层、Block设备层

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303111113.png" style="zoom:25%;" />

当MySQL发起一次数据页的随机读写，或者是一次redo log日志文件的顺序读写的时候，实际上会把磁盘IO请求交给 Linux操作系统的VFS层

这一层的作用，就是根据你是对哪个目录中的文件执行的磁盘IO操作，把IO请求交给具体的文件系统。 

举个例子，在linux中，有的目录比如/xx1/xx2里的文件其实是由NFS文件系统管理的，有的目录比如/xx3/xx4里的文 件其实是由Ext3文件系统管理的，那么这个时候VFS层需要根据你是对哪个目录下的文件发起的读写IO请求，把请求 转交给对应的文件系统

接着文件系统会先在Page Cache这个基于内存的缓存里找你要的数据在不在里面，如果有就基于内存缓存来执行读 写，如果没有就继续往下一层走，此时这个请求会交给通用Block层，在这一层会把你对文件的IO请求转换为Block IO 请求

接着IO请求转换为Block IO请求之后，会把这个Block IO请求交给IO调度层，在这一层里默认是用CFQ公平调度算法 的

也就是说，可能假设此时你数据库发起了多个SQL语句同时在执行IO操作。 有一个SQL语句可能非常简单，比如`update xxx set xx1=xx2 where id=1`，他其实可能就只要更新磁盘上的一个 block里的数据就可以了

但是有的SQL语句，比如说`select * from xx where xx1 like "%xx%"`可能需要IO读取磁盘上的大量数据

那么此时如果基于公平调度算法，就会导致他先执行第二个SQL语句的读取大量数据的IO操作，耗时很久，然后第一 个仅仅更新少量数据的SQL语句的IO操作，就一直在等待他，得不到执行的机会

所以在这里，其实一般建议MySQL的生产环境，需要调整为deadline IO调度算法，他的核心思想就是，任何一个IO 操作都不能一直不停的等待，在指定时间范围内，都必须让他去执行

所以基于deadline算法，上面第一个SQL语句的更新少量数据的IO操作可能在等待一会儿之后，就会得到执行的机 会，这也是一个生产环境的IO调度优化经验

最后IO完成调度之后，就会决定哪个IO请求先执行，哪个IO请求后执行，此时可以执行的IO请求就会交给Block设备 驱动层，然后最后经过驱动把IO请求发送给真正的存储硬件，也就是Block设备层

然后硬件设备完成了IO读写操作之后，要不然是写，要不然是读，最后就把响应经过上面的层级反向依次返回，最终 MySQL可以得到本次IO读写操作的结果

# 数据读写机制

MySQL在实际工作时候的两种数据读写机制，一种是对redo log、binlog这种日志进行的磁盘顺序 读写，一种是对表空间的磁盘文件里的数据页进行的磁盘随机读写。

简单来说，MySQL在工作的时候，尤其是执行增删改操作的时候，肯定会先从表空间的磁盘文件里读取数据页出来， 这个过程其实就是典型的磁盘随机读操作

你可能需要在一个随机的位置读取一个数 据页到缓存，这就是**磁盘随机读**

因为你要读取的这个数据页可能在磁盘的任意一个位置，所以你在读取磁盘里的数据页的时候只能是用随机读的这种 方式。

磁盘随机读的性能是比较差的，所以不可能每次更新数据都进行磁盘随机读，必须是读取一个数据页之后放到Buffer Pool的缓存里去，下次要更新的时候直接更新Buffer Pool里的缓存页。

**对于磁盘随机读来说，主要关注的性能指标是IOPS和响应延迟**

IOPS是说底层的存储系统每秒可以执行多少次磁盘读写操作， 比如你底层磁盘支持每秒执行 1000个磁盘随机读写操作和每秒执行200个磁盘随机读写操作，对你的数据库的性能影响其实是非常大的。 

这个IOPS指标如何观察， 大家在压测的时候可以观察一下。 这个指标实际上对数据库的crud操作的 QPS影响是非常大的，因为他在某种程度上几乎决定了你每秒能执行多少个SQL语句，底层存储的IOPS越高，你的数 据库的并发能力就越高。

> 另外一个就是磁盘随机读写操作的响应延迟，也是对数据库的性能有很大的影响。

因为假设你的底层磁盘支持你每秒 执行200个随机读写操作，但是每个操作是耗费10ms完成呢，还是耗费1ms完成呢，这个其实也是有很大的影响的， 决定了你对数据库执行的单个crud SQL语句的性能。

比如你一个SQL语句发送过去，他磁盘要执行随机读操作加载多个数据页，此时每个磁盘随机读响应时间是50ms，那 么此时可能你的SQL语句要执行几百ms，但是如果每个磁盘随机读仅仅耗费10ms，可能你的SQL就执行100ms就行 了。

所以其实一般对于核心业务的数据库的生产环境机器规划，我们都是推荐用SSD固态硬盘的，而不是机械硬盘，因为 SSD固态硬盘的随机读写并发能力和响应延迟要比机械硬盘好的多，可以大幅度提升数据库的QPS和性能。

接着我们来看磁盘顺序读写，之前我们都知道，当你在Buffer Pool的缓存页里更新了数据之后，必须要写一条redo log日志，这个redo log日志，其实就是就是走的顺序写

所谓顺序写，就是说在一个磁盘日志文件里，一直在末尾追加日志

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210303105809.png" style="zoom:25%;" />

磁盘顺序写的性能其实是很高的，某种程度上来说，几乎可以跟内存随机读写的性能差不多，尤其是在数据库里其实 也用了os cache机制，就是redo log顺序写入磁盘之前，先是进入os cache，就是操作系统管理的内存缓里

