---
title: MySLQ1
categories: 
- 学习笔记
- MySQL1
---

[如何执行一条 SQL语句](https://blog.csdn.net/qq_42046105/article/details/103982282)

# SQL更新

**缓冲池**

InnoDB存储引擎中有一个非常重要的放在内存里的组件，就是缓冲池（Buffer Pool），这里面会缓存很多的数据， 以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了

引擎要执行更新语句的时候 ，比如对`id=10`这一行数据，他其实会先将`id=10`这一行数据看看是否在缓冲池里，如果不在的 话，那么会直接从磁盘里加载到缓冲池里来，而且接着还会对这行记录加独占锁。

因为我们想一下，在我们更新`id=10`这一行数据的时候，肯定是不允许别人同时更新的，所以必须要对这行记录加 独占锁

**undo日志文件：如何让你更新的数据可以回滚**

接着下一步，假设“id=10”这行数据的name原来是“zhangsan”，现在我们要更新为“xxx”，那么此时我们得先 把要更新的原来的值“zhangsan”和“id=10”这些信息，写入到undo日志文件中去。 

**更新buffer pool中的缓存数据**

当我们把要更新的那行记录从磁盘文件加载到缓冲池，同时对他加锁之后，而且还把更新前的旧值写入undo日志文件 之后，我们就可以正式开始更新这行记录了，更新的时候，先是会更新缓冲池中的记录，此时这个数据就是脏数据 了。

这里所谓的更新内存缓冲池里的数据，意思就是把内存里的“id=10”这行数据的name字段修改为“xxx”

那么为什么说此时这行数据就是脏数据了呢

因为这个时候磁盘上“id=10”这行数据的name字段还是“zhangsan”，但是内存里这行数据已经被修改了，所以 就会叫他是脏数据。

**Redo Log Buffer：万一系统宕机，如何避免数据丢失**

现在已经把内存里的数据进行了修改，但是磁盘上的数据还没修改

那么此时万一MySQL所在的机器宕机了，必然会导致内存里修改过的数据丢失，这可怎么办呢

这个时候，就必须要把对内存所做的修改写入到一个Redo Log Buffer里去，这也是内存里的一个缓冲区，是用来存放redo日志的

所谓的redo日志，就是记录下来你对数据做了什么修改，比如对“id=10这行记录修改了name字段的值为xxx”，这 就是一个日志

**提交事务的时候将redo日志写入磁盘中** 

接着我们想要提交一个事务了，此时就会根据一定的策略把redo日志从redo log buffer里刷入到磁盘文件里去

此时这个策略是通过`innodb_flush_log_at_trx_commit`来配置的，他有几个选项。 当这个参数的值为0的时候，那么你提交事务的时候，不会把redo log buffer里的数据刷入磁盘文件的，此时可能你都 提交事务了，结果mysql宕机了，然后此时内存里的数据全部丢失。 相当于你提交事务成功了，但是由于MySQL突然宕机，导致内存中的数据和redo日志都丢失了

当这个参数的值为1的时候，你提交事务的时候，就必须把redo log从内存刷入到磁盘文件里去，只要事务提交成功，那么redo log就 必然在磁盘里了

如果`innodb_flush_log_at_trx_commit`参数的值是2

他的意思就是，提交事务的时候，把redo日志写入磁盘文件对应的os cache缓存里去，而不是直接进入磁盘文件，可 能1秒后才会把os cache里的数据写入到磁盘文件里去。

这种模式下，你提交事务之后，redo log可能仅仅停留在os cache内存缓存里，没实际进入磁盘文件，万一此时你要 是机器宕机了，那么os cache里的redo log就会丢失，同样会让你感觉提交事务了，结果数据丢了

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210209234102.png" style="zoom:33%;" />

# binlog

binlog叫做归档日志，他里面记录的是偏向于逻辑性的日志

binlog不是InnoDB存储引擎特有的日志文件，是属于mysql server自己的日志文件

**提交事务的时候，同时会写入binlog** 

在我们提交事务的时候，会把redo log日志写入磁盘文件中去。然后其实在提交事务的时 候，我们同时还会把这次更新对应的binlog日志写入到磁盘文件中去

**binlog日志的刷盘策略分析**

对于binlog日志，其实也有不同的刷盘策略，有一个`sync_binlog`参数可以控制binlog的刷盘策略，他的默认值是0， 此时你把binlog写入磁盘的时候，其实不是直接进入磁盘文件，而是进入os cache内存缓存。

所以跟之前分析的一样，如果此时机器宕机，那么你在os cache里的binlog日志是会丢失的

如果要是把`sync_binlog`参数设置为1的话，那么此时会强制在提交事务的时候，把binlog直接写入到磁盘文件里去， 那么这样提交事务之后，哪怕机器宕机，磁盘上的binlog是不会丢失的

**基于binlog和redo log完成事务的提交**

当我们把binlog写入磁盘文件之后，接着就会完成最终的事务提交，此时会把本次更新对应的binlog文件名称和这次更新的binlog日志在文件里的位置，都写入到redo log日志文件里去，同时在redo log日志文件里写入一个commit标 记。 在完成这个事情之后，才算最终完成了事务的提交

**最后一步在redo日志中写入commit标记的意义是什么**

说白了，他其实是用来保持redo log日志与binlog日志一致的

必须是在redo log中写入最终的事务commit标记了，然后此时事务提交成功，而且redo log里有本次更新对应的日 志，binlog里也有本次更新对应的日志 ，redo log和binlog完全是一致的

**后台IO线程随机将内存更新后的脏数据刷回磁盘**

现在我们假设已经提交事务了，此时一次更新`“update users set name='xxx' where id=10”`，他已经把内存里的 buffer pool中的缓存数据更新了，同时磁盘里有redo日志和binlog日志，都记录了把我们指定的“id=10”这行数据 修改了“name='xxx'”

这个时候磁盘上的数据文件里的“id=10”这行数据的name字段还是等于 zhangsan这个旧的值啊

所以MySQL有一个后台的IO线程，会在之后某个时间里，随机的把内存buffer pool中的修改后的脏数据给刷回到磁 盘上的数据文件里去

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210210002203.png" style="zoom:33%;" />

**生产经验：真实生产环境下的数据库机器配置如何规划**

根据我们大量的经验 观察而言，4核8G的机器部署普通的Java应用系统，每秒大致就是抗下几百的并发访问，从每秒一两百请求到每秒七八百请 求，都是有可能的，关键是看你每个请求处理需要耗费多长时间

假设你每个请求花费1s可以处理完，那么你一 台机器每秒也许只可以处理100个请求，但是如果你每个请求只要花费100ms就可以处理完，那么你一台机器每秒也许就可以 处理几百个请求

一般8核16G的机器部署的MySQL数据库，每秒抗个一两千并发请求是没问题的，但是如果你 的并发量再高一些，假设每秒有几千并发请求，那么可能数据库就会有点危险了，因为数据库的CPU、磁盘、IO、内存的负载 都会很高，弄不数据库压力过大就会宕机

对于16核32G的机器部署的MySQL数据库而言，每秒抗个两三千，甚至三四千的并发请求也都是可以的，但是如果你达到每 秒上万请求，那么数据库的CPU、磁盘、IO、内存的负载瞬间都会飙升到很高，数据库也是可能会扛不住宕机的

**生产经验：互联网公司的生产环境数据库是如何进行性能测试的**

QPS就是说，你的这个数据库每秒可以处理多少个请求，大致可以理解为，一次请求就是一条SQL语句，也就是说这个数据库每秒可以处理多少个SQL语句

TPS其实就是每秒可处理的事务量，这个TPS往往是用在 数据库中较多一些，其实从字面意思就能看的出来，他就是说数据库每秒会处理多少次事务提交或者回滚

IOPS：这个指的是机器的随机IO并发处理的能力，比如机器可以达到200 IOPS，意思就是说每秒可以执行200个随机 IO读写请求

在内存中更新的脏数据库，最后都会由后台IO线程在不确 定的时间，刷回到磁盘里去，这就是随机IO的过程。如果说IOPS指标太低了，那么会导致你内存里的脏数据刷回磁盘的效率就会不高

> 吞吐量：这个指的是机器的磁盘存储每秒可以读写多少字节的数据量

所以一台机器他的存储每秒可以读写多少字节的数据量，就决定了他每秒可以把多少redo log之类的日志写入到磁盘里去

一 般来说我们写redo log之类的日志，都是对磁盘文件进行顺序写入的，也就是一行接着一行的写，不会说进行随机的读写，那 么一般普通磁盘的顺序写入的吞吐量每秒都可以达到200MB左右

> latency：这个指标说的是往磁盘里写入一条数据的延迟

因为我们执行SQL语句和提交事务的时候，都需要顺序写redo log磁盘文件，所以此时你写一条日志到 磁盘文件里去，到底是延迟1ms，还是延迟100us，这就对你的数据库的SQL语句执行性能是有影响的

[生产经验：如何对生产环境中的数据库进行360度无死角压测](https://www.cnblogs.com/klvchen/articles/12901727.html)

**生产经验：在数据库的压测过程中，如何360度无死角观察机器性能**

如何观察机器的磁盘IO情况：使用dstat -d命令

观察网卡的流量情况：可以使用dstat -n命令

**生产经验：如何为生产环境中的数据库部署监控系统**

Prometheus其实就是一个监控数据采集和存储系统，他可以利用监控数据采集组件（比如`mysql_exporter`）从你 指定的MySQL数据库中采集他需要的监控数据，然后他自己有一个时序数据库，他会把采集到的监控数据放入自己的时序数 据库中，其实本质就是存储在磁盘文件里

Grafana就是一个可视化的监控数据展示系统，他可以把Prometheus采集到的大量的MySQL监控数据展示成各种精美的报表，让我们可以直观的看到MySQL的监控情况

# 事务

**脏写** 

事务B去修改了事务A修改过的值，但是此时事务A还没提交，所以事务A随时会回滚， 导致事务B修改的值也没了

**脏读**

事务B去查询了事务A修改过的数据，但是此时事务A还没提交，所以事务A随时会回滚导致事务B再次查询就读不到刚才事务A修改的数据了

无论是脏写还是脏读，都是因为一个事务去更新或者查询了另外一个还没提交的事务更新过的数据

因为另外一个事务还没提交，所以他随时可能会反悔会回滚，那么必然导致你更新的数据就没了，或者你之前查询到的数据就没了

# MVCC

**undo log版本链**

我们每条数据其实都有两个隐藏字段，一个是`trx_id`，一个是`roll_pointer`，这个`trx_id`就 是最近一次更新这条数据的事务id，`roll_pointer`就是指向你了你更新这个事务之前生成的undo log

这个多个事务串行更新一行数据的时候，undo log串联起来的多版本链条

## ReadView

你执行一个事务的时候，就给你生成一个ReadView，里面比较关键 的东西有4个

一个是`m_ids`，这个就是说此时有哪些事务在MySQL里执行还没提交的； 

一个是`min_trx_id`，就是`m_ids`里最小的值； 

一个是`max_trx_id`，这是说mysql下一个要生成的事务id，就是最大事务id； 

一个是`creator_trx_id`，就是你这个事务的id

