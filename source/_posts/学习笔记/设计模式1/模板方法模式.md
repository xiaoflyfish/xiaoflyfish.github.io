---
title: 模板方法模式
categories: 
- 学习笔记
- 设计模式1
---

**模板模式的原理与实现**

模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现

模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤

templateMethod()函数定义为final，是为了避免子类重写它。method1()和method2()定义为abstract，是为了强迫子类去实现。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活

```java
public class AbstractClass {
  public final void templateMethod() {
    //...
    method1();
    //...
    method2();
    //...
  }
  
  protected abstract void method1();
  protected abstract void method2();
}

public class ContreteClass1 extends AbstractClass {
  @Override
  protected void method1() {
    //...
  }
  
  @Override
  protected void method2() {
    //...
  }
}

public class ContreteClass2 extends AbstractClass {
  @Override
  protected void method1() {
    //...
  }
  
  @Override
  protected void method2() {
    //...
  }
}

AbstractClass demo = ContreteClass1();
demo.templateMethod();
```

**模板模式作用一：复用**

模板模式把一个算法中不变的流程抽象到父类的模板方法templateMethod()中，将可变的部分method1()、method2()留给子类ContreteClass1和ContreteClass2来实现

所有的子类都可以复用父类中模板方法定义的流程代码

我们通过两个小例子来更直观地体会一下

**Java InputStream**

Java IO类库中，有很多类的设计用到了模板模式，比如InputStream、OutputStream、Reader、Writer

我们拿InputStream来举例说明一下

我把InputStream部分相关代码贴在了下面。在代码中，read()函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了read()，只是参数跟模板方法不同

```java
public abstract class InputStream implements Closeable {
  //...省略其他代码...
  
  public int read(byte b[], int off, int len) throws IOException {
    if (b == null) {
      throw new NullPointerException();
    } else if (off < 0 || len < 0 || len > b.length - off) {
      throw new IndexOutOfBoundsException();
    } else if (len == 0) {
      return 0;
    }

    int c = read();
    if (c == -1) {
      return -1;
    }
    b[off] = (byte)c;

    int i = 1;
    try {
      for (; i < len ; i++) {
        c = read();
        if (c == -1) {
          break;
        }
        b[off + i] = (byte)c;
      }
    } catch (IOException ee) {
    }
    return i;
  }
  
  public abstract int read() throws IOException;
}

public class ByteArrayInputStream extends InputStream {
  //...省略其他代码...
  
  @Override
  public synchronized int read() {
    return (pos < count) ? (buf[pos++] & 0xff) : -1;
  }
}
```

**Java AbstractList**

在Java AbstractList类中，addAll()函数可以看作模板方法，add()是子类需要重写的方法，尽管没有声明为abstract的，但函数实现直接抛出了UnsupportedOperationException异常

前提是，如果子类不重写是不能使用的

```java
public boolean addAll(int index, Collection<? extends E> c) {
    rangeCheckForAdd(index);
    boolean modified = false;
    for (E e : c) {
        add(index++, e);
        modified = true;
    }
    return modified;
}

public void add(int index, E element) {
    throw new UnsupportedOperationException();
}
```

**模板模式作用二：扩展**

我们现在来看，HttpServlet的service()函数长什么样子

```java
public void service(ServletRequest req, ServletResponse res)
    throws ServletException, IOException
{
    HttpServletRequest  request;
    HttpServletResponse response;
    
    if (!(req instanceof HttpServletRequest &&
            res instanceof HttpServletResponse)) {
        throw new ServletException("non-HTTP request or response");
    }

    request = (HttpServletRequest) req;
    response = (HttpServletResponse) res;

    service(request, response);
}

protected void service(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException
{
    String method = req.getMethod();

    if (method.equals(METHOD_GET)) {
        long lastModified = getLastModified(req);
        if (lastModified == -1) {
            // servlet doesn't support if-modified-since, no reason
            // to go through further expensive logic
            doGet(req, resp);
        } else {
            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);
            if (ifModifiedSince < lastModified) {
                // If the servlet mod time is later, call doGet()
                // Round down to the nearest second for a proper compare
                // A ifModifiedSince of -1 will always be less
                maybeSetLastModified(resp, lastModified);
                doGet(req, resp);
            } else {
                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
            }
        }

    } else if (method.equals(METHOD_HEAD)) {
        long lastModified = getLastModified(req);
        maybeSetLastModified(resp, lastModified);
        doHead(req, resp);

    } else if (method.equals(METHOD_POST)) {
        doPost(req, resp);
        
    } else if (method.equals(METHOD_PUT)) {
        doPut(req, resp);
        
    } else if (method.equals(METHOD_DELETE)) {
        doDelete(req, resp);
        
    } else if (method.equals(METHOD_OPTIONS)) {
        doOptions(req,resp);
        
    } else if (method.equals(METHOD_TRACE)) {
        doTrace(req,resp);
        
    } else {
        //
        // Note that this means NO servlet supports whatever
        // method was requested, anywhere on this server.
        //

        String errMsg = lStrings.getString("http.method_not_implemented");
        Object[] errArgs = new Object[1];
        errArgs[0] = method;
        errMsg = MessageFormat.format(errMsg, errArgs);
        
        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);
    }
}
```

从上面的代码中我们可以看出，HttpServlet的service()方法就是一个模板方法，它实现了整个HTTP请求的执行流程，doGet()、doPost()是模板中可以由子类来定制的部分

实际上，这就相当于Servlet框架提供了一个扩展点（doGet()、doPost()方法），让框架用户在不用修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行

# 回调

相对于普通的函数调用来说，替代是一种双向调用关系

A类预先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”

```java
public interface ICallback {
  void methodToCallback();
}

public class BClass {
  public void process(ICallback callback) {
    //...
    callback.methodToCallback();
    //...
  }
}

public class AClass {
  public static void main(String[] args) {
    BClass b = new BClass();
    b.process(new ICallback() { //回调对象
      @Override
      public void methodToCallback() {
        System.out.println("Call back me.");
      }
    });
  }
}
```

实际上，回调不仅可以应⽤在代码设计上，在更⾼层次的架构设计上也⽐较常⽤。⽐如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，⼀般不会⼀直阻塞到⽀付结果返回，⽽是注册回调接⼝（类似回调函数，⼀般是⼀个回调⽤的URL）给三⽅⽀付系统，等三⽅⽀付系统执⾏完成之后，将结果通过回调接⼝返回给⽤⼾。

回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在函数返回之前执⾏回调函数；异步回调指的是在函数返回之后执⾏回调函数。上⾯的代码实际上是同步回调的实现⽅式，在process()函数返回之前，执⾏完回调函数methodToCallback()。⽽上⾯⽀付的例⼦是异步回调的实现⽅式，发起⽀付之后不需要等待回调接⼝被调⽤就直接返回。从应⽤场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式

**应用实例一：JdbcTemplate**

Spring提供了很多模板Template类，例如，JdbcTemplate，RedisTemplate，RestTemplate。虽然都叫作xxxTemplate，但它们并非基于模板模式来实现的，⽽是基于回调来实现的，确切地说应该是同步回调。⽽同步回调从应⽤场景上很像模板模式，所以，在命名上，这些类使⽤Template（模板）这个单词作为后缀。

Java提供了JDBC类库来封装不同类型的数据库操作。不过，直接使用JDBC来编写操作数据库的代码，还是有点复杂的。⽐如，下⾯这段是使⽤JDBC来查询⽤⼾信息的代码

```java
public class JdbcDemo {
  public User queryUser(long id) {
    Connection conn = null;
    Statement stmt = null;
    try {
      //1.加载驱动
      Class.forName("com.mysql.jdbc.Driver");
      conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/demo", "xzg", "xzg");

      //2.创建statement类对象，用来执行SQL语句
      stmt = conn.createStatement();

      //3.ResultSet类，用来存放获取的结果集
      String sql = "select * from user where id=" + id;
      ResultSet resultSet = stmt.executeQuery(sql);

      String eid = null, ename = null, price = null;

      while (resultSet.next()) {
        User user = new User();
        user.setId(resultSet.getLong("id"));
        user.setName(resultSet.getString("name"));
        user.setTelephone(resultSet.getString("telephone"));
        return user;
      }
    } catch (ClassNotFoundException e) {
      // TODO: log...
    } catch (SQLException e) {
      // TODO: log...
    } finally {
      if (conn != null)
        try {
          conn.close();
        } catch (SQLException e) {
          // TODO: log...
        }
      if (stmt != null)
        try {
          stmt.close();
        } catch (SQLException e) {
          // TODO: log...
        }
    }
    return null;
  }

}
```

queryUser()函数包含很多流程性质的代码，跟业务无关，例如，加载驱动，创建数据库连接，创建statement，关闭连接，关闭语句，处理异常。针对不同的SQL执行请求，这些流程性质的代码是相同的的，可以复⽤的，我们不需要每次都重新敲一遍。

针对这个问题，Spring提供了JdbcTemplate，对JDBC进一步封装，来简化数据库编程。使用JdbcTemplate查询用户信息，我们只需要编写跟这个业务相关的代码，其中包括，查询⽤⼾的SQL语句、查询结果与User对象之间的映射关系。其他流程性质的代码都封装在了JdbcTemplate类中，不需要我们每次都重新编写。我⽤JdbcTemplate重写了上⾯的例⼦，代码简单了很多，如下所⽰：

```java
public class JdbcTemplateDemo {
  private JdbcTemplate jdbcTemplate;

  public User queryUser(long id) {
    String sql = "select * from user where id="+id;
    return jdbcTemplate.query(sql, new UserRowMapper()).get(0);
  }

  class UserRowMapper implements RowMapper<User> {
    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
      User user = new User();
      user.setId(rs.getLong("id"));
      user.setName(rs.getString("name"));
      user.setTelephone(rs.getString("telephone"));
      return user;
    }
  }
}
```

那JdbcTemplate底层具体是如何实现的呢？我们来看⼀下它的源码。因为JdbcTemplate代码⽐较多，我只摘抄了部分相关代码，贴到了下⾯。其中，JdbcTemplate通过回调的机制，将不变的执⾏流程抽离出来，放到模板⽅法execute()中，将可变的部分设计成回调StatementCallback，由用户来定制。query()函数是对execute()函数的⼆次封装，让接⼝⽤起来更加⽅便

```java
@Override
public <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {
 	return query(sql, new RowMapperResultSetExtractor<T>(rowMapper));
}

@Override
public <T> T query(final String sql, final ResultSetExtractor<T> rse) throws DataAccessException {
 	Assert.notNull(sql, "SQL must not be null");
	Assert.notNull(rse, "ResultSetExtractor must not be null");
 	if (logger.isDebugEnabled()) {
 		logger.debug("Executing SQL query [" + sql + "]");
 	}
	
	class QueryStatementCallback implements StatementCallback<T>, SqlProvider {
    	@Override
  		public T doInStatement(Statement stmt) throws SQLException {
   			ResultSet rs = null;
   			try {
    			rs = stmt.executeQuery(sql);
    			ResultSet rsToUse = rs;
    			if (nativeJdbcExtractor != null) {
     				rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);
    			}
    			return rse.extractData(rsToUse);
   			}
   			finally {
    			JdbcUtils.closeResultSet(rs);
   			}
  		}
  		@Override
  		public String getSql() {
   			return sql;
  		}
 	}

	return execute(new QueryStatementCallback());
}

@Override
public <T> T execute(StatementCallback<T> action) throws DataAccessException {
 	Assert.notNull(action, "Callback object must not be null");

 	Connection con = DataSourceUtils.getConnection(getDataSource());
 	Statement stmt = null;
 	try {
  		Connection conToUse = con;
  		if (this.nativeJdbcExtractor != null &&
    this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) {
   			conToUse = this.nativeJdbcExtractor.getNativeConnection(con);
  		}
  		stmt = conToUse.createStatement();
  		applyStatementSettings(stmt);
  		Statement stmtToUse = stmt;
  		if (this.nativeJdbcExtractor != null) {
   			stmtToUse = this.nativeJdbcExtractor.getNativeStatement(stmt);
  		}
  		T result = action.doInStatement(stmtToUse);
  		handleWarnings(stmt);
  		return result;
 	} catch (SQLException ex) {
  		// Release Connection early, to avoid potential connection pool deadlock
  		// in the case when the exception translator hasn't been initialized yet.
  		JdbcUtils.closeStatement(stmt);
  		stmt = null;
  		DataSourceUtils.releaseConnection(con, getDataSource());
  		con = null;
  		throw getExceptionTranslator().translate("StatementCallback", getSql(action), ex);
 	} finally {
  		JdbcUtils.closeStatement(stmt);
  		DataSourceUtils.releaseConnection(con, getDataSource());
 	}
}
```

**应用实例二：setClickListener()**

在客户端开发中，我们经常给控件注册事件监听器，按下面的代码，就是在Android应用开发中，给按钮控件的单击事件注册监听器

```java
Button button = (Button)findViewById(R.id.button);
button.setOnClickListener(new OnClickListener() {
  @Override
  public void onClick(View v) {
    System.out.println("I am clicked.");
  }
});
```

从应用程序上来看，它又很像观察者模式，即事先注册观察者（OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并执行相应的onClick()函数。

我们前⾯讲到，回调分为同步回调和异步回调。这⾥的回调算是异步回调，我们往setOnClickListener()函数中注册好回调函数之后，并不需要等待回调函数执⾏。这也印证了我们前⾯讲的，异步回调⽐较像观察者模式。

**应用实例三：addShutdownHook()**

Hook⽐较经典的应⽤场景是Tomcat和JVM的shutdown hook。接下来，我们拿JVM来举例说明⼀下。JVM提供了`Runtime.addShutdownHook(Thread hook)`⽅法，可以注册⼀个JVM关闭的Hook。当应⽤程序关闭的时候，JVM会⾃动调⽤Hook代码。代码⽰例如下所⽰：

```java
public class ShutdownHookDemo {

  private static class ShutdownHook extends Thread {
    public void run() {
      System.out.println("I am called during shutting down.");
    }
  }

  public static void main(String[] args) {
    Runtime.getRuntime().addShutdownHook(new ShutdownHook());
  }

}
```

我们再来看addShutdownHook()的代码实现，如下所示。这⾥我只给出了部分相关代码。

```java
public class Runtime {
  public void addShutdownHook(Thread hook) {
    SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
      sm.checkPermission(new RuntimePermission("shutdownHooks"));
    }
    ApplicationShutdownHooks.add(hook);
  }
}

class ApplicationShutdownHooks {
    /* The set of registered hooks */
    private static IdentityHashMap<Thread, Thread> hooks;
    static {
            hooks = new IdentityHashMap<>();
        } catch (IllegalStateException e) {
            hooks = null;
        }
    }

    static synchronized void add(Thread hook) {
        if(hooks == null)
            throw new IllegalStateException("Shutdown in progress");

        if (hook.isAlive())
            throw new IllegalArgumentException("Hook already running");

        if (hooks.containsKey(hook))
            throw new IllegalArgumentException("Hook previously registered");

        hooks.put(hook, hook);
    }

    static void runHooks() {
        Collection<Thread> threads;
        synchronized(ApplicationShutdownHooks.class) {
            threads = hooks.keySet();
            hooks = null;
        }

        for (Thread hook : threads) {
            hook.start();
        }
        for (Thread hook : threads) {
            while (true) {
                try {
                    hook.join();
                    break;
                } catch (InterruptedException ignored) {
                }
            }
        }
    }
}
```

从代码中我们可以发现，有关Hook的逻辑都被封装到ApplicationShutdownHooks类中了。当应⽤程序关闭的时候，JVM会调⽤这个类的runHooks()⽅法，创建多个线程，并发地执⾏多个Hook。我们在注册完Hook之后，并不需要等待Hook执⾏完成，所以，这也算是⼀种异步回调

**模板模式VS回调**

从应⽤场景上来看 ，同步回调跟模板模式⼏乎⼀致。它们都是在⼀个⼤的算法⻣架中，⾃由替换其中的某个步骤，起到代码复⽤和扩展的⽬的。⽽异步回调跟模板模式有较⼤差别，更像是观察者模式。

从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把⼀个对象传递给另⼀个对象，是⼀种对象之间的关系；模板模式基于继承关系来实现，⼦类重写⽗类的抽象⽅法，是⼀种类之间的关系。

组合优于继承。实际上，这⾥也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下⾯⼏点。

- 像Java这种只⽀持单继承的语⾔，基于模板模式编写的⼦类，已经继承了⼀个⽗类，不再具有继承的能⼒。
- 回调可以使⽤匿名类来创建回调对象，可以不⽤事先定义类；⽽模板模式针对不同的实现都要定义不同的⼦类。
- 如果某个类中定义了多个模板⽅法，每个⽅法都有对应的抽象⽅法，那即便我们只⽤到其中的⼀个模板⽅法，⼦类也必须实现所有的抽象⽅法。⽽回调就更加灵活，我们只需要往⽤到的模板⽅法中注⼊回调对象即可。