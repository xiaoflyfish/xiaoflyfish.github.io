---
title: 充血模型
categories: 
- 学习笔记
- 设计模式1
---

**钱包业务背景介绍**

很多具有支付、购买功能的应用（比如淘宝、滴滴出行、极客时间等）都支持钱包的功能。应用为每个用户开设一个系统内的虚拟钱包账户，支持用户充值、提现、支付、冻结、透支、转赠、查询账户余额、查询交易流水等操作

一般来讲，每个虚拟钱包账户都会对应用户的一个真实的支付账户，有可能是银行卡账户，也有可能是三方支付账户（比如支付宝、微信钱包）

我们来一块儿看下它们的业务实现流程

**充值**

用户通过三方支付渠道，把自己银行卡账户内的钱，充值到虚拟钱包账号中。

这整个过程，我们可以分解为三个主要的操作流程：第一个操作是从用户的银行卡账户转账到应用的公共银行卡账户；第二个操作是将用户的充值金额加到虚拟钱包余额上；第三个操作是记录刚刚这笔交易流水

**支付**

用户用钱包内的余额，支付购买应用内的商品。实际上，支付的过程就是一个转账的过程，从用户的虚拟钱包账户划钱到商家的虚拟钱包账户上，然后触发真正的银行转账操作，从应用的公共银行账户转钱到商家的银行账户（注意，这里并不是从用户的银行账户转钱到商家的银行账户）。除此之外，我们也需要记录这笔支付的交易流水信息

**提现**

除了充值、支付之外，用户还可以将虚拟钱包中的余额，提现到自己的银行卡中。这个过程实际上就是扣减用户虚拟钱包中的余额，并且触发真正的银行转账操作，从应用的公共银行账户转钱到用户的银行账户。同样，我们也需要记录这笔提现的交易流水信息

**查询余额**

查询余额功能比较简单，我们看一下虚拟钱包中的余额数字即可。

**查询交易流水**

查询交易流水也比较简单。我们只支持三种类型的交易流水：充值、支付、提现。在用户充值、支付、提现的时候，我们会记录相应的交易信息。在需要查询的时候，我们只需要将之前记录的交易流水，按照时间、类型等条件过滤之后，显示出来即可

**基于贫血模型的传统开发模式**

利用基于贫血模型的传统开发模式来实现这样一个系统，应该是一件挺简单的事情

这是一个典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，Controller 中接口实现比较简单，主要就是调用Service 的方法

**基于充血模型的 DDD 开发模式**

在这种开发模式下，我们把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模型，并且将原来在Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让Service 类的实现依赖 VirtualWallet 类

具体的代码实现如下所示：

```java
public class VirtualWallet { // Domain 领域模型 (充血模型)
	private Long id;
	private Long createTime = System.currentTimeMillis();;
	private BigDecimal balance = BigDecimal.ZERO;
	
	public VirtualWallet(Long preAllocatedId) {
		this.id = preAllocatedId;
	}
	
	public BigDecimal balance() {
		return this.balance;
	}
	
	public void debit(BigDecimal amount) {
		if (this.balance.compareTo(amount) < 0) {
			throw new InsufficientBalanceException(...);
		}
		this.balance.subtract(amount);
	}
	
	public void credit(BigDecimal amount) {
		if (amount.compareTo(BigDecimal.ZERO) < 0) {
			throw new InvalidAmountException(...);
		}
		this.balance.add(amount);
	}
}

public class VirtualWalletService {
	// 通过构造函数或者 IOC 框架注入
	private VirtualWalletRepository walletRepo;
	private VirtualWalletTransactionRepository transactionRepo;
	
	public VirtualWallet getVirtualWallet(Long walletId) {
		VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
		VirtualWallet wallet = convert(walletEntity);
		return wallet;
	}
	
	public BigDecimal getBalance(Long walletId) {
		return virtualWalletRepo.getBalance(walletId);
	}

	public void debit(Long walletId, BigDecimal amount) {
		VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
		VirtualWallet wallet = convert(walletEntity);
		wallet.debit(amount);
		walletRepo.updateBalance(walletId, wallet.balance());
	}

	public void credit(Long walletId, BigDecimal amount) {
		VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
		VirtualWallet wallet = convert(walletEntity);
		wallet.credit(amount);
		walletRepo.updateBalance(walletId, wallet.balance());
	}

	public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount
		//... 跟基于贫血模型的传统开发模式的代码一样...
	}

}
```

看了上面的代码，你可能会说，领域模型 VirtualWallet 类很单薄，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大优势。你说得没错！这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这个时候，我们重新来看一下VirtualWallet 类的实现代码

```java
public class VirtualWallet {
	private Long id;
	private Long createTime = System.currentTimeMillis();;
	private BigDecimal balance = BigDecimal.ZERO;
	private boolean isAllowedOverdraft = true;
	private BigDecimal overdraftAmount = BigDecimal.ZERO;
	private BigDecimal frozenAmount = BigDecimal.ZERO;
	
	public VirtualWallet(Long preAllocatedId) {
		this.id = preAllocatedId;
	}
	
	public void freeze(BigDecimal amount) { ... }

	public void unfreeze(BigDecimal amount) { ...}

	public void increaseOverdraftAmount(BigDecimal amount) { ... }

	public void decreaseOverdraftAmount(BigDecimal amount) { ... }

	public void closeOverdraft() { ... }

	public void openOverdraft() { ... }

	public BigDecimal balance() {
		return this.balance;
	}

	public BigDecimal getAvaliableBalance() {
		BigDecimal totalAvaliableBalance = this.balance.subtract(this.frozenAmou
		if (isAllowedOverdraft) {
			totalAvaliableBalance += this.overdraftAmount;
		}
		return totalAvaliableBalance;
	}

	public void debit(BigDecimal amount) {
		BigDecimal totalAvaliableBalance = getAvaliableBalance();
		if (totoalAvaliableBalance.compareTo(amount) < 0) {
			throw new InsufficientBalanceException(...);
		}
		this.balance.subtract(amount);
	}

	public void credit(BigDecimal amount) {
		if (amount.compareTo(BigDecimal.ZERO) < 0) {
			throw new InvalidAmountException(...);
		}
		this.balance.add(amount);
	}
}
```

领域模型 VirtualWallet 类添加了简单的冻结和透支逻辑之后，功能看起来就丰富了很多，代码也没那么单薄了

如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号（VirtualWallet id 字段）自动生成的逻辑（不是通过构造函数经外部传入 ID，而是通过分布式 ID 生成算法来自动生成 ID）等等。VirtualWallet 类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了

**在基于充血模型的 DDD 开发模式中，将业务逻辑移动到Domain 中，Service 类变得很薄，但在我们的代码设计与实现中，并没有完全将Service 类去掉，这是为什么？或者说，Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？**

区别于 Domain 的职责，Service 类主要有下面这样几个职责。

1. Service 类负责与 Repository 交流。在我的设计与代码实现中，VirtualWalletService类负责与 Repository 层打交道，调用 Respository 类的方法，获取数据库中的数据，转化成领域模型 VirtualWallet，然后由领域模型 VirtualWallet 来完成业务逻辑，最后调用 Repository 类的方法，将数据存回数据库。

这里再稍微解释一下，之所以让 VirtualWalletService 类与 Repository 打交道，而不是让领域模型 VirtualWallet 与 Repository 打交道，那是因为我们想保持领域模型的独立性，不与任何其他层的代码（Repository 层的代码）或开发框架（比如 Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从 DB 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。

1. Service 类负责跨领域模型的业务聚合功能。VirtualWalletService 类中的 transfer()转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中，所以，我们暂且把转账业务放到 VirtualWalletService 类中了。当然，虽然功能演进，使得转账业务变得复杂起来之后，我们也可以将转账业务抽取出来，设计成一个独立的领域模型。
2. Service 类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等，都可以放到 Service 类中。

**在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？**

答案是没有必要。Controller 层主要负责接口的暴露，Repository 层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面也提到了，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。

拿 Repository 的 Entity 来说，即便它被设计成贫血模型，违反面相对象编程的封装特性，有被任意代码修改数据的风险，但 Entity 的生命周期是有限的。一般来讲，我们把它传递到 Service 层之后，就会转化成 BO 或者 Domain 来继续后面的业务逻辑。Entity 的生命周期到此就结束了，所以也并不会被到处任意修改。

再来说说 Controller 层的 VO。实际上 VO 是一种 DTO（Data Transfer Object，数据传输对象）。它主要是作为接口的数据传输承载体，将数据发送给其他系统。从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，我们将它设计成贫血模型也是比较合理的。