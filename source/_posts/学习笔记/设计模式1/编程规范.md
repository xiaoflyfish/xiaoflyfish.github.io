---
title: 编程规范
categories: 
- 学习笔记
- 设计模式1
---

# 命名

**利用上下文简化命名**

```java
public class User {
	private String userName;
	private String userPassword;
	private String userAvatarUrl;
	//...
}
```

在 User 类这样一个上下文中，我们没有在成员变量的命名中重复添加“user”这样一个前缀单词，而是直接命名为 name、password、avatarUrl

除了类之外，函数参数也可以借助函数这个上下文来简化命名

```java
public void uploadUserAvatarImageToAliyun(String userAvatarImageUri);
// 利用上下文简化为：
public void uploadUserAvatarImageToAliyun(String imageUri);
```

**如何命名接口和抽象类**

对于接口的命名，一般有两种比较常见的方式。一种是加前缀“I”，表示一个 Interface。比如 IUserService，对应的实现类命名为 UserService。另一种是不加前缀，比如UserService，对应的实现类加后缀“Impl”，比如 UserServiceImpl。

对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，比如AbstractConfiguration；另一种是不带前缀“Abstract”。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行

# 注释

**一些总结性注释能让代码结构更清晰**

对于逻辑比较复杂的代码或者比较长的函数，如果不好提炼、不好拆分成小的函数调用，那我们可以借助总结性的注释来让代码结构更清晰、更有条理

```java
public boolean isValidPasword(String password) {
	// check if password is null or empty
	if (StringUtils.isBlank(password)) {
		return false;
	}
	// check if the length of password is between 4 and 64
	int length = password.length();
	if (length < 4 || length > 64) {
		return false;
	}
	// check if password contains only lowercase characters
	if (!StringUtils.isAllLowerCase(password)) {
		return false;
	}
	// check if password contains only a~z,0~9,dot
	for (int i = 0; i < length; ++i) {
		char c = password.charAt(i);
		if (!(c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '.') {
			return false;
		}
	}
	return true;
}
```

# 函数

**把代码分割成更小的单元块**

这里我举一个例子来进一步解释一下。代码具体如下所示。重构前，在 invest() 函数中，最开始的那段关于时间处理的代码，是不是很难看懂？重构之后，我们将这部分逻辑抽象成一个函数，并且命名为 isLastDayOfMonth，从名字就能清晰地了解它的功能，判断今天是不是当月的最后一天。这里，我们就是通过将复杂的逻辑代码提炼成函数，大大提高了代码的可读性

```java
// 重构前的代码
public void invest(long userId, long financialProductId) {
	Calendar calendar = Calendar.getInstance();
	calendar.setTime(date);
	calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));
	if (calendar.get(Calendar.DAY_OF_MONTH) == 1) {
		return;
	}
	//...
}
// 重构后的代码：提炼函数之后逻辑更加清晰
public void invest(long userId, long financialProductId) {
	if (isLastDayOfMonth(new Date())) {
		return;
	}
	//...
}
public boolean isLastDayOfMonth(Date date) {
	Calendar calendar = Calendar.getInstance();
	calendar.setTime(date);
	calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));
	if (calendar.get(Calendar.DAY_OF_MONTH) == 1) {
		return true;
	}
	return false;
}
```

**避免函数参数过多**

我个人觉得，函数包含 3、4 个参数的时候还是能接受的，大于等于 5 个的时候，我们就觉得参数有点过多了，会影响到代码的可读性，使用起来也不方便。针对参数过多的情况，一般有 2 种处理方法。

考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。示例代码如下所示：

```java
public void getUser(String username, String telephone, String email);

// 拆分成多个函数
public void getUserByUsername(String username);
public void getUserByTelephone(String telephone);
public void getUserByEmail(String email);
```

将函数的参数封装成对象。示例代码如下所示：

```java
public void postBlog(String title, String summary, String keywords, String cont
// 将参数封装成对象
public class Blog {
	private String title;
	private String summary;
	private String keywords;
	private Strint content;
	private String category;
	private long authorId;
}
public void postBlog(Blog blog);
```

除此之外，如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了

**勿用函数参数来控制逻辑**

不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。我建议将其拆成两个函数，可读性上也要更好。我举个例子来说明一下

```java
public void buyCourse(long userId, long courseId, boolean isVip);
// 将其拆分成两个函数
public void buyCourse(long userId, long courseId);
public void buyCourseForVip(long userId, long courseId);
```

不过，如果函数是 private 私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，我们可以酌情考虑保留标识参数。示例代码如下所示：

```java
// 拆分成两个函数的调用方式
boolean isVip = false;
//...省略其他逻辑...
if (isVip) {
	buyCourseForVip(userId, courseId);
} else {
	buyCourse(userId, courseId);
}

// 保留标识参数的调用方式更加简洁
boolean isVip = false;
//...省略其他逻辑...
buyCourse(userId, courseId, isVip);
```

除了布尔类型作为标识参数来控制逻辑的情况外，还有一种“根据参数是否为 null”来控制逻辑的情况。针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错。具体代码示例如下所示：

```java
public List<Transaction> selectTransactions(Long userId, Date startDate, Date e
	if (startDate != null && endDate != null) {
		// 查询两个时间区间的transactions
	}
	if (startDate != null && endDate == null) {
		// 查询startDate之后的所有transactions
	}
	if (startDate == null && endDate != null) {
		// 查询endDate之前的所有transactions
	}
	if (startDate == null && endDate == null) {
		// 查询所有的transactions
	}
}

// 拆分成多个public函数，更加清晰、易用
public List<Transaction> selectTransactionsBetween(Long userId, Date startDate
	return selectTransactions(userId, startDate, endDate);
}
public List<Transaction> selectTransactionsStartWith(Long userId, Date startDat
	return selectTransactions(userId, startDate, null);
}
public List<Transaction> selectTransactionsEndWith(Long userId, Date endDate) {
	return selectTransactions(userId, null, endDate);
}
public List<Transaction> selectAllTransactions(Long userId) {
	return selectTransactions(userId, null, null);
}
private List<Transaction> selectTransactions(Long userId, Date startDate, Date
	// ...
}
```

**函数设计要职责单一**

我们在前面讲到单一职责原则的时候，针对的是类、模块这样的应用对象。

实际上，对于函数的设计来说，更要满足单一职责原则。相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一。

具体的代码示例如下所示：

```java
public boolean checkUserIfExisting(String telephone, String username, String em
	if (!StringUtils.isBlank(telephone)) {
		User user = userRepo.selectUserByTelephone(telephone);
		return user != null;
	}
	if (!StringUtils.isBlank(username)) {
		User user = userRepo.selectUserByUsername(username);
		return user != null;
	}
	if (!StringUtils.isBlank(email)) {
		User user = userRepo.selectUserByEmail(email);
		return user != null;
	}
	return false;
}

// 拆分成三个函数
public boolean checkUserIfExistingByTelephone(String telephone);
public boolean checkUserIfExistingByUsername(String username);
public boolean checkUserIfExistingByEmail(String email);
```

