---
title: MySLQ1
categories: 
- 学习笔记
---

# 执行SQL语句

**网络连接必须让线程来处理**

现在假设我们的数据库服务器的连接池中的某个连接接收到了网络请求，假设就是一条SQL语句，那么大家先思考一个问题， 谁负责从这个连接中去监听网络请求，谁负责从网络连接里把请求数据读取出来

如果大家对计算机基础知识有一个简单了解的话，应该或多或少知道一点，那就是网络连接必须得分配给一个线程去进行处理，由一个线程来监听请求以及读取请求数据，比如从网络连接中读取和解析出来一 条我们的系统发送过去的SQL语句

**SQL接口:负责处理接收到的SQL语句**

当MySQL内部的工作线程从一个网络连接中读取出来一个SQL语句之后，此时会如何来执行这个SQL语 句呢

MySQL内部首先提供了一个组件，就是SQL接口，他是一套执行SQL语句的接口，专门用于执行我们 发送给MySQL的那些增删改查的SQL语句

因此MySQL的工作线程接收到SQL语句之后，就会转交给SQL接口去执行

**查询解析器:让MySQL能看懂SQL语句**

这个查询解析器就是负责对SQL语句进行解析的

所谓的SQL解析，就是按照既定的SQL语法，对我们按照SQL语法规则编写的SQL语句进行解析，然后理解这个SQL语句要干什么事情

**查询优化器:选择最优的查询路径**

当我们通过解析器理解了SQL语句要干什么之后，接着会找查询优化器来选择一个最优的查询路径

**调用存储引擎接口，真正执行SQL语句**

最后一步，就是把查询优化器选择的最优查询路径，也就是你到底应该按照一个什么样的顺序和步骤去执行这个SQL语句的计 划，把这个计划交给底层的存储引擎去真正的执行

所以我们来思考一下，假设我们的数据有的存放在内存里，有的存放在磁盘文件里

所以这个时候就需要存储引擎了，存储引擎其实就是执行SQL语句的，他会按照一定的步骤去查询内存缓存数据，更新磁盘数 据，查询磁盘数据，等等，执行诸如此类的一系列的操作

**执行器：根据执行计划调用存储引擎的接口**

执行器就会去根据我们的优化器生成的一套执行计划，然后不停的调用存储引擎的各种接口去完成SQL 语句的执行计划，大致就是不停的更新或者提取一些数据出来

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210209231054.png" style="zoom:30%;" />

# SQL更新

**缓冲池**

InnoDB存储引擎中有一个非常重要的放在内存里的组件，就是缓冲池（Buffer Pool），这里面会缓存很多的数据， 以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了

引擎要执行更新语句的时候 ，比如对`id=10`这一行数据，他其实会先将`id=10`这一行数据看看是否在缓冲池里，如果不在的 话，那么会直接从磁盘里加载到缓冲池里来，而且接着还会对这行记录加独占锁。

因为我们想一下，在我们更新`id=10`这一行数据的时候，肯定是不允许别人同时更新的，所以必须要对这行记录加 独占锁

**undo日志文件：如何让你更新的数据可以回滚**

接着下一步，假设“id=10”这行数据的name原来是“zhangsan”，现在我们要更新为“xxx”，那么此时我们得先 把要更新的原来的值“zhangsan”和“id=10”这些信息，写入到undo日志文件中去。 

**更新buffer pool中的缓存数据**

当我们把要更新的那行记录从磁盘文件加载到缓冲池，同时对他加锁之后，而且还把更新前的旧值写入undo日志文件 之后，我们就可以正式开始更新这行记录了，更新的时候，先是会更新缓冲池中的记录，此时这个数据就是脏数据 了。

这里所谓的更新内存缓冲池里的数据，意思就是把内存里的“id=10”这行数据的name字段修改为“xxx”

那么为什么说此时这行数据就是脏数据了呢？ 因为这个时候磁盘上“id=10”这行数据的name字段还是“zhangsan”，但是内存里这行数据已经被修改了，所以 就会叫他是脏数据。

**Redo Log Buffer：万一系统宕机，如何避免数据丢失**

现在已经把内存里的数据进行了修改，但是磁盘上的数据还没修改

那么此时万一MySQL所在的机器宕机了，必然会导致内存里修改过的数据丢失，这可怎么办呢？ 这个时候，就必须要把对内存所做的修改写入到一个Redo Log Buffer里去，这也是内存里的一个缓冲区，是用来存 放redo日志的

所谓的redo日志，就是记录下来你对数据做了什么修改，比如对“id=10这行记录修改了name字段的值为xxx”，这 就是一个日志

**提交事务的时候将redo日志写入磁盘中** 

接着我们想要提交一个事务了，此时就会根据一定的策略把redo日志从redo log buffer里刷入到磁盘文件里去

此时这个策略是通过`innodb_flush_log_at_trx_commit`来配置的，他有几个选项。 当这个参数的值为0的时候，那么你提交事务的时候，不会把redo log buffer里的数据刷入磁盘文件的，此时可能你都 提交事务了，结果mysql宕机了，然后此时内存里的数据全部丢失。 相当于你提交事务成功了，但是由于MySQL突然宕机，导致内存中的数据和redo日志都丢失了

当这个参数的值为1的时候，你提交事务的时候，就必须把redo log从内存刷入到磁盘文件里去，只要事务提交成功，那么redo log就 必然在磁盘里了

如果`innodb_flush_log_at_trx_commit`参数的值是2

他的意思就是，提交事务的时候，把redo日志写入磁盘文件对应的os cache缓存里去，而不是直接进入磁盘文件，可 能1秒后才会把os cache里的数据写入到磁盘文件里去。

这种模式下，你提交事务之后，redo log可能仅仅停留在os cache内存缓存里，没实际进入磁盘文件，万一此时你要 是机器宕机了，那么os cache里的redo log就会丢失，同样会让你感觉提交事务了，结果数据丢了

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210209234102.png" style="zoom:33%;" />

# binlog

binlog叫做归档日志，他里面记录的是偏向于逻辑性的日志，类似于“对users表中的id=10的一行数据做了更新操 作，更新以后的值是什么”

binlog不是InnoDB存储引擎特有的日志文件，是属于mysql server自己的日志文件。

**提交事务的时候，同时会写入binlog** 

在我们提交事务的时候，会把redo log日志写入磁盘文件中去。然后其实在提交事务的时 候，我们同时还会把这次更新对应的binlog日志写入到磁盘文件中去

**binlog日志的刷盘策略分析**

对于binlog日志，其实也有不同的刷盘策略，有一个`sync_binlog`参数可以控制binlog的刷盘策略，他的默认值是0， 此时你把binlog写入磁盘的时候，其实不是直接进入磁盘文件，而是进入os cache内存缓存。

所以跟之前分析的一样，如果此时机器宕机，那么你在os cache里的binlog日志是会丢失的

如果要是把`sync_binlog`参数设置为1的话，那么此时会强制在提交事务的时候，把binlog直接写入到磁盘文件里去， 那么这样提交事务之后，哪怕机器宕机，磁盘上的binlog是不会丢失的

**基于binlog和redo log完成事务的提交**

当我们把binlog写入磁盘文件之后，接着就会完成最终的事务提交，此时会把本次更新对应的binlog文件名称和这次更新的binlog日志在文件里的位置，都写入到redo log日志文件里去，同时在redo log日志文件里写入一个commit标 记。 在完成这个事情之后，才算最终完成了事务的提交

**最后一步在redo日志中写入commit标记的意义是什么**

说白了，他其实是用来保持redo log日志与binlog日志一致的。

必须是在redo log中写入最终的事务commit标记了，然后此时事务提交成功，而且redo log里有本次更新对应的日 志，binlog里也有本次更新对应的日志 ，redo log和binlog完全是一致的。

**后台IO线程随机将内存更新后的脏数据刷回磁盘**

现在我们假设已经提交事务了，此时一次更新“update users set name='xxx' where id=10”，他已经把内存里的 buffer pool中的缓存数据更新了，同时磁盘里有redo日志和binlog日志，都记录了把我们指定的“id=10”这行数据 修改了“name='xxx'”。

这个时候磁盘上的数据文件里的“id=10”这行数据的name字段还是等于 zhangsan这个旧的值啊

所以MySQL有一个后台的IO线程，会在之后某个时间里，随机的把内存buffer pool中的修改后的脏数据给刷回到磁 盘上的数据文件里去

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210210002203.png" style="zoom:33%;" />

# Buffer Pool

**如何配置你的Buffer Pool的大小**

因为Buffer Pool本质其实就是数据库的一个内存组件，你可以理解为他就是一片内存数据结构，所以这个内存数据结构肯定是 有一定的大小的，不可能是无限大的

这个Buffer Pool默认情况下是128MB，还是有一点偏小了，我们实际生产环境下完全可以对Buffer Pool进行调整

比如我们的数据库如果是16核32G的机器，那么你就可以给Buffer Pool分配个2GB的内存，使用下面的配置就可以了

`[server] innodb_buffer_pool_size = 2147483648`

**数据页：MySQL中抽象出来的数据单位**

我们都知道数据库的核心数据模型就是表+字段+行的概念，也就是说我们都知道数据库里有一个一个的表，一个表有很多字 段，然后一个表里有很多行数据，每行数据都有自己的字段值

MySQL对数据抽象出来了一个数据页的概念，他是把很多行数据放在了一个数据页里，也就是说我们的磁盘文件中就是会有很多的数据页，每一页数据里放了很多行数据

所以实际上假设我们要更新一行数据，此时数据库会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页 直接给加载到Buffer Pool里去 也就是说，Buffer Pool中存放的是一个一个的数据页

**磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来的**

 实际上默认情况下，磁盘中存放的数据页的大小是16KB，也就是说，一页数据包含了16KB的内容。

而Buffer Pool中存放的一个一个的数据页，我们通常叫做缓存页，因为毕竟Buffer Pool是一个缓冲池，里面的数据都是从磁 盘缓存到内存去的。

而Buffer Pool中默认情况下，一个缓存页的大小和磁盘上的一个数据页的大小是一一对应起来的，都是16KB。

**缓存页对应的描述信息是什么**

对于每个缓存页，他实际上都会有一个描述信息，这个描述信息大体可以认为是用来描述这个缓 存页的

比如包含如下的一些东西：这个数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址以及别的一些杂七杂 八的东西

每个缓存页都会对应一个描述信息，这个描述信息本身也是一块数据，在Buffer Pool中，每个缓存页的描述数据放在最前面， 然后各个缓存页放在后面

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210212175324.png" style="zoom:33%;" />

而且这里我们要注意一点，Buffer Pool中的描述数据大概相当于缓存页大小的5%左右，也就是每个描述数据大概是800个字 节左右的大小，然后假设你设置的buffer pool大小是128MB，实际上Buffer Pool真正的最终大小会超出一些，可能有个130 多MB的样子，因为他里面还要存放每个缓存页的描述数据

## Free链表

**我们怎么知道哪些缓存页是空闲的呢**

因为默认情况下磁盘上的数据页和缓存页是一 一对应起来的，都是16KB，一个数据页对应一个缓存页

所以我们必须要知道Buffer Pool中哪些缓存页是空闲的状态

所以数据库会为Buffer Pool设计一个free链表，他是一个双向链表数据结构，这个free链表里，每个节点就是一个空闲的缓存 页的描述数据块的地址，也就是说，只要你一个缓存页是空闲的，那么他的描述数据块就会被放入这个free链表中

刚开始数据库启动的时候，可能所有的缓存页都是空闲的，因为此时可能是一个空的数据库，一条数据都没有，所以此时所有 缓存页的描述数据块，都会被放入这个free链表中

这个free链表里面就是各个缓存页的描述数据块，只要缓存页是空闲的，那么他们对 应的描述数据块就会加入到这个free链表中，每个节点都会双向链接自己的前后节点，组成一个双向链表。

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210212182618.png" style="zoom:33%;" />

## Flush链表

**脏数据页到底为什么会脏**

更新Buffer Pool的缓存页中的数据，此时一旦你更新了缓存页中的数据，那么缓存页里的数据和磁盘上的数据 页里的数据，是不是就不一致了

这个时候，我们就说缓存页是脏数据，脏页

**哪些缓存页是脏页**

数据库在这里引入了另外一个跟free链表类似的flush链表，这个flush链表本质也是通过缓存页的描述数据块中的两个指 针，让被修改过的缓存页的描述数据块，组成一个双向链表

凡是被修改过的缓存页，都会把他的描述数据块加入到flush链表中去，flush的意思就是这些都是脏页，后续都是要flush刷新 到磁盘上去的

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210212193846.png" style="zoom:33%;" />

## LRU链表

**引入LRU链表来判断哪些缓存页是不常用的**

接着我们就要解决下一个问题了，就是你怎么知道哪些缓存页经常被访问，哪些缓存页很少被访问

此时就要引入一个新的LRU链表了，这个所谓的LRU就是Least Recently Used，最近最少使用的意思

通过这个LRU链表，我们可以知道哪些缓存页是最近最少被使用的，那么当你缓存页需要腾出来一个刷入磁盘的时 候，不就可以选择那个LRU链表中最近最少被使用的缓存页了么

**这个LRU链表大致是怎么个工作原理呢**

假设我们从磁盘加载一个数据页到缓存页的时候，就把这个缓存页的描述数据块放到LRU链 表头部去，那么只要有数据的缓存页，他都会在LRU里了，而且最近被加载数据的缓存页，都会放到LRU链表的头部

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210212195630.png" style="zoom:33%;" />

然后假设某个缓存页的描述数据块本来在LRU链表的尾部，后续你只要查询或者修改了这个缓存页的数据，也要把这 个缓存页挪动到LRU链表的头部去，也就是说最近被访问过的缓存页，一定在LRU链表的头部

那么这样的话，当你的缓存页没有一个空闲的时候，你是不是要找出来那个最近最少被访问的缓存页去刷入磁盘

此 时你就直接在LRU链表的尾部找到一个缓存页，他一定是最近最少被访问的那个缓存页

然后你就把LRU链表尾部的那个缓存页刷入磁盘中，然后把你需要的磁盘数据页加载到腾出来的空闲缓存页中就可以 了

## 生产经验

**Buffer Pool在访问的时候需要加锁吗**

然后这多个线程是不是应该会同时去访问Buffer Pool

就是同时去操作里面的缓存页，同时操作一个free链表、 flush链表、lru链表

现在多个线程来并发的访问这个Buffer Pool了，此时他们都是在访问内存里的一些共享的数据结 构，比如说缓存页、各种链表之类的，那么此时是不是必然要进行加锁

对，多线程并发访问一个Buffer Pool，必然是要加锁的，然后让一个线程先完成一系列的操作，比如说加载数据页到 缓存页，更新free链表，更新lru链表，然后释放锁，接着下一个线程再执行一系列的操作

**多线程并发访问加锁，数据库的性能还能好吗**

既然我们已经解决了第一个问题，就是多线程并发访问一个Buffer Pool的时候必然会加锁，然后很多线程可能要串行 着排队，一个一个的依次执行自己要执行的操作，此时数据库的性能还能好吗

应该这么说，即使就一个Buffer Pool，即使多个线程会加锁串行着排队执行，其实性能也差不到哪儿去

因为大部分情况下，每个线程都是查询或者更新缓存页里的数据，这个操作是发生在内存里的，基本都是微秒级的， 很快很快，包括更新free、flush、lru这些链表，他因为都是基于链表进行一些指针操作，性能也是极高的

所以即使每个线程排队加锁，然后执行一系列操作，数据库的性能倒也是还可以的

**MySQL的生产优化经验：多个Buffer Pool优化并发能力**

一般来说，MySQL默认的规则是，如果你给Buffer Pool分配的内存小于1GB，那么最多就只会给你一个Buffer Pool

但是如果你的机器内存很大，那么你必然会给Buffer Pool分配较大的内存，比如给他个8G内存，那么此时你是同时可 以设置多个Buffer Pool的，比如说下面的MySQL服务器端的配置

` [server] innodb_buffer_pool_size = 8589934592 innodb_buffer_pool_instances = 4`

我们给buffer pool设置了8GB的总内存，然后设置了他应该有4个Buffer Pool，此时就是说，每个buffer pool的大小 就是2GB

这个时候，MySQL在运行的时候就会有4个Buffer Pool了！每个Buffer Pool负责管理一部分的缓存页和描述数据块， 有自己独立的free、flush、lru等链表

这个时候，假设多个线程并发过来访问，那么不就可以把压力分散开来了吗？有的线程访问这个buffer pool，有的线 程访问那个buffer pool

所以这样的话，一旦你有了多个buffer pool之后，你的多线程并发访问的性能就会得到成倍的提升，因为多个线程可 以在不同的buffer pool中加锁和执行自己的操作，大家可以并发来执行了

所以这个在实际生产环境中，设置多个buffer pool来优化高并发访问性能，是mysql一个很重要的优化技巧

# 事务

**脏写** 

事务B去修改了事务A修改过的值，但是此时事务A还没提交，所以事务A随时会回滚， 导致事务B修改的值也没了

**脏读**

事务B去查询了事务A修改过的数据，但是此时事务A还没提交，所以事务A随时会回滚导致事务B再次查询就读不到刚才事务A修改的数据了

无论是脏写还是脏读，都是因为一个事务去更新或者查询了另外一个还没提交的事务更新过的数据

因为另外一个事务还没提交，所以他随时可能会反悔会回滚，那么必然导致你更新的数据就没了，或者你之前查询到的数据就没了

# MVCC

**undo log版本链**

我们每条数据其实都有两个隐藏字段，一个是`trx_id`，一个是`roll_pointer`，这个`trx_id`就 是最近一次更新这条数据的事务id，`roll_pointer`就是指向你了你更新这个事务之前生成的undo log

这个多个事务串行更新一行数据的时候，undo log串联起来的多版本链条

## ReadView

你执行一个事务的时候，就给你生成一个ReadView，里面比较关键 的东西有4个

一个是`m_ids`，这个就是说此时有哪些事务在MySQL里执行还没提交的； 

一个是`min_trx_id`，就是`m_ids`里最小的值； 

一个是`max_trx_id`，这是说mysql下一个要生成的事务id，就是最大事务id； 

一个是`creator_trx_id`，就是你这个事务的id

