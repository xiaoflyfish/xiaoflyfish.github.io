---
title: 分布式锁
categories: 
- ZooKeeper
---

分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题

实现分布式锁目前有三种流行方案，即基于数据库、`Redis、ZooKeeper` 的方案

**方案一：**

使用节点中的存储数据区域，`ZK`中节点存储数据的大小不能超过1M，但是只是存放一个标识是足够的，线程获得锁时，先检查该标识是否是无锁标识，若是可修改为占用标识，使用完再恢复为无锁标识

**方案二：**

使用子节点，每当有线程来请求锁的时候，便在锁的节点下创建一个子节点，子节点类型必须维护一个顺序，对子节点的自增序号进行排序，默认总是最小的子节点对应的线程获得锁，释放锁时删除对应子节点便可

**死锁风险:**

两种方案其实都是可行的，但是使用锁的时候一定要去规避死锁

方案一看上去是没问题的，用的时候设置标识，用完清除标识，但是要是持有锁的线程发生了意外，释放锁的代码无法执行，锁就无法释放，其他线程就会一直等待锁，相关同步代码便无法执行

方案二也存在这个问题，但方案二可以利用ZK的临时顺序节点来解决这个问题，只要线程发生了异常导致程序中断，就会丢失与`ZK`的连接，`ZK`检测到该链接断开，就会自动删除该链接创建的临时节点，这样就可以达到即使占用锁的线程程序发生意外，也能保证锁正常释放的目的

**避免羊群效应**

把锁请求者按照后缀数字进行排队，后缀数字小的锁请求者先获取锁。如果所有的锁请求者都 `watch` 锁持有者，当代表锁请求者的 `znode` 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请 求者能拿到锁。这就是羊群效应。

为了避免羊群效应，每个锁请求者 `watch` 它前面的锁请求者。每次锁被释放，只会有一个锁请求者 会被通知到。这样做还让锁的分配具有公平性，锁定的分配遵循先到先得的原则

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201229090907.png" style="zoom:33%;" />

**用 ZooKeeper 实现分布式锁的算法流程，根节点为 /lock：**

* 客户端连接 ZooKeeper，并在` /lock` 下创建临时有序子节点，第一个客户端对应的子节点为 `/lock/lock01/00000001`，第二个为 `/lock/lock01/00000002`；

* 其他客户端获取 `/lock01` 下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；

* 如果是则认为获得锁，执行业务代码，否则通过 `watch` 事件监听`/lock01` 的子节点变更消息，获得变更通知后重复此步骤直至获得锁；

* 完成业务流程后，删除对应的子节点，释放分布式锁

在实际开发中，可以应用 `Apache Curator` 来快速实现分布式锁，`Curator` 是 Netflix 公司开源的一个 ZooKeeper 客户端，对 ZooKeeper 原生 API 做了抽象和封装