---
title: 粘包和拆包
categories: 
- Netty
---

**TCP粘包和拆包基本介绍**

TCP 是面向连接的， 面向流的， 提供高可靠性服务。 收发两端（客户端和服务器端） 都要有一一成对的 socket，因此， 发送端为了将多个发给接收端的包， 更有效的发给对方， 使用了优化方法（`Nagle算法`） ， 将多次间隔较小且数据量小的数据， 合并成一个大的数据块， 然后进行封包。 这样做虽然提高了效率， 但是接收端就难于分辨出完整的数据包了， 因为面向流的通信是无消息保护边界的。

由于 TCP 无消息保护边界, 需要在接收端处理消息边界问题， 也就是我们所说的粘包、 拆包问题

在编写 `Netty` 程序时， 如果没有做处理， 就会发生粘包和拆包的问题

# 解决方案

1.使用自定义协议 + 编解码器 来解决

2.关键就是要解决 服务器端每次读取数据长度的问题, 这个问题解决， 就不会出现服务器多读或少读数据的问题， 从而避免的 `TCP` 粘包、 拆包

# 拆包器

**Netty中已经为我们提供了自带的拆包器：**

1.FixedLengthFrameDecoder：固定长度的拆包器，适用于每个数据包的长度都是固定的情况。使用时只需要将这个拆包器加入到`pipeline`中，Netty将根据固定长度的数据包传入到下一个`Handler`。

2.LineBasedFrameDecoder：行拆包器，适用于每个数据包之间按照行来分割的情况。

3.DelimiterBasedFrameDecoder：分隔符拆包器，行拆包器按照换行符分割，分隔符拆包器可以自定义分隔符来进行拆包。

4.LengthFieldBasedFrameDecoder：基于长度域拆包器，最通用的一种拆包器，只要自定义协议中包含长度域字段，均可以使用该拆包器来实现。

一般我们使用第四个最通用的拆包器，只要我们的协议里面有数据长度这个字段即可。

```java
// 最大字节数，长度域偏移量，长度域长度
new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 7, 4);
```

由于是拆包器，肯定是在责任链的第一个，所以只需要将这个拆包器加入到`pipeline`中第一个位置即可完成拆包，解决TCP拆包问题

Netty中的拆包器都是继承自`ByteToMessageDecoder`这个基类，这个类中内部有一个累加器，读取到数据之后会触发累加器，用于记录当前已经读取多少字节，然后对累加的数据按照给定的数据长度进行拆包