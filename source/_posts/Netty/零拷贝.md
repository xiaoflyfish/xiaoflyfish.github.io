---
title: 零拷贝
categories: 
- Netty
---

**CompositeByteBuf**

`CompositeByteBuf `是 Netty 中实现零拷贝机制非常重要的一个数据结构

它是由多个 ByteBuf 组合而成，但是在 `CompositeByteBuf` 内部保存着每个 ByteBuf 的引用关系，从逻辑上构成一个整体。

比较常见的像 HTTP 协议数据可以分为头部信息 header和消息体数据 body，分别存在两个不同的 `ByteBuf `中，通常我们需要将两个 `ByteBuf `合并成一个完整的协议数据进行发送，可以使用如下方式完成：

```java
CompositeByteBuf httpBuf = Unpooled.compositeBuffer();
httpBuf.addComponents(true, header, body);
```

CompositeByteBuf 通过调用 `addComponents()` 方法来添加多个 ByteBuf，但是底层的 byte 数组是复用的，不会发生内存拷贝。但对于用户来说，它可以当作一个整体进行操作

CompositeByteBuf 内部维护了一个 `Components` 数组。在每个 Component 中存放着不同的 ByteBuf，各个 ByteBuf 独立维护自己的读写索引，而 CompositeByteBuf 自身也会单独维护一个读写索引

```java
private static final class Component {
    final ByteBuf srcBuf; // 原始的 ByteBuf
    final ByteBuf buf; // srcBuf 去除包装之后的 ByteBuf
    int srcAdjustment; // CompositeByteBuf 的起始索引相对于 srcBuf 读索引的偏移
    int adjustment; // CompositeByteBuf 的起始索引相对于 buf 的读索引的偏移
    int offset; // Component 相对于 CompositeByteBuf 的起始索引位置
    int endOffset; // Component 相对于 CompositeByteBuf 的结束索引位置
}
```

Component 中的 `offset` 和 `endOffset` 可以表示当前 ByteBuf 可以读取的范围，通过 offset 和 endOffset 可以将每一个 Component 所对应的 ByteBuf 连接起来，形成一个逻辑整体

Component 中` srcAdjustment` 和 `adjustment` 表示 CompositeByteBuf 起始索引相对于 ByteBuf 读索引的偏移。

初始 `adjustment = readIndex - offset`，这样通过 CompositeByteBuf 的起始索引就可以直接定位到 Component 中 ByteBuf 的读索引位置

**Unpooled.wrappedBuffer操作**

`Unpooled.wrappedBuffer` 同时也是创建 CompositeByteBuf 对象的另一种推荐做法

`Unpooled.wrappedBuffer` 方法可以将不同的数据源的一个或者多个数据包装成一个大的 ByteBuf 对象，其中数据源的类型包括 `byte[]、ByteBuf、ByteBuffer`。包装的过程中不会发生数据拷贝操作，包装后生成的 ByteBuf 对象和原始 ByteBuf 对象是共享底层的 byte 数组

**ByteBuf.slice操作**

`ByteBuf.slice` 和 `Unpooled.wrappedBuffer` 的逻辑正好相反，`ByteBuf.slice` 是将一个 ByteBuf 对象切分成多个共享同一个底层存储的 ByteBuf 对象。

ByteBuf 提供了两个 slice 切分方法:

```java
public ByteBuf slice();
public ByteBuf slice(int index, int length);
```

通过 slice 切分后都会返回一个新的 ByteBuf 对象，而且新的对象有自己独立的 `readerIndex、writerIndex` 索引

由于新的 ByteBuf 对象与原始的 ByteBuf 对象数据是共享的，所以通过新的 ByteBuf 对象进行数据操作也会对原始 ByteBuf 对象生效

**文件传输FileRegion**

在 Netty 源码的 example 包中，提供了 FileRegion 的使用示例

Netty 使用 FileRegion 实现文件传输的零拷贝。FileRegion 的默认实现类是 DefaultFileRegion，通过 DefaultFileRegion 将文件内容写入到 NioSocketChannel

```java
public class DefaultFileRegion extends AbstractReferenceCounted implements FileRegion {
    private final File f; // 传输的文件
    private final long position; // 文件的起始位置
    private final long count; // 传输的字节数
    private long transferred; // 已经写入的字节数
    private FileChannel file; // 文件对应的 FileChannel
    @Override
    public long transferTo(WritableByteChannel target, long position) throws IOException {
        long count = this.count - position;
        if (count < 0 || position < 0) {
            throw new IllegalArgumentException(
                    "position out of range: " + position +
                    " (expected: 0 - " + (this.count - 1) + ')');
        }
        if (count == 0) {
            return 0L;
        }
        if (refCnt() == 0) {
            throw new IllegalReferenceCountException(0);
        }
        open();
        long written = file.transferTo(this.position + position, count, target);
        if (written > 0) {
            transferred += written;
        } else if (written == 0) {
            validate(this, position);
        }
        return written;
    }
}
```

从源码可以看出，FileRegion 其实就是对 FileChannel 的包装，并没有什么特殊操作，底层使用的是 JDK NIO 中的 `FileChannel#transferTo()` 方法实现文件传输，所以 FileRegion 是操作系统级别的零拷贝，对于传输大文件会很有帮助



