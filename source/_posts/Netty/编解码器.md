---
title: 编解码器
categories: 
- Netty
---

编写网络应用程序时， 因为数据在网络中传输的都是二进制字节码数据， 在发送数据时就需要编码， 接收数据时就需要解码

**codec(编解码器) 的组成部分有两个：**

- decoder(解码器)和 `encoder(编码器)`。
- encoder 负责把业务数据转换成字节码数据， `decoder` 负责把字节码数据转换成业务数据

Netty 本身自带的 `ObjectDecoder` 和 `ObjectEncoder` 可以用来实现 POJO 对象或各种业务对象的编码和解码， 底层使用的仍是 Java 序列化技术

而 Java 序列化技术本身效率就不高，无法跨语言，序列化后的体积太大， 是二进制编码的 5 倍多。序列化性能太低

# Protobuf

Protobuf 是 Google 发布的开源项目， 全称 Google Protocol Buffers， 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化

它很适合做数据存储或RPC数据交换格式

参考文档 : https://developers.google.com/protocol-buffers/docs/proto

Protobuf 是以 message 的方式来管理数据的，支持跨平台、 跨语言，高性能， 高可靠性

使用 protobuf 编译器能自动生成代码， Protobuf 是将类的定义使用`.proto` 文件进行描述。

通过 `protoc.exe` 编译器根据`.proto` 自动生成Java文件

# 编码解码器

当 Netty 发送或者接受一个消息的时候， 就将会发生一次数据转换

入站消息会被解码，从字节转换为另一种格式（比如 java对象），如果是出站消息，它会被编码成字节

Netty 提供一系列实用的编解码器， 他们都实现了 `ChannelInboundHadnler` 或者 `ChannelOutboundHandler` 接口

在这些类中，`channelRead` 方法已经被重写了。

以入站为例， 对于每个从入站 Channel 读取的消息， 这个方法会被调用。

随后， 它将调用由解码器所提供的 `decode()`方法进行解码， 并将已经解码的字节转发给 ChannelPipeline中的下一个 `ChannelInboundHandler`