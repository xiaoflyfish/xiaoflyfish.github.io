---
title: 经典垃圾收集器
categories: 
- 读书笔记
- 深入理解Java虚拟机
---

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214210341.png" style="zoom:33%;" />

图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用

图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器

# Serial收集器

Serial收集器是最基础、历史最悠久的收集器，曾经（在`JDK 1.3.1`之前）是`HotSpot`虚拟机新生代 收集器的唯一选择。

这个收集器是一个单线程工作的收集器，但它的单线 程的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强 调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

**Serial/Serial Old收集器的运行过程**

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214212405.png" style="zoom:33%;" />

HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；

对于单核处理器或处理器核心数较少的环境来说，`Serial`收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

# ParNew收集器

ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之 外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、`Stop The World`、对象分配规 则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。

**ParNew收集器的工作过程如图所示**

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214212745.png" style="zoom:33%;" />

ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处，但它 却是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集 器，其中有一个与功能、性能无关但其实很重要的原因是：除了`Serial`收集器外，目前只有它能与`CMS `收集器配合工作。

在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者 Serial收集器中的一个。

ParNew收集器是激活CMS后（使用`-XX：+UseConcMarkSweepGC`选项）的默认新生代收集器，也可以使用`-XX：+/-UseParNewGC`选项来强制指定或者禁用它。

自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。

官方希望它能完全被G1所取代，甚至还取消了ParNew加` Serial Old`以及Serial加CMS这两组收集器组合的支持并直接取消了`XX：+UseParNewGC`参数，这意味着ParNew和CMS从此只能互相搭配使用，再也没有其他收集器能够和它们配合了

ParNew对于垃圾收集时 系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多（譬如32个，现在CPU都是多核加超线程设计，服务器达到或超过32个逻辑核心的情况非常 普遍）的环境中，可以使用`-XX：ParallelGCThreads`参数来限制垃圾收集的线程数。

**并行和并发都是并发编程中的专业名词，，它们可以理解为：**

* 并行：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。

* 并发：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾 收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于 垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

# Parallel Scavenge收集器

Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器

**Parallel Scavenge的诸多特性从表面上看和ParNew非常相似，那它有什么特别之处呢**

Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。

所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值

如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分 钟，那吞吐量就是99%。

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的`-XX：MaxGCPauseMillis`参数以及直接设置吞吐量大小的`-XX：GCTimeRatio`参数。

`-XX：MaxGCPauseMillis`参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。

`-XX：GCTimeRatio`参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的 比率，相当于吞吐量的倒数。

譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5% （即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间。

**自适应的调节策略**

除上述两个 参数之外，Parallel Scavenge收集器还有一个参数`-XX：+UseAdaptiveSizePolicy`值得我们关注。

这是一 个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区 的比例（`-XX：SurvivorRatio`）、晋升老年代对象大小（`-XX：PretenureSizeThreshold`）等细节参数 了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

# Serial Old收集器

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。

这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：

一种是在JDK 5以及之前的版本中与`Parallel Scavenge`收集器搭配使用 ，另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。

**Serial Old收集器的工作过程如图所示**

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214214446.png" style="zoom:33%;" />

# Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了`Serial Old`收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑`Parallel Scavenge`加Parallel Old收集器这个组 合。

**Parallel Old收集器的工作过程如图所示**

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214214715.png" style="zoom:33%;" />

# CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

从名字（包含Mark Sweep）上就可以看出CMS收集器是基于标记-清除算法实现的

**过程分为四个步骤，包括：**

1. 初始标记（CMS initial mark） 

2. 并发标记（CMS concurrent mark） 

3. 重新标记（CMS remark） 

4. 并发清除（CMS concurrent sweep） 

其中初始标记、重新标记这两个步骤仍然需要Stop The World。

初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；

并发标记阶段就是从`GC Roots`的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；

重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录

这个阶段的停顿时间通常会比初始标记阶段稍长一 些，但也远比并发标记阶段的时间短；

并发清除阶段，清理删除掉标记阶段判断的已经死亡的 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

**通过图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的阶段**

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214215200.png" style="zoom:33%;" />

CMS是一款优秀的收集器，它最主要的优点在名字上已经体现出来：并发收集、低停顿

**CMS收集器至少有以下三个明显的缺点：**

> 1.CMS收集器对处理器资源非常敏感。

在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。

CMS默认启动的回收线程数是（处理器核心数量 +3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时， CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。

> 2.CMS收集器无法处理浮动垃圾

有可能出现Con-current Mode Failure失败进而导致另一次完全Stop The World的`Full GC`的产生。

在CMS的并发标记和并发清理阶 段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集 时再清理掉。

这一部分垃圾就称为浮动垃圾。同样也是由于在垃圾收集阶段用户线程还需要持续运 行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。

在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果 在实际应用中老年代增长并不是太快，可以适当调高参数`-XX：CMSInitiatingOccu-pancyFraction`的值 来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。

到了JDK 6时，CMS收集器的启动 阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满 足程序分配新对象的需要，就会出现一次并发失败（`Concurrent Mode Failure`），这时候虚拟机将不 得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。所以参数`-XX：CMSInitiatingOccupancyFraction`设置得太高将会很容易导致 大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。

> 3.收集结束时会有大量空间碎片产生

空间 碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。

为了解决这个问题， CMS收集器提供了一个`-XX：+UseCMS-CompactAtFullCollection`开关参数（默认是开启的，此参数从 JDK 9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长

因此虚拟机设计者们还提供了另外一个参数`-XX：CMSFullGCsBeforeCompaction`（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表 示每次进入Full GC时都进行碎片整理）。

# Garbage First收集器

G1是一款主要面向服务端应用的垃圾收集器。HotSpot开发团队最初赋予它的期望是（在比较长期的）未来可以替换掉JDK 5中发布的CMS收集器。

现在这个期望目标已经实现过半了，JDK 9发布之 日，G1宣告取代`Parallel Scavenge`加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用的收集器 。

如果对JDK 9及以上版本的HotSpot虚拟机使用 参数`-XX：+UseConcMarkSweepGC`来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃

G1不再坚持固定大小以及固定数量的 分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个`Region`都可以 根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

Region中还有一类特殊的`Humongous`区域，专门用来存储大对象。G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数`-XX：G1HeapRegionSize`设 定，取值范围为`1MB～32MB`，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代 的一部分来进行看待。

虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区 域（不需要连续）的动态集合。

G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。

更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的价值大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数`-XX：MaxGCPauseMillis`指定，默 认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是Garbage First名字的由来。 这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获 取尽可能高的收集效率。

**如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的 运作过程大致可划分为以下四个步骤：**

* 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。

* 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以 后，还要重新处理SATB记录下的在并发时有引用变动的对象。

* 最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。

* 筛选回收：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的。

**从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的**

通过图可以比较清楚地看到G1收集器的运 作步骤中并发和需要停顿的阶段。

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201214221547.png" style="zoom:33%;" />

G1从整体来看是基于标记-整理算法实现的收集器，但从局部（两个Region 之间）上看又是基于标记-复制算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大 对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。

按照实践经 验，目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间
