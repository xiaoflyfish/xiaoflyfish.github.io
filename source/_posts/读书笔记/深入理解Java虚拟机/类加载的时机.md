---
title: 类加载的时机
categories: 
- 读书笔记
- 深入理解Java虚拟机
---

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载 （`Loading`）、验证（Verification）、准备（Preparation）、解析（`Resolution`）、初始化 （Initialization）、使用（Using）和卸载（`Unloading`）七个阶段，其中验证、准备、解析三个部分统称 为连接（Linking）

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201215215446.png" style="zoom:33%;" />

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。

这些阶段通常都 是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。

**初始化阶段，Java虚拟机规范则是严格规定了有且只有六种情况必须立即对类进行初始化：**

1.遇到new、getstatic、putstatic或`invokestatic`这四条字节码指令时，如果类型没有进行过初始 化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：

* 使用new关键字实例化对象的时候。

* 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。

* 调用一个类型的静态方法的时候。

2.使用`java.lang.reflect`包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。 

3.当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4.当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先 初始化这个主类。

5.当使用JDK 7新加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果为`REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInvokeSpecial`四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

6.当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

对于这六种会触发类型进行初始化的场景，这六种场景中的行为称为对一个类型进行主动引用。

除此之外，所有引用类型的方 式都不会触发初始化，称为被动引用。

**下面举三个例子来说明何为被动引用**

1.通过子类引用父类中的静态字段，不会初始化子类

```java
package org.fenixsoft.classloading;

/**
 * 被动使用类字段演示一：
 * 通过子类引用父类的静态字段，不会导致子类初始化
 *
 */
public class SuperClass {
    public static int value = 123;

    static {
        System.out.println("SuperClass Init");
    }
}

public class SubClass extends SuperClass {

    static {
        System.out.println("SubClass Init");
    }
}

public class NotInitialization {

    public static void main(String[] args) {
        //通过子类引用父类的静态字段，不会导致子类初始化
        System.out.println(SubClass.value);
    }

}
```

上述代码运行之后，只会输出“SuperClass init！”，而不会输出“SubClass init！”。

对于静态字段， 只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

至于是否要触发子类的加载和验证阶段，在Java虚拟机规范中并未明确规定，所以这点取决于虚拟机的具体实现。

对于HotSpot虚拟机来说，可通过`-XX： +TraceClassLoading`参数观察到此操作是会导致子类加载的。

**2.通过定义数组来引用类，不会触发此类的初始化**

```java
public class NotInitialization {

    public static void main(String[] args) {

        //通过数组定义来引用类，不会触发此类的初始化
        SuperClass[] sca = new SuperClass[10];

    }

}
```

运行之后发现没有输出“SuperClass init！”，说明并没有触发类`org.fenixsoft.classloading.SuperClass`的初始化阶段。

但是这段代码里面触发了 另一个名为`“[Lorg.fenixsoft.classloading.SuperClass”`的类的初始化阶段，对于用户代码来说，这并不是 一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于`java.lang.Object`的子类，创建动作由字节码指令newarray触发。

这个类代表了一个元素类型为`org.fenixsoft.classloading.SuperClass`的一维数组，数组中应有的属性 和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里。

Java语言中对数组的访问要比C/C++相对安全，很大程度上就是因为这个类包装了数组元素的访问

> 准确地说，越界检查不是封装在数组元素访问的类中，而是封装在数组访问的xaload、xastore字节 码指令中。

在Java语言里，当检查到发生数组越界时会抛出` java.lang.ArrayIndexOutOfBoundsException`异常，避免了直接造成非法内存访问。

**3.引用常量池中的常量，不针触发定义常量类的初始化**

```java
public class ConstClass {

    public static final String HELLOWORLD = "hello world";

    static {
        System.out.println("ConstClass Inited");
    }

}
package com.xtayfjpk.jvm.chapter7;

public class NotInitialization {

    public static void main(String[] args) {

        //常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会导致该类初始化
        System.out.println(ConstClass.HELLOWORLD);
    }

}
```

上述代码运行之后，也没有输出ConstClass init！，这是因为虽然在Java源码中确实引用了ConstClass类的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”直接存储在NotInitialization类的常量池中，以后NotInitialization对常量 `ConstClass.HELLOWORLD`的引用，实际都被转化为NotInitialization类对自身常量池的引用了。

也就是 说，实际上`NotInitialization`的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成 Class文件后就已不存在任何联系了。

接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明：接口也有初始化过程， 这点与类是一致的，上面的代码都是用静态语句块`“static{}”`来输出初始化信息的，而接口中不能使用`“static{}”`语句块，但编译器仍然会为接口生成`“<clinit>()”`类构造器，用于初始化接口中所定义的 成员变量。

接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种： 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父 接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始 化。