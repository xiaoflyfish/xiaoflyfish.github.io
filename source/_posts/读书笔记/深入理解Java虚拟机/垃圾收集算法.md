---
title: 垃圾收集算法
categories: 
- 读书笔记
- 深入理解Java虚拟机
---

**分代收集理论**

当前商业虚拟机的垃圾收集器，大多数都遵循了分代收集的理论进 行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

1. 弱分代假说：绝大多数对象都是朝生夕灭的。 

2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

部分收集（`Partial GC`）：

指目标不是完整收集整个Java堆的垃圾收集，其中又分为： 

* 新生代收集（`Minor GC/Young GC`）：指目标只是新生代的垃圾收集。 

* 老年代收集（`Major GC/Old GC`）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。

* 混合收集（`Mixed GC`）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。

整堆收集（`Full GC`）：收集整个Java堆和方法区的垃圾收集。

# 标记-清除算法

最早出现也是最基础的垃圾收集算法是标记-清除算法

如它的名字一样，算法分为标记和清除两个阶段：首先标记出所有需要回 收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回 收所有未被标记的对象。

**它的主要缺点有两个：**

第一个是执行效率不稳定，如果Java堆中包含大量对 象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过 程的执行效率都随对象数量增长而降低；

第二个是内存空间的碎片化问题，标记、清除之后会产生大 量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找 到足够的连续内存而不得不提前触发另一次垃圾收集动作。

# 复制算法

为了解决标记-清除算法面对大量可回收对象时执行效率低 的问题

它将可用 内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存 活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复 制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有 空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷 也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。

**现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代**

HotSpot虚拟机的`Serial、ParNew`等新生代收集器均采用了这种策略来设计新生代的内存布局

具体做法是把新生代分为一块较大的Eden空间和两块较小的` Survivor`空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍 然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空 间。

HotSpot虚拟机默认`Eden`和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新 生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被浪费的。

当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实 际上大多就是老年代）进行分配担保（Handle Promotion）。

# 标记-整理算法

复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

它的标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可 回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内 存。

标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。

**是否移动回收后的存活对象是一项优缺点并存的风险决策：**

如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种**对象移动操作必须全程暂停用户应用程序才能进行**，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为`Stop The World`。

但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的 空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。

基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会 更复杂。

从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。

> 通常标记-清除算法也是需要停顿用户线程来标记、清理可回收对象的，只是停顿时间相对而言要来的短而已

HotSpot虚拟机里面关注吞吐量的`Parallel Scavenge`收集器是基于标记-整理算法的，而关注延迟的`CMS`收集器则是基于标记-清除算法的，这也从侧面印证这点。

另外，还有一种解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚 拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经 大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。

前面提到的基于标记-清除算法的`CMS`收集器面临空间碎片过多时采用的就是这种处理办法。