---
title: 类加载器
categories: 
- 读书笔记
- 深入理解Java虚拟机
---

Java虚拟机设计团队有意把类加载阶段中的通过一个类的全限定名来获取描述该类的二进制字节流这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为类加载器。

# 类与类加载器

比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

这里所指的相等，包括代表类的Class对象的`equals()`方法、`isAssignableFrom()`方法、`isInstance() `方法的返回结果，也包括了使用`instanceof`关键字做对象所属关系判定等各种情况。

**代码演示了不同的类加载器对instanceof关键字运算的结果的影响。**

```java
public class ClassLoaderTest {
    public static void main(String args[])throws Exception{
		ClassLoader myLoader=new ClassLoader(){
			@Override
			public Class<?> loadClass(String name)throws ClassNotFoundException{
				try{
					String fileName=name.substring(name.lastIndexOf(".")+1)+".class";
					InputStream in=getClass().getResourceAsStream(fileName);
					if (in==null)
					{
						return super.loadClass(name);
					}
					byte[] b=new byte[in.available];
					in.read(b);
					return defineClass(name,b,0,b,length);
				} catch (IOException e) {
					throw new ClassNotFoundException(name);
				}
			}
		};
 
		Object obj=myLoader.loadClass("org.fenixsoft.classloading.ClassLoaderTest").newInstance();
		System.out.println(obj.getClass());
		System.out.println(obj instanceof org.fenixsoft.classloading.ClassLoaderTest);
	}
 
}
```

```
运行结果：
class org.fenixsoft.classloading.ClassLoaderTest
false
```

代码清单中构造了一个简单的类加载器，尽管它极为简陋，但是对于这个演示来说已经足够。 

它可以加载与自己在同一路径下的Class文件，我们使用这个类加载器去加载了一个名 为`org.fenixsoft.classloading.ClassLoaderTest`的类，并实例化了这个类的对象。

两行输出结果中，从第一行可以看到这个对象确实是类`org.fenixsoft.classloading.ClassLoaderTest`实 例化出来的，但在第二行的输出中却发现这个对象与类`org.fenixsoft.classloading.ClassLoaderTest`做所属 类型检查的时候返回了false。

这是因为Java虚拟机中同时存在了两个`ClassLoaderTest`类，一个是由虚拟 机的应用程序类加载器所加载的，另外一个是由我们自定义的类加载器加载的，虽然它们都来自同一 个Class文件，但在Java虚拟机中仍然是两个互相独立的类，做对象所属类型检查时的结果自然为 false。

# 双亲委派模型

站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（`Bootstrap ClassLoader`），这个类加载器使用C++语言实现 ，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类` java.lang.ClassLoader`。

站在Java开发人员的角度来看，类加载器就应当划分得更细致一些。自JDK 1.2以来，Java一直保 持着三层类加载器、双亲委派的类加载架构，尽管这套架构在Java模块化系统出现后有了一些调整变 动，但依然未改变其主体结构

**启动类加载器（Bootstrap Class Loader）：**

这个类加载器负责加载存放在` <JAVA_HOME>\lib`目录，或者被`-Xbootclasspath`参数所指定的路径中存放的，而且是Java虚拟机能够 识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时， 如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可

**扩展类加载器（Extension Class Loader）：**

这个类加载器是在类`sun.misc.Launcher$ExtClassLoader` 中以Java代码的形式实现的。它负责加载`<JAVA_HOME>\lib\ext`目录中，或者被`java.ext.dirs`系统变量所 指定的路径中所有的类库。

扩展类加载器是由Java代码实现 的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。 

**应用程序类加载器（Application Class Loader）：**

这个类加载器由` sun.misc.Launcher$AppClassLoader`来实现。由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以有些场合中也称它为系统类加载器。它负责加载用户类路径 （ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有 自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

<img src="https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201216232010.png" style="zoom:33%;" />

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载 器。不过这里类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用 组合关系来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加 载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的 加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请 求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类 加载器一起具备了一种带有优先级的层次关系。例如类`java.lang.Object`，它存放在`rt.jar`之中，无论哪一 个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此`Object`类 在程序的各种类加载器环境中都能够保证是同一个类。

如果没有使用双亲委派模型，都由各个 类加载器自行去加载的话，如果用户自己也编写了一个名为`java.lang.Object`的类，并放在程序的 `ClassPath`中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应 用程序将会变得一片混乱。

双亲委派模型对于保证Java程序的稳定运作极为重要，但它的实现却异常简单，用以实现双亲委 派的代码只有短短十余行，全部集中在`java.lang.ClassLoader`的`loadClass()`方法之中

```java
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
{
    // 首先，检查请求的类是否已经被加载过了
    Class c = findLoadedClass(name);
    if (c == null) {
        try {
            if (parent != null) {
            	c = parent.loadClass(name, false);
            } else {
            	c = findBootstrapClassOrNull(name);
            }
        } catch (ClassNotFoundException e) {
            // 如果父类加载器抛出ClassNotFoundException
            // 说明父类加载器无法完成加载请求
        }
        if (c == null) {
            // 在父类加载器无法加载时
            // 再调用本身的findClass方法来进行类加载
            c = findClass(name);
        }
    }
    if (resolve) {
    	resolveClass(c);
    }
    return c;
}
```

先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的` loadClass()`方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败， 抛出`ClassNotFoundException`异常的话，才调用自己的`findClass()`方法尝试进行加载。

# 破坏双亲委派模型

一个典型的例子便是JNDI服务，JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程 序的ClassPath下的JNDI服务提供者接口（`Service Provider Interface，SPI`）的代码，现在问题来了，启 动类加载器是绝不可能认识、加载这些代码的，那该怎么办？

为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过`java.lang.Thread`类的setContext-ClassLoader()方 法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内 都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

JNDI服务使用这个线程上下文类 加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行 为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性 原则，但也是无可奈何的事情。

Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、 JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供 者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了 `java.util.ServiceLoader`类，以`META-INF/services`中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。

**OSGi实现模块化热部署**

OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。

在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更 加复杂的网状结构，当收到类加载请求时，`OSGi`将按照一定的顺序进行类搜索